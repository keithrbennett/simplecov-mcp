{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"CovLoupe  <p>   An MCP server, command line utility, and library for Ruby SimpleCov test coverage analysis. </p> <p> Documentation Website </p> <p> </p>"},{"location":"#what-is-cov-loupe","title":"What is cov-loupe?","text":"<p>cov-loupe makes SimpleCov coverage data queryable and actionable through three interfaces:</p> <ul> <li>MCP server - Lets AI assistants analyze your coverage</li> <li>CLI - Fast command-line coverage reports and queries</li> <li>Ruby library - Programmatic API for custom tooling</li> </ul> <p>Works with any SimpleCov-generated <code>.resultset.json</code> file\u2014no runtime dependency on your test suite.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\u2705 Multiple interfaces - MCP server, CLI, and Ruby API</li> <li>Annotated source code - <code>-s full|uncovered</code> / <code>--source full|uncovered</code> with <code>-c N</code> / <code>--context-lines N</code> for context lines</li> <li>\u2705 Staleness detection - Identify outdated coverage (missing files, timestamp mismatches, line count changes)</li> <li>\u2705 Multi-suite support - Automatic merging of multiple test suites (RSpec + Cucumber, etc.)</li> <li>\u2705 Flexible path resolution - Works with absolute or relative paths</li> <li>\u2705 Comprehensive error handling - Context-aware messages for each mode</li> </ul>"},{"location":"#practical-use-cases","title":"Practical Use Cases","text":"<ul> <li>Query coverage data from AI assistants, e.g.:</li> <li>\"Using cov-loupe, analyze test coverage data and write a report to a markdown file containing a free text analysis of each issue and then two tables, one sorted in descending order of urgency, the other in ascending order of level of effort.\"</li> <li>\"Using cov-loupe, generate a table of directories and their average coverage rates, in ascending order of coverage.\"</li> <li>Find files with the lowest coverage</li> <li>Investigate specific files or directories</li> <li>Generate CI/CD coverage reports</li> <li>Create custom pass/fail predicates for scripts and CI - use the library API or CLI JSON output to implement arbitrarily complex coverage rules beyond simple thresholds (e.g., require higher coverage for critical paths, exempt test utilities, track coverage trends)</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>gem install cov-loupe\n</code></pre>"},{"location":"#upgrading","title":"Upgrading","text":"<p>If you are upgrading from a previous version, please refer to the Migration Guides.</p>"},{"location":"#generate-coverage-data","title":"Generate Coverage Data","text":"<pre><code># Run your tests with SimpleCov enabled\nbundle exec rspec  # or your test command\n\n# Verify coverage was generated\nls -l coverage/.resultset.json\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>CLI - View Coverage Table: <pre><code>cov-loupe\n</code></pre></p> <p>CLI - Check Specific File: <pre><code>cov-loupe summary lib/cov_loupe/model.rb\ncov-loupe uncovered lib/cov_loupe/cli.rb\n</code></pre></p> <p>CLI - Find the Project Homepage Fast: Run <code>cov-loupe -h</code> and the banner's second line shows the repository URL. Some terminal applications (e.g. iTerm2) will enable direct clicking the link using modifier keys such as <code>Cmd</code> or <code>Alt</code>. <pre><code>Usage:      cov-loupe [options] [subcommand] [args]\nRepository: https://github.com/keithrbennett/cov-loupe  # &lt;--- Project URL ---\n</code></pre></p> <p>Ruby Library: <pre><code>require \"cov_loupe\"\n\nmodel = CovLoupe::CoverageModel.new\nlist_result = model.list\nfiles = list_result[\"files\"]\n# =&gt; [{ \"file\" =&gt; \"lib/cov_loupe/model.rb\", \"covered\" =&gt; 114, \"total\" =&gt; 118, \"percentage\" =&gt; 96.61, \"stale\" =&gt; false }, ...]\n\nsummary = model.summary_for(\"lib/cov_loupe/model.rb\")\n# =&gt; { \"file\" =&gt; \"lib/cov_loupe/model.rb\", \"summary\" =&gt; { \"covered\" =&gt; 114, \"total\" =&gt; 118, \"percentage\" =&gt; 96.61 } }\n</code></pre></p> <p>For advanced use cases, multiple models can each have their own data source and log file. See Library API for details.</p> <p>MCP Server: See MCP Integration Guide for AI assistant setup.</p>"},{"location":"#multi-suite-coverage","title":"Multi-Suite Coverage","text":"<p>Projects with multiple test suites (RSpec + Cucumber, etc.) are automatically merged. See Multi-Suite Coverage Merging for details and current limitations.</p>"},{"location":"#documentation-index","title":"Documentation Index","text":"<p>Full documentation is available at https://keithrbennett.github.io/cov-loupe/.</p> <p>User Guides:</p> <ul> <li>Quick Start - Get up and running in 3 steps</li> <li>User Docs Overview - Map of all end-user guides</li> <li>Installation - Setup for different environments</li> <li>CLI Usage - Command-line reference</li> <li>Examples - Common use cases</li> <li>Advanced Usage - Staleness detection, error modes, path resolution</li> <li>Library API - Ruby API documentation</li> <li>Error Handling - Error modes and exceptions</li> <li>MCP Integration - AI assistant configuration</li> <li>Troubleshooting - Common issues</li> </ul> <p>Special Topics &amp; Prompts:</p> <ul> <li>CLI Fallback for LLMs - When MCP isn't available</li> <li>Sample MCP Prompts - Ready-to-use ChatGPT/Claude/Gemini prompts</li> <li>Migration Guides</li> <li>Migrate to v4</li> <li>Migrate to v3</li> <li>Migrate to v2</li> </ul> <p>Developer Docs:</p> <ul> <li>Developer Docs Overview - Entry point for contributors</li> <li>Architecture - Design and internals</li> <li>Development Guide - Local dev workflow</li> <li>Releasing - Release checklist</li> <li>Future Enhancements - Planned improvements</li> <li>Architecture Decision Records - Design history</li> </ul> <p>Project Docs &amp; Examples:</p> <ul> <li>Contributing</li> <li>Code of Conduct</li> <li>Release Notes</li> <li>License</li> <li>MCP Input Examples</li> <li>Predicate Examples</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Ruby &gt;= 3.2 (required by <code>mcp</code> gem dependency)</li> <li>SimpleCov-generated <code>.resultset.json</code> file</li> <li><code>simplecov</code> gem &gt;= 0.21</li> </ul>"},{"location":"#configuring-the-resultset","title":"Configuring the Resultset","text":"<p><code>cov-loupe</code> automatically searches for <code>.resultset.json</code> in standard locations (<code>coverage/.resultset.json</code>, <code>.resultset.json</code>, <code>tmp/.resultset.json</code>). For non-standard locations:</p> <pre><code># Command-line option (highest priority) - use -r or --resultset\ncov-loupe -r /path/to/your/coverage\n\n# Environment variable (project-wide default)\nexport COV_LOUPE_OPTS=\"-r /path/to/your/coverage\"\n\n# MCP server configuration\n# Add to your MCP client config (used as defaults for MCP tools):\n# \"args\": [\"-r\", \"/path/to/your/coverage\"]\n</code></pre> <p>MCP precedence: For MCP tool calls, per-request JSON parameters win over the CLI args used to start the server (including <code>COV_LOUPE_OPTS</code>). If neither is provided, built-in defaults are used (<code>root: '.'</code>, <code>raise_on_stale: false</code>, etc.). Coverage data is cached globally and automatically reloaded when the resultset file changes.</p> <p>See CLI Usage Guide for complete details.</p>"},{"location":"#common-workflows","title":"Common Workflows","text":""},{"location":"#find-coverage-gaps","title":"Find Coverage Gaps","text":"<pre><code># Files with worst coverage\ncov-loupe -o d list           # -o = --sort-order, d = descending (worst at end)\ncov-loupe list | less         # display table in pager, best files first (worst at end)\ncov-loupe list | head -10     # truncate the table\n\n# Filter to specific patterns (see COV_LOUPE_OPTS best practice below)\ncov-loupe -g \"lib/cov_loupe/tools/**/*.rb\" list  # -g = --tracked-globs\n\n# Export for analysis\ncov-loupe -fJ list &gt; coverage-report.json\n</code></pre>"},{"location":"#best-practice-match-simplecov-configuration","title":"Best Practice: Match SimpleCov Configuration","text":"<p>For accurate coverage tracking and validation, set <code>COV_LOUPE_OPTS</code> to match your SimpleCov <code>track_files</code> patterns:</p> <pre><code># In spec_helper.rb or rails_helper.rb\nSimpleCov.start do\n  add_filter '/spec/'\n  track_files 'lib/**/*.rb'\n  track_files 'app/**/*.rb'\nend\n</code></pre> <pre><code># In your shell config (.bashrc, .zshrc, etc.)\nexport COV_LOUPE_OPTS=\"--tracked-globs lib/**/*.rb,app/**/*.rb\"\n</code></pre> <p>This ensures <code>list</code> and <code>totals</code> output matches SimpleCov's scope and <code>missing_tracked_files</code> (in <code>list</code>) / <code>missing_from_coverage</code> (in <code>totals</code>) report meaningful gaps.</p> <p>Note: By default, <code>--tracked-globs</code> is empty (shows all files in the resultset). This prevents silently hiding coverage data that doesn't match assumed patterns.</p>"},{"location":"#working-with-json-output","title":"Working with JSON Output","text":"<p>The <code>-fJ</code> flag enables programmatic processing of coverage data using command-line JSON tools.</p> <p>Using jq: <pre><code># Filter files below 80% coverage\ncov-loupe -fJ list | jq '.files[] | select(.percentage &lt; 80)'\n</code></pre></p> <p>Using Ruby one-liners: <pre><code># Count files below threshold\ncov-loupe -fJ list | ruby -r json -e '\n  puts JSON.parse($stdin.read)[\"files\"].count { |f| f[\"percentage\"] &lt; 80 }\n'\n</code></pre></p> <p>Using rexe:</p> <p>rexe is a Ruby gem that enables shorter Ruby command lines by providing command-line options for input and output formats, plus other conveniences. It eliminates the need for explicit JSON parsing and formatting code.</p> <p>Install: <code>gem install rexe</code></p> <pre><code># Filter files below 80% coverage with pretty-printed JSON output\ncov-loupe -fJ list | rexe -ij -mb -oJ 'self[\"files\"].select { |f| f[\"percentage\"] &lt; 80 }'\n\n# Count files below threshold\ncov-loupe -fJ list | rexe -ij -mb -op 'self[\"files\"].count { |f| f[\"percentage\"] &lt; 80 }'\n\n# Human-readable output with AmazingPrint\ncov-loupe -fJ list | rexe -ij -mb -oa 'self[\"files\"].first(3)'\n</code></pre> <p>With rexe's <code>-ij -mb</code> options, <code>self</code> automatically becomes the parsed JSON object. The same holds true for JSON output -- using <code>-oJ</code> produces pretty-printed JSON without explicit formatting calls. Rexe also supports YAML input/output (<code>-iy</code>, <code>-oy</code>) and AmazingPrint output (<code>-oa</code>) for human consumption.</p>"},{"location":"#when-coverage-rows-are-skipped","title":"When Coverage Rows Are Skipped","text":"<p>If a file in the resultset is missing on disk or has corrupt data, the CLI now logs and warns after rendering the report so operators immediately see that totals may be incomplete. Example table output:</p> <pre><code>$ cov-loupe list\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 File                        \u2502 Covered \u2502 Total   \u2502 % Covered  \u2502 Stale \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 lib/foo.rb                  \u2502       2 \u2502       3 \u2502     66.67% \u2502       \u2502\n\u2502 lib/bar.rb                  \u2502       1 \u2502       3 \u2502     33.33% \u2502       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWARNING: 1 coverage row skipped due to errors:\n  - lib/deleted.rb: No coverage data found for file: lib/deleted.rb\nRun again with --raise-on-stale to exit when rows are skipped.\n</code></pre> <p>Pretty JSON (<code>-fJ</code>) reports still emit valid JSON to <code>stdout</code>; the warning continues to be printed on <code>stderr</code>:</p> <pre><code>$ cov-loupe -fJ list\n{\n  \"files\": [\n    { \"file\": \"lib/foo.rb\", \"covered\": 2, \"total\": 3, \"percentage\": 66.67, \"stale\": null },\n    { \"file\": \"lib/bar.rb\", \"covered\": 1, \"total\": 3, \"percentage\": 33.33, \"stale\": null }\n  ],\n  \"counts\": { \"total\": 2, \"ok\": 2, \"stale\": 0 }\n}\n\nWARNING: 1 coverage row skipped due to errors:\n  - lib/deleted.rb: No coverage data found for file: lib/deleted.rb\nRun again with --raise-on-stale to exit when rows are skipped.\n</code></pre> <p>Use <code>--raise-on-stale true</code> (or <code>-S true</code>) to turn these warnings into hard failures for CI pipelines.</p> <p>Run <code>rexe -h</code> to see all available options, or visit the rexe project page for more examples.</p> <p>For comprehensive JSON processing examples, see user/EXAMPLES.md.</p>"},{"location":"#cicd-integration","title":"CI/CD Integration","text":"<pre><code># Fail build if coverage is stale (--raise-on-stale or -S)\ncov-loupe --raise-on-stale true list || exit 1\n\n# Generate coverage report artifact\ncov-loupe -fJ list &gt; artifacts/coverage.json\n</code></pre>"},{"location":"#investigate-specific-files","title":"Investigate Specific Files","text":"<pre><code># Quick summary\ncov-loupe summary lib/cov_loupe/model.rb\n\n# See uncovered lines\ncov-loupe uncovered lib/cov_loupe/cli.rb\n\n# View in context\ncov-loupe -s u -c 3 uncovered lib/cov_loupe/cli.rb  # -s = --source (u = uncovered), -c = --context-lines\n\n# Detailed hit counts\ncov-loupe detailed lib/cov_loupe/util.rb\n\n# Project totals\ncov-loupe totals\ncov-loupe -fJ totals\n</code></pre>"},{"location":"#boolean-cli-options","title":"Boolean CLI Options","text":"<p>Boolean flags such as <code>--color</code> (short: <code>-C</code>) and <code>--raise-on-stale</code> (short: <code>-S</code>) require explicit boolean arguments. Recognized literals:</p> <code>yes</code> <code>no</code> <code>y</code> <code>n</code> <code>true</code> <code>false</code> <code>t</code> <code>f</code> <code>on</code> <code>off</code> <code>+</code> <code>-</code> <code>1</code> <code>0</code> <p>Each row lists the equivalent <code>true</code> token (left) and <code>false</code> token (right).</p> <pre><code>cov-loupe --color false        # disable ANSI colors explicitly\ncov-loupe -C false             # short form\ncov-loupe --raise-on-stale yes # enforce stale coverage failures\n</code></pre>"},{"location":"#commands-and-tools","title":"Commands and Tools","text":"<p>CLI Subcommands: <code>list</code>, <code>summary</code>, <code>uncovered</code>, <code>detailed</code>, <code>raw</code>, <code>totals</code>, <code>validate</code>, <code>version</code></p> <p>MCP Tools: <code>coverage_summary_tool</code>, <code>coverage_detailed_tool</code>, <code>coverage_raw_tool</code>, <code>uncovered_lines_tool</code>, <code>list_tool</code>, <code>coverage_totals_tool</code>, <code>coverage_table_tool</code>, <code>validate_tool</code>, <code>help_tool</code>, <code>version_tool</code></p> <p>\ud83d\udcd6 See also: - CLI Usage Guide - Complete command-line reference - MCP Integration Guide - MCP tools documentation</p>"},{"location":"#troubleshooting","title":"Troubleshooting","text":"<ul> <li>\"command not found\" - See Installation Guide</li> <li>\"cannot load such file -- mcp\" - Requires Ruby &gt;= 3.2. Verify: <code>ruby -v</code></li> <li>\"Could not find .resultset.json\" - Ensure SimpleCov is configured in your test suite, then run tests to generate coverage. See the Configuring the Resultset section for more details.</li> <li>MCP server won't connect - Check PATH and Ruby version in MCP Troubleshooting</li> <li>RVM in sandboxed environments (macOS) - RVM requires <code>/bin/ps</code> which may be blocked by sandbox restrictions. Use rbenv or chruby instead.</li> </ul> <p>For more detailed help, see the full Troubleshooting Guide.</p>"},{"location":"#development","title":"Development","text":"<pre><code># Clone and setup\ngit clone https://github.com/keithrbennett/cov-loupe.git\ncd cov-loupe\nbundle install\n\n# Run tests\nbundle exec rspec\n\n# Test locally\nbundle exec exe/cov-loupe\n\n# Build and install\ngem build cov-loupe.gemspec\ngem install cov-loupe-*.gem\n</code></pre> <p>See dev/DEVELOPMENT.md for more.</p>"},{"location":"#simplecov-dependency","title":"SimpleCov Dependency","text":"<p><code>cov-loupe</code> declares a runtime dependency on <code>simplecov</code> (&gt;= 0.21) to support multi-suite merging using SimpleCov's combine helpers. The dependency is lazy-loaded only when needed, ensuring fast startup for single-suite projects.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please:</p> <ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Add tests for new functionality</li> <li>Ensure all tests pass (<code>bundle exec rspec</code>)</li> <li>Submit a pull request</li> </ol>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE file for details.</p>"},{"location":"#links","title":"Links","text":"<ul> <li>GitHub: https://github.com/keithrbennett/cov-loupe</li> <li>RubyGems: https://rubygems.org/gems/cov-loupe</li> <li>Issues: https://github.com/keithrbennett/cov-loupe/issues</li> <li>Changelog: RELEASE_NOTES.md</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<p>\ud83d\udce6 Install: <code>gem install cov-loupe</code></p> <p>\ud83d\udcd6 Read: CLI Usage Guide | MCP Integration</p> <p>\ud83d\udc1b Report issues: GitHub Issues</p> <p>\u2b50 Star the repo if you find it useful!</p>"},{"location":"QUICKSTART/","title":"Quick Start","text":"<p>Back to main README</p> <p>Get up and running with cov-loupe in 3 steps.</p>"},{"location":"QUICKSTART/#1-install","title":"1. Install","text":"<pre><code>gem install cov-loupe\n</code></pre>"},{"location":"QUICKSTART/#2-generate-coverage","title":"2. Generate Coverage","text":"<p>Run your test suite with SimpleCov enabled:</p> <pre><code>bundle exec rspec  # or your test command\n</code></pre> <p>This creates <code>coverage/.resultset.json</code>.</p>"},{"location":"QUICKSTART/#3-view-coverage","title":"3. View Coverage","text":"<pre><code>cov-loupe\n</code></pre> <p>You'll see a table showing coverage for each file, sorted by highest coverage first (lowest at the bottom).</p>"},{"location":"QUICKSTART/#common-commands","title":"Common Commands","text":"<pre><code># Check a specific file\ncov-loupe summary lib/my_file.rb\n\n# See uncovered lines\ncov-loupe uncovered lib/my_file.rb\n\n# Get overall project stats\ncov-loupe totals\n\n# View all commands\ncov-loupe --help\n</code></pre>"},{"location":"QUICKSTART/#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide - Platform-specific setup, environment variables</li> <li>CLI Usage - Complete command reference</li> <li>Examples - Common workflows and recipes</li> <li>MCP Integration - Connect to AI assistants (Claude, ChatGPT)</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"QUICKSTART/#integration-with-ai-assistants","title":"Integration with AI Assistants","text":"<p>If you're using Claude Code, ChatGPT, or another MCP-compatible assistant:</p> <ol> <li>Install the MCP server (see MCP Integration Guide)</li> <li>Use ready-made prompts from Prompt Library</li> <li>Let AI analyze your coverage and suggest improvements</li> </ol> <p>Back to main README</p>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":"<p>Back to main README</p>"},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and users pledge to make participation in this project a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment include:</p> <ul> <li>Demonstrating empathy and kindness toward others  </li> <li>Being respectful of differing opinions, viewpoints, and experiences  </li> <li>Giving and gracefully accepting constructive feedback  </li> <li>Taking responsibility for our mistakes and learning from them  </li> <li>Focusing on what is best for the community, not just ourselves  </li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances  </li> <li>Trolling, insulting or derogatory comments, and personal or political attacks  </li> <li>Public or private harassment  </li> <li>Publishing others\u2019 private information, such as physical or email addresses, without explicit permission  </li> <li>Any other conduct which could reasonably be considered inappropriate in a professional setting  </li> </ul>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported through GitHub\u2019s Report Abuse form.</p> <p>If inappropriate behavior occurs in this repository\u2019s issues, pull requests, or discussions, the maintainer may delete comments, lock threads, or block offending users from further participation.</p> <p>These actions are at the sole discretion of the maintainer and are intended to maintain a safe, respectful, and productive environment for everyone.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies to all project spaces within this repository and also applies when an individual is officially representing the project or its community in public spaces.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at  https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>For answers to common questions, see the FAQ at  https://www.contributor-covenant.org/faq.</p>"},{"location":"contributing/","title":"Contributing to cov-loupe","text":"<p>Back to main README</p> <p>Thank you for your interest in contributing!  This project welcomes bug reports, improvements, and suggestions that make it more useful and reliable for the Ruby community.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"contributing/#1-reporting-issues","title":"1. Reporting Issues","text":"<ul> <li>Check existing issues before opening a new one.  </li> <li>Include clear reproduction steps, expected vs. actual results, and your Ruby version (<code>ruby -v</code>) and OS.  </li> <li>Keep discussion technical and respectful \u2014 see the Code of Conduct.</li> </ul>"},{"location":"contributing/#2-submitting-changes","title":"2. Submitting Changes","text":"<ol> <li>Fork the repository on GitHub.  </li> <li>Create a branch for your work: <pre><code>git checkout -b feature/my-change\n</code></pre></li> <li>Install dependencies: <pre><code>bundle install\n</code></pre></li> <li>Make your changes, conforming to the project's coding style.</li> <li>Run tests to verify your changes: <pre><code>bundle exec rspec\n</code></pre></li> <li>Lint the code: <pre><code>bundle exec rubocop\n</code></pre></li> <li>Commit changes with clear, concise messages following conventional commit style (e.g. <code>fix: handle missing file gracefully</code>).</li> <li>Push your branch and open a Pull Request against <code>main</code>.</li> </ol> <p>PRs should: - Include or update tests for new/changed behavior. - Pass all existing tests and RuboCop checks. - Update documentation or README examples if behavior changes.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>This project requires Ruby &gt;= 3.2 (due to the <code>mcp</code> gem dependency). Typical workflow:</p> <pre><code>git clone https://github.com/keithrbennett/cov-loupe.git\ncd cov-loupe\nbundle install\nrspec\n</code></pre> <p>Optional tools: - <code>rake</code> as an alternate way to run <code>rspec</code> and <code>rubocop</code> - <code>exe/cov-loupe</code> the CLI and MCP entry point, use for end-to-end runs</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>This project uses MkDocs with the Material theme to build and serve documentation.</p> <p>Quick start: <pre><code>pip3 install -r requirements.txt\nmkdocs serve  # View at http://127.0.0.1:8000\n</code></pre></p> <p>For detailed platform-specific installation instructions (macOS, Linux, Windows) and troubleshooting, see the Documentation Development section of the Development Guide</p>"},{"location":"contributing/#release-process-maintainer-only","title":"Release Process (maintainer only)","text":"<ol> <li>Update version in <code>lib/cov_loupe/version.rb</code></li> <li>Update <code>RELEASE_NOTES.md</code></li> <li>Commit, tag, and push:    <pre><code>git add -A\ngit commit -m \"Bump version to 1.0.0, update release notes\"\ngit tag -a v1.0.0 -m \"v1.0.0 - brief summary of release\"\ngit push origin main --tags\n</code></pre></li> <li>Build and publish:    <pre><code>gem build cov-loupe.gemspec\ngem push cov-loupe-#{version-string}.gem\n</code></pre></li> </ol>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please review and follow the Code of Conduct.  Instances of unacceptable behavior may be reported through GitHub\u2019s Report Abuse form.</p> <p>Thank you for helping improve cov-loupe!</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 Keith Bennett</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"release_notes/","title":"Release Notes","text":""},{"location":"release_notes/#release-notes_1","title":"Release Notes","text":"<p>Back to main README</p>"},{"location":"release_notes/#v400-v400pre-v400pre1-breaking","title":"v4.0.0, v4.0.0.pre, v4.0.0.pre.1 (Breaking)","text":"<ul> <li>Removed Branch Coverage Support: Removed logic that synthesized line coverage from branch-only coverage data. This feature was complex and rarely used. Users should use standard line coverage configuration in SimpleCov.</li> <li>Removed <code>docs/dev/BRANCH_ONLY_COVERAGE.md</code>.</li> <li>\u26a0\ufe0f MCP mode now requires <code>-m/--mode mcp</code> flag: Automatic mode detection has been removed. MCP users must update their MCP server configuration to include <code>-m mcp</code> or <code>--mode mcp</code> or the server will run in CLI mode and hang. See migration guide for setup commands.</li> <li>Old: Mode was auto-detected based on TTY/stdin status, with optional <code>--force-mode cli|mcp|auto</code> override</li> <li>New: Mode defaults to <code>cli</code>. Use <code>-m mcp</code> or <code>--mode mcp</code> to run as MCP server. No auto-detection.</li> <li>Rationale: Auto-detection caused issues with piped input, CI environments, and CLI-only flags (e.g., <code>cov-loupe --format json</code> would hang in MCP mode)</li> <li>Unified stale coverage enforcement: New <code>--raise-on-stale</code> / <code>raise_on_stale</code> boolean replaces the old <code>--staleness</code>/<code>check_stale</code> combo across CLI, Ruby, and MCP interfaces. When true, <code>cov-loupe</code> raises if any file or the project totals are stale; when false, staleness is reported but execution continues.</li> <li>Ruby API method renamed: <code>CoverageModel#all_files_coverage</code> renamed to <code>CoverageModel#list</code> for consistency with CLI subcommand naming.</li> <li>Ruby API return type changed: <code>CoverageModel#list</code> now returns a hash with comprehensive staleness information instead of just an array of files. The hash includes keys: <code>files</code> (array), <code>skipped_files</code>, <code>missing_tracked_files</code>, <code>newer_files</code>, and <code>deleted_files</code>. Update code to use <code>model.list['files']</code> when you need just the file array.</li> <li>Ruby API signature change: <code>CovLoupe::Resolvers::CoverageLineResolver</code> now requires <code>root:</code> (no default), and <code>ResolverHelpers.lookup_lines</code> / <code>create_coverage_resolver</code> require <code>root:</code> as well.</li> <li>Dependency update: Replaced unmaintained <code>awesome_print</code> with <code>amazing_print</code> (<code>~&gt; 2.0</code>).</li> <li>CLI: <code>--format amazing_print</code> is now the preferred way to specify the pretty-print formatter. <code>-f ap</code> and <code>--format awesome_print</code> are still supported.</li> <li>Library: <code>require 'awesome_print'</code> is replaced by <code>require 'amazing_print'</code>.</li> <li>Library: Internal format symbol changed from <code>:awesome_print</code> to <code>:amazing_print</code>.<ul> <li><code>CovLoupe::AppConfig#format</code> now returns <code>:amazing_print</code> when configured for that output.</li> <li><code>CovLoupe::Formatters.format(obj, :amazing_print)</code> is the new API method.</li> </ul> </li> <li>Internal Logger API changed: <code>CovLoupe::Logger.new</code> now requires <code>mode:</code> (symbol) instead of <code>mcp_mode:</code> (boolean).<ul> <li>Use <code>CovLoupe::Logger.new(target: t, mode: :cli|:mcp|:library)</code> instead of <code>mcp_mode: true/false</code>.</li> </ul> </li> <li>Deleted files now raise <code>FileNotFoundError</code>: Previously, querying a file that was deleted after coverage was generated would incorrectly return stale coverage data. This was misleading for metrics and violated the documented API contract. Now properly raises <code>FileNotFoundError</code> for missing files, regardless of whether coverage data exists in the resultset.</li> <li>Old: <code>model.summary_for('deleted_file.rb')</code> would return coverage data with exit 0</li> <li>New: <code>model.summary_for('deleted_file.rb')</code> raises <code>CovLoupe::FileNotFoundError</code></li> <li>Rationale: Deleted files represent stale data that pollutes metrics. The API documentation already promised <code>FileNotFoundError</code> for missing files; the implementation now matches the contract.</li> <li>Staleness check errors now return 'E' marker: Previously, when staleness checking itself failed (e.g., file permission errors, resolver failures, unexpected exceptions), the <code>stale</code> field returned <code>false</code>, making errors indistinguishable from fresh files. Now returns <code>'E'</code> to explicitly indicate a failed staleness check.</li> <li>Old: <code>{ \"file\": \"...\", \"stale\": false }</code> (error silently treated as fresh)</li> <li>New: <code>{ \"file\": \"...\", \"stale\": \"E\" }</code> (error explicitly flagged)</li> <li>Impact: Code checking <code>stale == false</code> or using truthiness checks (<code>if payload['stale']</code>) will need updating. Error is still logged for debugging.</li> <li>Frequency: Rare - only affects error conditions during staleness checking (not normal staleness detection)</li> <li>Path resolution now handles case-sensitivity and path separators correctly (NEW in v4.0.0): Path normalization now independently handles two concerns: (1) slash normalization for Windows backslashes, and (2) case-folding for case-insensitive volumes. Case-sensitivity is detected lazily on first use by testing the project root volume (prefers using existing files via <code>File.identical?</code> to avoid writes; falls back to temporary file creation if needed).</li> <li>Windows: Paths are now case-insensitive with backslash normalization (<code>C:\\Foo\\Bar.rb</code> matches <code>c:/foo/bar.rb</code>)</li> <li>macOS: Most macOS users have case-insensitive APFS volumes - path lookups like <code>lib/Foo.rb</code> will now correctly match <code>lib/foo.rb</code> in coverage data. This may surface previously-hidden case mismatches in test code.</li> <li>Linux: Typically case-sensitive (no change in behavior for most users)</li> <li>Special cases: Correctly handles case-sensitive APFS volumes (macOS formatted with <code>-s</code>) and external drives</li> <li>Limitation: All coverage files are assumed to be on the same volume as the project root. Mixed-volume coverage data (e.g., files from both case-sensitive and case-insensitive volumes) is not supported.</li> <li>Why: A filesystem type (APFS, ext4, NTFS) can have multiple volumes with different case-sensitivity settings. Platform assumptions are insufficient. Runtime detection is the only accurate approach.</li> <li>Stricter staleness detection for line count mismatches: Removed the trailing newline adjustment heuristic that could mask legitimate code additions (false negatives). Previously, if a file's line count was exactly one more than the coverage data and the file was missing a trailing newline, the staleness checker would adjust the count and report the file as fresh. This heuristic was risky because it couldn't distinguish between a harmless missing newline and a developer adding a line of code while simultaneously removing the trailing newline. All line count mismatches are now treated as significant staleness indicators.</li> <li>Old: File with 101 lines (no trailing newline) matching 100 coverage lines \u2192 reported as fresh (adjusted)</li> <li>New: File with 101 lines matching 100 coverage lines \u2192 reported as stale (length mismatch)</li> <li>Impact: More conservative staleness detection may flag some files that were previously considered fresh. This is intentional to prevent false negatives.</li> <li>Rationale: Prioritizes accuracy over convenience. Better to flag a file as stale and re-run tests than to miss actual code changes.</li> <li>\u26a0\ufe0f <code>--tracked-globs</code> default changed to empty array: The <code>--tracked-globs</code> CLI option now defaults to <code>[]</code> (empty) instead of <code>lib/**/*.rb,app/**/*.rb,src/**/*.rb</code>. The Ruby API also changed from <code>nil</code> to <code>[]</code> for consistency (both behave identically, so no functional change). This prevents silently excluding coverage results that don't match assumed project patterns and avoids false positives when detecting missing files.</li> <li>Old: CLI defaulted to <code>lib/**/*.rb,app/**/*.rb,src/**/*.rb</code> - files outside these patterns were excluded from output</li> <li>New: CLI and Ruby API default to <code>[]</code> (empty) - shows all files in the resultset without filtering</li> <li>Affects: CLI (<code>cov-loupe list</code>) and Ruby API signature (<code>CoverageModel.new</code> - behavior unchanged, only default parameter value changed for consistency)</li> <li>Impact: CLI users who relied on automatic filtering or missing-file detection will need to explicitly set <code>--tracked-globs</code></li> <li>Migration (CLI): Set <code>COV_LOUPE_OPTS=\"--tracked-globs lib/**/*.rb,app/**/*.rb\"</code> in your shell config to match your SimpleCov <code>track_files</code> patterns</li> <li>Migration (Ruby API): No action needed - behavior unchanged (nil and [] both normalize to empty array)</li> <li>Rationale:<ul> <li>Transparency: Shows all coverage data without hiding files that don't match assumptions</li> <li>No false positives: Broad patterns flag migrations, bin scripts, etc. as \"missing\"</li> <li>Project variety: Different projects use different structures (lib/, app/, src/, config/, etc.)</li> </ul> </li> <li>Important: Files lacking any coverage at all (not loaded during tests) will not appear in the resultset and therefore won't be visible with the default empty array. To detect such files, you must set <code>--tracked-globs</code></li> </ul>"},{"location":"release_notes/#enhancements","title":"\u2728 Enhancements","text":"<ul> <li> <p>New <code>-f p</code> shortcut for pretty-json format: Added <code>-f p</code> as a shortcut for <code>--format pretty-json</code>. This follows the pattern of other format shortcuts (<code>-f j</code> for json, <code>-f y</code> for yaml, etc.). The previous <code>-f J</code> shortcut no longer works (use <code>-f p</code> instead).</p> </li> <li> <p>Project totals now include coverage breakdowns: The <code>totals</code> subcommand and <code>coverage_totals_tool</code> now return explicit <code>with_coverage</code> and <code>without_coverage</code> breakdowns, plus tracking metadata, so totals clearly separate fresh coverage from missing coverage.</p> </li> </ul> <p>Example output: <pre><code>{\n  \"lines\": { \"total\": 100, \"covered\": 90, \"uncovered\": 10, \"percent_covered\": 90.0 },\n  \"tracking\": { \"enabled\": true, \"globs\": [\"lib/**/*.rb\"] },\n  \"files\": {\n    \"total\": 10,\n    \"with_coverage\": {\n      \"total\": 9,\n      \"ok\": 8,\n      \"stale\": {\n        \"total\": 1,\n        \"by_type\": {\n          \"missing_from_disk\": 0,\n          \"newer\": 1,\n          \"length_mismatch\": 0,\n          \"unreadable\": 0\n        }\n      }\n    },\n    \"without_coverage\": {\n      \"total\": 1,\n      \"by_type\": {\n        \"missing_from_coverage\": 1,\n        \"unreadable\": 0,\n        \"skipped\": 0\n      }\n    }\n  }\n}\n</code></pre></p> <p>Table format also includes a file breakdown section after totals.</p> <p>Breaking change: The JSON shape for totals has changed (the old <code>percentage</code> and <code>excluded_files</code> fields are removed).</p> <p>\ud83d\udcd6 For complete migration guide, see docs/user/migrations/MIGRATING_TO_V4.md</p>"},{"location":"release_notes/#v300","title":"v3.0.0","text":""},{"location":"release_notes/#breaking-change-gem-renamed-simplecov-mcp-cov-loupe","title":"\ud83d\udea8 BREAKING CHANGE: GEM RENAMED simplecov-mcp \u2192 cov-loupe","text":"<p>This is a major version bump because the gem has been completely renamed from simplecov-mcp to cov-loupe. This requires manual intervention to migrate.</p>"},{"location":"release_notes/#what-changed","title":"What Changed","text":"<ul> <li>Gem name: <code>simplecov-mcp</code> \u2192 <code>cov-loupe</code></li> <li>Executable: <code>simplecov-mcp</code> \u2192 <code>cov-loupe</code></li> <li>Repository: <code>github.com/keithrbennett/simplecov-mcp</code> \u2192 <code>github.com/keithrbennett/cov-loupe</code></li> <li>Module name: <code>SimpleCovMcp</code> \u2192 <code>CovLoupe</code></li> <li>Require path: <code>require 'simplecov_mcp'</code> \u2192 <code>require 'cov_loupe'</code></li> <li>Environment variable: <code>SIMPLECOV_MCP_OPTS</code> \u2192 <code>COV_LOUPE_OPTS</code></li> <li>Log file: <code>simplecov_mcp.log</code> \u2192 <code>cov_loupe.log</code></li> <li>Documentation alias: <code>smcp</code> \u2192 <code>clp</code></li> </ul>"},{"location":"release_notes/#what-stayed-the-same","title":"What Stayed the Same","text":"<ul> <li>All functionality: No breaking changes to features or APIs</li> </ul>"},{"location":"release_notes/#migration-steps","title":"Migration Steps","text":"<ol> <li>Uninstall old gem: <code>gem uninstall simplecov-mcp</code></li> <li>Install new gem: <code>gem install cov-loupe</code></li> <li>Update scripts/aliases: Change <code>simplecov-mcp</code> to <code>cov-loupe</code></li> <li>Update Ruby code: Rename <code>SimpleCovMcp</code> to <code>CovLoupe</code> and update requires.</li> <li>Update env vars: Rename <code>SIMPLECOV_MCP_OPTS</code> to <code>COV_LOUPE_OPTS</code></li> </ol> <p>\ud83d\udcd6 For complete migration guide, see docs/user/migrations/MIGRATING_TO_V3.md</p> <p>Note: The old <code>simplecov-mcp</code> gem (v2.0.1) will remain available on RubyGems but will not receive further updates.</p>"},{"location":"release_notes/#other-changes","title":"\u2728 Other Changes","text":"<ul> <li>Add logo and avatar images, display in readme</li> </ul>"},{"location":"release_notes/#v201","title":"v2.0.1","text":"<ul> <li>Improve help text</li> <li>Add a prompt</li> </ul>"},{"location":"release_notes/#v200","title":"v2.0.0","text":""},{"location":"release_notes/#breaking-changes","title":"\ud83d\udea8 BREAKING CHANGES","text":"<p>Version 2.0 introduces several breaking changes to improve consistency and align with Ruby conventions. Key changes include:</p> <ul> <li>CLI: Global options must now precede subcommands (e.g., <code>simplecov-mcp --format json list</code> instead of <code>simplecov-mcp list --format json</code>)</li> <li>Options renamed: <code>--stale</code> \u2192 <code>--staleness</code>, <code>--source-context</code> \u2192 <code>--context-lines</code>, <code>--json</code> \u2192 <code>--format</code></li> <li>Error modes: <code>on</code> \u2192 <code>log</code>, <code>trace</code> \u2192 <code>debug</code></li> <li>Subcommands: <code>--success-predicate</code> flag replaced with <code>validate</code> subcommand</li> <li>Source option: Now requires explicit mode (<code>--source full</code> or <code>--source uncovered</code>)</li> <li>Default sort: Changed from ascending to descending (best coverage first)</li> <li>MCP tools: Parameter <code>stale</code> renamed to <code>staleness</code>, error modes updated</li> <li>Ruby API: <code>CLIConfig</code> renamed to <code>AppConfig</code>, field changes (<code>json</code> \u2192 <code>format</code>, <code>stale_mode</code> \u2192 <code>staleness</code>)</li> </ul> <p>\ud83d\udcd6 For complete migration guide with examples, see docs/user/migrations/MIGRATING_TO_V2.md</p>"},{"location":"release_notes/#new-features","title":"\u2728 New Features","text":"<ul> <li>validate subcommand: File mode (<code>validate &lt;file&gt;</code>) and inline mode (<code>validate -i &lt;code&gt;</code>)</li> <li>MCP support: New <code>validate_tool</code> with <code>code</code> and <code>file</code> parameters</li> </ul>"},{"location":"release_notes/#v110","title":"v1.1.0","text":"<ul> <li>Add a <code>totals</code> CLI subcommand and matching <code>coverage_totals_tool</code> that report covered/total/uncovered line counts plus the average coverage percent.</li> <li>Refactor command line and environment argument handling</li> </ul>"},{"location":"release_notes/#v101-2025-10-23","title":"v1.0.1 (2025-10-23)","text":"<ul> <li>Make error output more helpful when a result set file is not found, esp. when the command name is run without args in a non-project directory.</li> </ul>"},{"location":"release_notes/#v100-2025-10-18","title":"v1.0.0 (2025-10-18)","text":"<p>\ud83c\udf89 Major Release: Production-Ready Coverage Analysis Tool</p> <p>This release represents a complete maturation of simplecov-mcp from experimental proof-of-concept to production-ready tool. The v1.0.0 milestone brings comprehensive documentation, robust error handling, extensive test coverage, architectural improvements, and a polished user experience across all three interfaces (MCP server, CLI, and Ruby library).</p>"},{"location":"release_notes/#major-features","title":"\ud83c\udf1f Major Features","text":""},{"location":"release_notes/#multi-suite-coverage-merging","title":"Multi-Suite Coverage Merging","text":"<ul> <li>Automatic merging of multiple test suites from a single <code>.resultset.json</code> file (e.g., RSpec + Cucumber)</li> <li>Lazy loading of SimpleCov dependency - only loaded when multi-suite merging is needed</li> <li>Performance optimized - single-suite projects remain fast with no SimpleCov runtime overhead</li> <li>See <code>docs/user/ADVANCED_USAGE.md</code> for configuration details</li> </ul>"},{"location":"release_notes/#branch-coverage-support-with-limitations","title":"Branch Coverage Support (with Limitations)","text":"<ul> <li>Branch-level data handling - reads and processes SimpleCov branch coverage data</li> <li>Line-level aggregation - branch hits are summed per line since individual branch tracking isn't supported yet</li> <li>Graceful degradation - use native SimpleCov HTML reports for detailed branch-by-branch analysis</li> <li>See <code>docs/dev/BRANCH_ONLY_COVERAGE.md</code> for details and limitations</li> </ul>"},{"location":"release_notes/#enhanced-staleness-detection","title":"Enhanced Staleness Detection","text":"<ul> <li>Three staleness indicators:</li> <li><code>M</code> - File modified after coverage run (timestamp-based)</li> <li><code>T</code> - File timestamp unavailable or coverage missing</li> <li><code>L</code> - Line count mismatch between source and coverage</li> <li>Per-file reporting in all outputs (CLI tables, JSON, MCP responses)</li> <li>Configurable modes: <code>--stale off|error</code> for CI/CD integration</li> <li>Improved edge case handling for files outside project root</li> </ul>"},{"location":"release_notes/#success-predicates-for-cicd","title":"Success Predicates for CI/CD","text":"<ul> <li>Custom exit code logic via <code>--success-predicate</code> flag</li> <li>Ruby code evaluation - Load lambdas or other callable objects to define coverage policies</li> <li>Flexible policy definitions - Check minimum thresholds, file-based rules, directory-specific requirements, etc.</li> <li>Examples provided in <code>examples/success_predicates/</code>:</li> <li>Project-wide minimum coverage</li> <li>Per-directory thresholds</li> <li>Class-based policies</li> <li>Maximum low-coverage file count</li> <li>See <code>docs/user/ADVANCED_USAGE.md#success-predicates</code> for usage and security considerations</li> </ul>"},{"location":"release_notes/#comprehensive-cli-enhancements","title":"Comprehensive CLI Enhancements","text":"<ul> <li>Default command improved - <code>simplecov-mcp</code> shows sorted coverage table (no subcommand needed)</li> <li>Flexible sorting - <code>--sort-order a|d</code> or <code>--sort-order ascending|descending</code></li> <li>Annotated source code - <code>--source=full|uncovered</code> with <code>--source-context N</code> for context lines</li> <li>Optional colorization - <code>-C/--color [BOOLEAN]</code> for source code output</li> <li>Tracked globs - <code>--tracked-globs PATTERN</code> to filter files or detect new untested files</li> <li>User-specified defaults via environment variable - <code>SIMPLECOV_MCP_OPTS</code> environment variable value is prepended to ARGV for option parsing</li> <li>Configurable logging - <code>--log-file PATH</code> or <code>stdout</code>/<code>stderr</code> (default: <code>./simplecov_mcp.log</code>)</li> </ul>"},{"location":"release_notes/#architecture-code-quality","title":"\ud83c\udfd7\ufe0f Architecture &amp; Code Quality","text":""},{"location":"release_notes/#major-refactoring","title":"Major Refactoring","text":"<ul> <li>Command pattern - CLI subcommands extracted to individual command classes (<code>lib/simplecov_mcp/commands/</code>)</li> <li>Presenter pattern - Shared presentation logic for all output formats (<code>lib/simplecov_mcp/presenters/</code>)</li> <li>Resolver pattern - Path and coverage line resolution extracted to dedicated classes (<code>lib/simplecov_mcp/resolvers/</code>)</li> <li>Factory pattern - Error handlers and command instantiation centralized</li> <li>Shared test examples - DRY test suite with shared behaviors documented in <code>spec/shared_examples/README.md</code></li> </ul>"},{"location":"release_notes/#error-handling-overhaul","title":"Error Handling Overhaul","text":"<ul> <li>Context-aware errors - Different error strategies for CLI, library, and MCP server modes</li> <li>Three error modes: <code>off</code>, <code>log</code>, <code>debug</code> (configurable via <code>--error-mode</code> or <code>SIMPLECOV_MCP_OPTS</code>)</li> <li>Custom exception hierarchy - <code>SimpleCovMcp::Error</code> base class with specific subtypes</li> <li>Logging fallback - Graceful degradation to stderr when log file is unavailable (CLI/library modes only)</li> <li>Structured MCP errors - JSON-RPC compliant error responses with proper error codes</li> <li>See <code>docs/user/ERROR_HANDLING.md</code> for complete reference</li> </ul>"},{"location":"release_notes/#improved-path-resolution","title":"Improved Path Resolution","text":"<ul> <li>Multi-strategy matching:</li> <li>Exact absolute path</li> <li>Path without working directory prefix</li> <li>Basename (filename) fallback</li> <li>New <code>PathRelativizer</code> class - Consistent relative path handling across codebase</li> <li>Configurable root - <code>--root PATH</code> option to resolve relative paths against different directories</li> </ul>"},{"location":"release_notes/#test-coverage-excellence","title":"Test Coverage Excellence","text":"<ul> <li>Comprehensive test suite - 546 examples across 55 test files</li> <li>High coverage - 98.49% line coverage, 90.36% branch coverage (self-reported via SimpleCov)</li> <li>Integration tests - Real-world scenarios in <code>spec/integration_spec.rb</code></li> <li>MCP integration tests - JSON-RPC protocol validation in <code>spec/mcp_server_integration_spec.rb</code></li> <li>Edge case testing - Exhaustive error condition coverage in <code>spec/errors_edge_cases_spec.rb</code></li> <li>Test documentation - <code>spec/MCP_INTEGRATION_TESTS_README.md</code> and <code>spec/TIMESTAMPS.md</code></li> </ul>"},{"location":"release_notes/#documentation-overhaul","title":"\ud83d\udcda Documentation Overhaul","text":""},{"location":"release_notes/#comprehensive-documentation-suite","title":"Comprehensive Documentation Suite","text":"<p>All documentation moved under audience-specific directories (<code>docs/user</code> for usage guides, <code>docs/dev</code> for contributor content):</p> <p>Getting Started: - <code>docs/user/INSTALLATION.md</code> - Installation for all environments (gem, Bundler, source, RVM, rbenv, etc.) - <code>docs/user/CLI_USAGE.md</code> - Complete command-line reference with examples - <code>docs/user/EXAMPLES.md</code> - Common use cases and workflows</p> <p>Advanced Usage: - <code>docs/user/ADVANCED_USAGE.md</code> - Success predicates, multi-suite merging, resultset configuration - <code>docs/user/MCP_INTEGRATION.md</code> - AI assistant setup (Claude Code, Cursor, Zed, etc.) - <code>docs/user/LIBRARY_API.md</code> - Complete Ruby API documentation with recipes</p> <p>Reference: - <code>docs/user/ERROR_HANDLING.md</code> - Error modes, exception types, logging - <code>docs/user/TROUBLESHOOTING.md</code> - Common issues and solutions - <code>docs/dev/ARCHITECTURE.md</code> - System design and component overview - <code>docs/dev/DEVELOPMENT.md</code> - Contributing guide - <code>docs/dev/BRANCH_ONLY_COVERAGE.md</code> - Branch coverage support and limitations</p> <p>Architectural Decisions: - <code>docs/dev/arch-decisions/*.md</code> - 5 detailed ADRs documenting major design decisions - <code>docs/dev/arch-decisions/README.md</code> - Index and overview</p> <p>Additional Resources: - <code>docs/dev/presentations/simplecov-mcp-presentation.md</code> - Slide deck for talks/demos - <code>examples/success_predicates/README.md</code> - Success predicate examples and patterns - <code>prompts/*.md</code> - AI prompt templates for coverage analysis</p>"},{"location":"release_notes/#improved-readme","title":"Improved README","text":"<ul> <li>Value proposition first - Clear explanation of what simplecov-mcp does and why it matters</li> <li>Quick Start section - Get running in 3 steps</li> <li>Audience-based organization - Documentation grouped by user journey (Getting Started, Advanced, Reference)</li> <li>Next Steps section - Clear calls-to-action at end</li> <li>Reduced length - Main README streamlined from 967 lines to 272 lines by extracting content to dedicated docs</li> </ul>"},{"location":"release_notes/#developer-experience","title":"\ud83d\udd27 Developer Experience","text":""},{"location":"release_notes/#configuration-improvements","title":"Configuration Improvements","text":"<ul> <li>Environment variable options - <code>SIMPLECOV_MCP_OPTS</code> prepended to ARGV for option parsing</li> <li>Force CLI mode - <code>--force-cli</code> flag to disable MCP server mode detection</li> <li>Flexible resultset location - Multiple resolution strategies with sensible defaults</li> <li>Normalized options - Consistent internal representation of enumerated options (symbols)</li> </ul>"},{"location":"release_notes/#logging-enhancements","title":"Logging Enhancements","text":"<ul> <li>Configurable log file - <code>--log-file PATH</code> (or <code>-l</code>) command-line option</li> <li>Programmatic control - <code>SimpleCovMcp.default_log_file=</code> and <code>SimpleCovMcp.active_log_file=</code> for runtime changes</li> <li>Mode-aware logging - MCP mode prohibits <code>stdout</code> logging (would corrupt JSON-RPC protocol), allows <code>stderr</code> or file</li> <li>Timestamped log entries - All log messages include ISO 8601 timestamps</li> </ul>"},{"location":"release_notes/#build-release","title":"Build &amp; Release","text":"<ul> <li>Dependabot integration - Automated dependency updates (<code>.github/dependabot.yml</code>)</li> <li>License added - MIT License (<code>LICENSE</code> file)</li> <li>Gemspec improvements - Tighter version constraints, correct file list</li> <li>Version command - <code>simplecov-mcp version</code> for easy version checking</li> </ul>"},{"location":"release_notes/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":""},{"location":"release_notes/#cli-fixes","title":"CLI Fixes","text":"<ul> <li>Subcommand extraction - Fixed <code>--source</code> flag incorrectly treated as subcommand (see the subcommand list in <code>lib/simplecov_mcp/constants.rb</code>)</li> <li>Option argument parsing - Centralized list of options expecting arguments to prevent similar bugs</li> <li>Invalid option handling - Clean error messages for unrecognized CLI flags</li> <li>Help text formatting - Improved readability and consistency</li> </ul>"},{"location":"release_notes/#path-resolution-fixes","title":"Path Resolution Fixes","text":"<ul> <li>Double-path bug - Fixed resultset resolver creating invalid paths like <code>spec/fixtures/project1/spec/fixtures/project1/coverage</code></li> <li>Relative path handling - Stopped indiscriminately running <code>File.absolute_path(resultset, @root)</code> on already-absolute paths</li> <li>Files outside root - Graceful handling of coverage data for files outside project root directory</li> </ul>"},{"location":"release_notes/#coverage-processing-fixes","title":"Coverage Processing Fixes","text":"<ul> <li>Branch-only coverage - No longer crashes on resultsets with branch data but no line data</li> <li>String timestamps - Handles both integer and string timestamps in resultset JSON</li> <li>Multiple resultsets - Proper merging when <code>.resultset.json</code> contains multiple test suite entries</li> <li>Line count mismatches - Accurate staleness detection handles trailing newline differences between source and coverage data</li> </ul>"},{"location":"release_notes/#error-handling-fixes","title":"Error Handling Fixes","text":"<ul> <li>Library mode exceptions - Consistent <code>SimpleCovMcp::Error</code> exceptions (not bare <code>RuntimeError</code>)</li> <li>MCP error format - JSON-RPC compliant error responses</li> <li>Missing resultset - Clear error messages with actionable suggestions</li> <li>Fallback logging - stderr logging when primary log destination is unavailable (not in MCP mode)</li> </ul>"},{"location":"release_notes/#breaking-changes_1","title":"\ud83d\udd04 Breaking Changes","text":""},{"location":"release_notes/#naming-consistency","title":"Naming Consistency","text":"<ul> <li>Module name - Now consistently <code>SimpleCovMcp</code> (matching SimpleCov's single-word style)</li> <li>Legacy shim removed - <code>SimpleCov::Mcp</code> entry point no longer supported</li> <li>Require path - Changed from <code>simple_cov/mcp</code> to <code>simplecov_mcp</code></li> <li>File paths - All files moved from <code>lib/simple_cov_mcp/</code> to <code>lib/simplecov_mcp/</code></li> </ul>"},{"location":"release_notes/#option-changes","title":"Option Changes","text":"<ul> <li>Removed environment variables: <code>SIMPLECOV_RESULTSET</code>, <code>SIMPLECOV_MCP_CLI</code>, <code>SIMPLECOV_MCP_DEBUG</code>, <code>SIMPLECOV_MCP_LOG</code></li> <li>New environment variable: <code>SIMPLECOV_MCP_OPTS</code> - use this instead (supports all CLI options including <code>--log-file</code>)</li> <li>CLI flag removed: <code>--cli</code> (replaced by <code>--force-cli</code>)</li> <li>Error mode enum: Changed from <code>--debug</code> to <code>--error-mode trace|on|off</code></li> <li>Subcommand changes: <code>table</code> and <code>all-files</code> subcommands merged into <code>list</code></li> </ul>"},{"location":"release_notes/#api-changes","title":"API Changes","text":"<ul> <li>CoverageModel constructor - Options now use consistent symbol keys (not mixed strings/symbols)</li> <li>Staleness return values - Changed from boolean to letter codes (<code>'M'</code>, <code>'T'</code>, <code>'L'</code>, or <code>false</code>)</li> <li>Error classes - Custom exception hierarchy replaces generic <code>RuntimeError</code></li> </ul>"},{"location":"release_notes/#statistics","title":"\ud83d\udcca Statistics","text":"<ul> <li>175 files changed with 15,712 insertions and 2,142 deletions</li> <li>152 commits since v0.3.0</li> <li>Comprehensive documentation - 12 major documentation files in <code>docs/</code>, 5 ADRs, 7 example scripts</li> <li>Test coverage - Self-reported coverage via SimpleCov (view with <code>simplecov-mcp list</code>)</li> </ul>"},{"location":"release_notes/#acknowledgments","title":"\ud83d\ude4f Acknowledgments","text":"<p>This release benefited from extensive AI pair programming sessions with Codex, Claude Code, GLM-4.6 (Z-AI), Gemini, and Warp.</p> <p>See <code>CLAUDE.md</code>, <code>AGENTS.md</code>, and <code>GEMINI.md</code> for AI agent integration notes.</p>"},{"location":"release_notes/#upgrade-guide","title":"\ud83d\udce6 Upgrade Guide","text":""},{"location":"release_notes/#from-v030","title":"From v0.3.0","text":"<ol> <li> <p>Update require statements: <pre><code># Old\nrequire 'simple_cov/mcp'\n\n# New\nrequire 'simplecov_mcp'\n</code></pre></p> </li> <li> <p>Update environment variables: <pre><code># Old\nexport SIMPLECOV_RESULTSET=/path/to/coverage\nexport SIMPLECOV_MCP_DEBUG=1\n\n# New\nexport SIMPLECOV_MCP_OPTS=\"--resultset /path/to/coverage --error-mode trace\"\n</code></pre></p> </li> <li> <p>Update CLI commands: <pre><code># Old\nsimplecov-mcp table\nsimplecov-mcp all-files\n\n# New (merged into 'list')\nsimplecov-mcp list\nsimplecov-mcp        # default command is 'list'\n</code></pre></p> </li> <li> <p>Update MCP configurations:</p> </li> <li>Review <code>docs/user/MCP_INTEGRATION.md</code> for updated setup instructions</li> <li> <p>Log file now defaults to <code>./simplecov_mcp.log</code> (was <code>~/simplecov_mcp.log</code>)</p> </li> <li> <p>Handle new error types in library code: <pre><code># Old\nrescue RuntimeError =&gt; e\n\n# New\nrescue SimpleCovMcp::FileError =&gt; e\nrescue SimpleCovMcp::ConfigurationError =&gt; e\nrescue SimpleCovMcp::Error =&gt; e  # catch-all\n</code></pre></p> </li> </ol>"},{"location":"release_notes/#possible-future-improvements","title":"\ud83d\udd2e Possible Future Improvements","text":"<ul> <li>Per-file staleness timestamps in multi-suite scenarios</li> <li>Multiple resultset file merging (currently only merges suites within single file)</li> <li>Full branch coverage support with individual branch tracking</li> <li>Web interface for interactive coverage exploration</li> <li>Additional output formats (HTML reports, badges, etc.)</li> </ul>"},{"location":"release_notes/#links","title":"\ud83d\udd17 Links","text":"<ul> <li>Changelog: RELEASE_NOTES.md</li> <li>GitHub: https://github.com/keithrbennett/simplecov-mcp</li> <li>RubyGems: https://rubygems.org/gems/simplecov-mcp</li> <li>Issues: https://github.com/keithrbennett/simplecov-mcp/issues</li> </ul> <p>Full Changelog: v0.3.0...v1.0.0</p>"},{"location":"release_notes/#v021","title":"v0.2.1","text":"<ul> <li>Fixed JSON data key issue and resulting test failure.</li> </ul>"},{"location":"release_notes/#v020","title":"v0.2.0","text":"<ul> <li>Massive enhancements and improvements.</li> </ul>"},{"location":"release_notes/#v010","title":"v0.1.0","text":"<ul> <li>Initial version.</li> </ul>"},{"location":"dev/","title":"Developer Documentation","text":"<p>Back to main README</p> <p>Resources for contributors working on cov-loupe internals and release engineering.</p> <ul> <li>Architecture Overview \u2013 subsystem layout and data flow</li> <li>Development Guide \u2013 setup, testing, release workflow</li> <li>Architecture Decision Records \u2013 design history</li> <li>Presentations \u2013 slide deck for talks/demos</li> </ul>"},{"location":"dev/ARCHITECTURE/","title":"Architecture","text":"<p>Back to main README | Architecture Decision Records</p> <p>cov-loupe is organized around a single coverage data model that feeds three delivery channels: a command-line interface, an MCP server for LLM agents, and a light-weight Ruby API. The codebase is intentionally modular\u2014shared logic for loading, normalizing, and validating SimpleCov data lives in <code>lib/cov_loupe/</code>, while adapters wrap that core for each runtime mode.</p>"},{"location":"dev/ARCHITECTURE/#runtime-entry-points","title":"Runtime Entry Points","text":"<ul> <li>Executable \u2013 <code>exe/cov-loupe</code> bootstraps the gem, enforces Ruby &gt;= 3.2, and delegates to <code>CovLoupe.run(ARGV)</code>.</li> <li>Mode Negotiation \u2013 <code>CovLoupe.run</code> inspects environment defaults from <code>COV_LOUPE_OPTS</code> and parses the <code>-m/--mode</code> flag. It defaults to CLI mode and instantiates <code>CovLoupe::CoverageCLI</code>. When <code>-m mcp</code> or <code>--mode mcp</code> is specified, it instantiates <code>CovLoupe::MCPServer</code> for MCP protocol communication over STDIO.</li> <li>Embedded Usage \u2013 Applications embed the gem by instantiating <code>CovLoupe::CoverageModel</code> directly, optionally wrapping work in <code>CovLoupe.with_context</code> to install a library-oriented error handler.</li> </ul>"},{"location":"dev/ARCHITECTURE/#coverage-data-pipeline","title":"Coverage Data Pipeline","text":"<ol> <li>Resultset discovery \u2013 The tool locates the <code>.resultset.json</code> file by checking a series of default paths or by using a path specified by the user. For a detailed explanation of the configuration options, see the Configuring the Resultset section in the main README.</li> <li>Parsing and normalization \u2013 <code>CoverageModel</code> loads the chosen resultset once, extracts all test suites that expose <code>coverage</code> data (e.g., \"RSpec\", \"Minitest\"), merges them if multiple suites exist, and maps all file keys to absolute paths anchored at the configured project root. Timestamps are cached for staleness checks.</li> <li>Path relativizing \u2013 <code>PathRelativizer</code> (powered by the centralized <code>PathUtils</code> module) produces relative paths for user-facing payloads without mutating the canonical data. Tool responses pass through <code>CoverageModel#relativize</code> before leaving the process.</li> <li>Derived metrics \u2013 <code>CovUtil.summary</code>, <code>CovUtil.uncovered</code>, and <code>CovUtil.detailed</code> compute coverage stats from the raw <code>lines</code> arrays. <code>CoverageModel</code> exposes <code>summary_for</code>, <code>uncovered_for</code>, <code>detailed_for</code>, and <code>raw_for</code> helpers that wrap these utilities.</li> <li>Staleness detection \u2013 <code>StalenessChecker</code> compares source mtimes/line counts to coverage metadata. CLI flags and MCP arguments can promote warnings to hard failures (<code>--raise-on-stale true</code>) or simply mark rows as stale for display.</li> </ol>"},{"location":"dev/ARCHITECTURE/#interfaces","title":"Interfaces","text":""},{"location":"dev/ARCHITECTURE/#cli-covloupecoveragecli","title":"CLI (<code>CovLoupe::CoverageCLI</code>)","text":"<ul> <li>Builds on Ruby\u2019s <code>OptionParser</code>, with global options such as <code>--resultset</code>, <code>--raise-on-stale</code>, <code>-fJ</code>, and <code>--source</code> modes.</li> <li>Subcommands (<code>list</code>, <code>summary</code>, <code>raw</code>, <code>uncovered</code>, <code>detailed</code>, <code>version</code>) translate to calls on <code>CoverageModel</code>.</li> <li>Uses <code>ErrorHandlerFactory.for_cli</code> to convert unexpected exceptions into friendly user messages while honoring <code>--error-mode</code>.</li> <li>Formatting logic (tables, JSON) lives in the model to keep presentation consistent with MCP responses.</li> </ul>"},{"location":"dev/ARCHITECTURE/#mcp-server-covloupemcpserver","title":"MCP Server (<code>CovLoupe::MCPServer</code>)","text":"<ul> <li>Assembles a list of tool classes and mounts them in <code>MCP::Server</code> using STDIO transport.</li> <li>Relies on the same core model; each MCP request creates a fresh <code>CoverageModel</code> instance, but the underlying coverage data is cached in a global <code>ModelDataCache</code> singleton. The cache automatically reloads when the resultset file changes (validated via file signature: mtime, subsecond mtime, size, inode, and MD5 digest).</li> <li>Configuration precedence in MCP: per-request JSON parameters override CLI arguments passed when the server starts (including <code>COV_LOUPE_OPTS</code>), which in turn override built-in defaults.</li> <li>Error handling delegates to <code>BaseTool.handle_mcp_error</code>, which swaps in the MCP-specific handler and emits <code>MCP::Tool::Response</code> objects.</li> </ul>"},{"location":"dev/ARCHITECTURE/#library-api","title":"Library API","text":"<ul> <li>Consuming code instantiates <code>CoverageModel</code> directly for fine-grained control over coverage queries.</li> <li>Use <code>CovLoupe::ErrorHandlerFactory.for_library</code> together with <code>CovLoupe.with_context</code> when an embedded caller wants to suppress CLI-friendly error logging.</li> </ul>"},{"location":"dev/ARCHITECTURE/#mcp-tool-stack","title":"MCP Tool Stack","text":"<ul> <li><code>CovLoupe::BaseTool</code> centralizes JSON schema definitions, error conversion, and response serialization for the MCP protocol.</li> <li>Individual tools reside in <code>lib/cov_loupe/tools/</code> and follow a consistent shape: define an input schema, call into <code>CoverageModel</code>, then serialize via <code>respond_json</code>. Examples include <code>ListTool</code>, <code>CoverageSummaryTool</code>, and <code>UncoveredLinesTool</code>.</li> <li>Tools are registered in <code>CovLoupe::MCPServer#run</code>. Adding a new tool only requires creating a subclass and appending it to that list.</li> </ul>"},{"location":"dev/ARCHITECTURE/#error-handling-logging","title":"Error Handling &amp; Logging","text":"<ul> <li>Custom exceptions under <code>lib/cov_loupe/errors.rb</code> capture context for configuration issues, missing files, stale coverage, and general runtime errors. Each implements <code>#user_friendly_message</code> for consistent UX.</li> <li><code>CovLoupe::ErrorHandler</code> encapsulates logging and severity decisions. Modes (<code>:off</code>, <code>:log</code>, <code>:debug</code>) control whether errors are recorded and whether stack traces are included.</li> <li>Runtime configuration (error handlers, log destinations) flows through <code>CovLoupe::AppContext</code>. Entry points push a context with <code>CovLoupe.with_context</code>, which stores the active configuration in a thread-local slot (<code>CovLoupe.context</code>). Nested calls automatically restore the previous context when the block exits, ensuring isolation even when multiple callers share a process or thread.</li> <li>Two helper accessors clarify intent:</li> <li><code>CovLoupe.default_log_file</code> / <code>default_log_file=</code> adjust the baseline log sink that future contexts inherit.</li> <li><code>CovLoupe.active_log_file</code> / <code>active_log_file=</code> mutate only the current context (or create one on demand) so the change applies immediately without touching the default.</li> <li><code>ErrorHandlerFactory</code> wires the appropriate handler per runtime: CLI, MCP server, or embedded library, each of which installs its handler inside a fresh <code>AppContext</code> before executing user work.</li> <li>Diagnostics are written via <code>CovUtil.log</code> to <code>cov_loupe.log</code> in the current directory by default; override with CLI <code>--log-file</code>, set <code>CovLoupe.default_log_file</code> for future contexts, or temporarily tweak <code>CovLoupe.active_log_file</code> when a caller needs a different destination mid-run.</li> </ul>"},{"location":"dev/ARCHITECTURE/#output-character-mode","title":"Output Character Mode","text":"<p>cov-loupe provides a global output character mode that controls ASCII vs Unicode output across both CLI and MCP interfaces. This feature ensures compatibility with terminals and systems that cannot display Unicode characters while providing rich Unicode output (box-drawing characters, fancy tables) for environments that support it.</p>"},{"location":"dev/ARCHITECTURE/#configuration","title":"Configuration","text":"<ul> <li>CLI flag \u2013 <code>-O/--output-chars MODE</code> accepts <code>default</code>, <code>fancy</code>, or <code>ascii</code> (case-insensitive, with short forms <code>d</code>, <code>f</code>, <code>a</code>)</li> <li>MCP parameter \u2013 Optional <code>output_chars</code> parameter in tool requests overrides server default</li> <li>Mode resolution \u2013 <code>:default</code> resolves at runtime: UTF-8 terminal capability check for fancy, otherwise ASCII</li> </ul>"},{"location":"dev/ARCHITECTURE/#implementation","title":"Implementation","text":"<ul> <li>Core conversion \u2013 <code>OutputChars.convert</code> uses an internal transliteration map with <code>?</code> fallback for characters without ASCII equivalents</li> <li>Charsets \u2013 Separate charset definitions for fancy (Unicode box-drawing) and ASCII modes</li> <li>Formatters \u2013 All formatters (JSON, YAML, AmazingPrint, tables, source) respect the output_chars parameter</li> <li>JSON uses <code>JSON.generate(..., ascii_only: true)</code> for ASCII mode</li> <li>YAML and AmazingPrint post-process output through <code>OutputChars.convert</code></li> <li>Tables use appropriate charset and convert cell contents</li> <li>Source output uses ASCII-safe markers (<code>+/-</code> instead of Unicode <code>\u2713/\u00b7</code>)</li> </ul>"},{"location":"dev/ARCHITECTURE/#scope-of-conversion","title":"Scope of Conversion","text":"<p>Converted in ASCII mode: - CLI error messages and option parser errors - Staleness error messages and file paths - Command literal strings (via <code>convert_text</code> helper in BaseCommand) - MCP tool JSON responses (via <code>respond_json</code> with <code>ascii_only: true</code>) - All formatted output (tables, source, JSON, YAML)</p> <p>Not converted in ASCII mode: - Log files \u2013 Preserved in original encoding for debugging fidelity. Log files are system/debugging artifacts, not user-facing output. Converting would lose exact file paths and error details needed for troubleshooting, create inconsistency between logged paths and actual filesystem paths, and provides no user value since logs are developer artifacts. - Gem post-install message \u2013 Intentionally left unchanged per requirements</p>"},{"location":"dev/ARCHITECTURE/#testing","title":"Testing","text":"<p>Comprehensive test coverage exists: - Mode resolution and normalization tests - Formatter tests for ASCII mode (JSON, YAML, AmazingPrint, tables, source) - CLI option parsing tests for <code>--output-chars</code> flag - MCP tool output mode tests - Staleness error message tests with Unicode file paths</p>"},{"location":"dev/ARCHITECTURE/#configuration-surface","title":"Configuration Surface","text":"<ul> <li>Environment defaults \u2013 <code>COV_LOUPE_OPTS</code> applies baseline CLI flags before parsing the actual command line.</li> <li>Resultset overrides \u2013 The location of the <code>.resultset.json</code> file can be specified via CLI options or in the MCP configuration. See Configuring the Resultset for details.</li> <li>Tracked globs \u2013 Glob patterns (e.g., <code>lib/**/*.rb</code>) that specify which files should have coverage. When provided, cov-loupe alerts you if any matching files are missing from the coverage data, helping catch untested files that were added to the project but never executed during test runs.</li> <li>Output character mode \u2013 Global control of ASCII vs Unicode output via <code>-O/--output-chars</code> (CLI) or <code>output_chars</code> parameter (MCP). Default mode auto-detects terminal UTF-8 capability.</li> <li>Colorized source \u2013 CLI-only flags (<code>--source</code>, <code>--context-lines</code>, <code>--color</code>) enhance human-readable reports when working locally.</li> </ul>"},{"location":"dev/ARCHITECTURE/#repository-layout-highlights","title":"Repository Layout Highlights","text":"<ul> <li><code>lib/cov_loupe/</code> \u2013 Core runtime (model, utilities, error handling, CLI, MCP server, tools).</li> <li><code>lib/cov_loupe.rb</code> \u2013 Primary public entry point required by gem consumers.</li> <li><code>lib/cov_loupe/path_utils.rb</code> \u2013 Centralized path normalization and expansion logic.</li> <li><code>docs/</code> \u2013 Audience-specific guides (<code>docs/user</code> for usage, <code>docs/dev</code> for contributors).</li> <li><code>spec/</code> \u2013 RSpec suite with fixtures under <code>spec/fixtures/</code> for deterministic coverage data.</li> </ul>"},{"location":"dev/ARCHITECTURE/#extending-the-system-with-a-new-tool-or-metric","title":"Extending the System With a New Tool or Metric","text":"<ol> <li>Add or update data processing inside <code>CoverageModel</code> or <code>CovUtil</code> when a new metric is needed.</li> <li>Surface that metric through all interfaces: add a CLI option/subcommand, create an MCP tool, and expose a library helper method.</li> <li>Register the new tool in <code>MCPServer</code> and update CLI option parsing in <code>CoverageCLI</code>.</li> <li>Provide tests under <code>spec/</code> mirroring the lib path (<code>spec/lib/cov_loupe/..._spec.rb</code>).</li> <li>Update documentation to reflect the new capability.</li> </ol> <p>By funnelling every interface through the shared <code>CoverageModel</code>, cov-loupe guarantees that CLI users, MCP clients, and embedding libraries all observe identical coverage semantics and staleness rules, while still allowing each adapter to tailor presentation and error handling to its audience.</p>"},{"location":"dev/DEVELOPMENT/","title":"Development Guide","text":"<p>Back to main README</p> <p>Note: Commands like <code>cov-loupe</code> assume the gem is installed globally. If not, substitute <code>bundle exec exe/cov-loupe</code>.</p>"},{"location":"dev/DEVELOPMENT/#setup","title":"Setup","text":"<pre><code>git clone https://github.com/keithrbennett/cov-loupe.git\ncd cov-loupe\nbundle install\ngem build cov-loupe.gemspec &amp;&amp; gem install cov-loupe-*.gem  # optional\ncov-loupe version  # verify it works\n</code></pre>"},{"location":"dev/DEVELOPMENT/#running-tests","title":"Running Tests","text":"<pre><code>bundle exec rspec\n</code></pre>"},{"location":"dev/DEVELOPMENT/#project-specific-patterns","title":"Project-Specific Patterns","text":"<p>All Ruby files start with: <pre><code># frozen_string_literal: true\n</code></pre></p> <p>Error handling uses custom exceptions from <code>errors.rb</code>: <pre><code>rescue Errno::ENOENT =&gt; e\n  raise FileError.new(\"Coverage data not found: #{e.message}\")\nrescue JSON::ParserError =&gt; e\n  raise CoverageDataError.new(\"Invalid coverage format: #{e.message}\")\n</code></pre></p> <p>MCP tools extend <code>BaseTool</code> and follow this pattern: <pre><code>module CovLoupe::Tools\n  class MyTool &lt; BaseTool\n    description 'What this tool does'\n    input_schema(**input_schema_def)\n\n    def self.call(path:, root: nil, resultset: nil, raise_on_stale: nil,\n      error_mode: 'log', server_context:)\n      with_error_handling('MyTool', error_mode: error_mode) do\n        model = create_model(\n          server_context: server_context,\n          root: root,\n          resultset: resultset,\n          raise_on_stale: raise_on_stale\n        )\n        data = model.my_method_for(path)\n        respond_json(model.relativize(data), name: 'my_tool_output.json')\n      end\n    end\n  end\nend\n</code></pre></p> <p>Use test fixtures for consistency: <pre><code>let(:project_root) { (FIXTURES_DIR / 'project1').to_s }\nlet(:coverage_dir) { File.join(project_root, 'coverage') }\n</code></pre></p> <p>MCP tool tests need setup: <pre><code>let(:server_context) { instance_double('ServerContext').as_null_object }\nbefore { setup_mcp_response_stub }\n</code></pre></p>"},{"location":"dev/DEVELOPMENT/#adding-features","title":"Adding Features","text":"<p>CLI commands: Add to <code>SUBCOMMANDS</code> in <code>cli.rb</code>, implement handler, add tests</p> <p>MCP tools: Create <code>*_tool.rb</code> in <code>lib/cov_loupe/tools/</code>, register in <code>mcp_server.rb</code></p> <p>Coverage features: Add to <code>CoverageModel</code> in <code>model.rb</code> or <code>CovUtil</code> in <code>util.rb</code></p>"},{"location":"dev/DEVELOPMENT/#documentation-development","title":"Documentation Development","text":"<p>This project uses MkDocs with the Material theme for documentation.</p>"},{"location":"dev/DEVELOPMENT/#installing-mkdocs","title":"Installing MkDocs","text":"<p>Recommended: Using a Virtual Environment (all platforms)</p> <p>Virtual environments isolate Python dependencies and don't require system-level permissions.</p> <pre><code># Create virtual environment\npython3 -m venv .venv-docs\n\n# Activate it\nsource .venv-docs/bin/activate  # macOS/Linux\n# Or on Windows: .venv-docs\\Scripts\\activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Deactivate when done (optional)\ndeactivate\n</code></pre> <p>Note: Virtual environment directories (<code>.venv/</code>, <code>.venv-*/</code>, <code>venv/</code>) are already in <code>.gitignore</code>.</p> <p>Alternative: System/User Installation</p> <p>macOS: <pre><code># Using Homebrew\nbrew install mkdocs\npip3 install mkdocs-material mkdocs-awesome-pages-plugin pymdown-extensions\n\n# Or using pip only\npip3 install -r requirements.txt\n</code></pre></p> <p>Linux (Ubuntu/Debian): <pre><code># Install pip if needed\nsudo apt update\nsudo apt install python3-pip\n\n# Install MkDocs and dependencies\npip3 install -r requirements.txt\n\n# Add pip bin directory to PATH if mkdocs command not found\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre></p> <p>Windows: <pre><code># Using pip (requires Python 3)\npip install -r requirements.txt\n\n# Or install individually\npip install mkdocs mkdocs-material mkdocs-awesome-pages-plugin pymdown-extensions\n</code></pre></p>"},{"location":"dev/DEVELOPMENT/#building-documentation","title":"Building Documentation","text":"<pre><code># If using virtual environment, activate it first\nsource .venv-docs/bin/activate  # macOS/Linux\n# Or on Windows: .venv-docs\\Scripts\\activate\n\n# Build static site\nmkdocs build\n\n# Serve locally with live reload (opens at http://127.0.0.1:8000)\nmkdocs serve\n</code></pre>"},{"location":"dev/DEVELOPMENT/#documentation-structure","title":"Documentation Structure","text":"<ul> <li><code>docs/index.md</code> - Main landing page (derived from README.md)</li> <li><code>docs/user/</code> - User-facing documentation (installation, usage, examples)</li> <li><code>docs/dev/</code> - Developer documentation (architecture, contributing)</li> <li><code>mkdocs.yml</code> - MkDocs configuration and navigation structure</li> </ul>"},{"location":"dev/DEVELOPMENT/#adding-documentation","title":"Adding Documentation","text":"<ol> <li>Create or edit markdown files in the <code>docs/</code> directory</li> <li>Add new pages to the <code>nav</code> section in <code>mkdocs.yml</code></li> <li>Test locally with <code>mkdocs serve</code></li> <li>Commit changes along with your code changes</li> </ol>"},{"location":"dev/DEVELOPMENT/#troubleshooting-mkdocs","title":"Troubleshooting MkDocs","text":"<p>Command not found after pip install: - Ensure pip's bin directory is in your PATH - macOS: <code>export PATH=\"$HOME/Library/Python/3.x/bin:$PATH\"</code> - Linux: <code>export PATH=\"$HOME/.local/bin:$PATH\"</code> - Or run via Python: <code>python3 -m mkdocs serve</code></p>"},{"location":"dev/DEVELOPMENT/#troubleshooting","title":"Troubleshooting","text":"<p>RVM + Codex macOS: Currently not possible for Codex to run rspec when running on macOS with rvm-managed rubies - see Troubleshooting</p> <p>MCP server testing: <pre><code>echo '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"version_tool\",\"arguments\":{}}}' | cov-loupe -m mcp\n</code></pre></p>"},{"location":"dev/FUTURE_ENHANCEMENTS/","title":"Future Enhancements","text":"<p>Back to main README</p>"},{"location":"dev/FUTURE_ENHANCEMENTS/#coverage-path-lookup-indexing","title":"Coverage path lookup indexing","text":""},{"location":"dev/FUTURE_ENHANCEMENTS/#problem","title":"Problem","text":"<p>Single-file tools (<code>summary</code>, <code>raw</code>, <code>detailed</code>, <code>uncovered</code>) call <code>CoverageLineResolver#resolve_key</code>, which normalizes every key in the coverage map on each lookup. That makes per-file queries O(n) in the number of files and can become O(n^2) across repeated MCP/CLI requests.</p>"},{"location":"dev/FUTURE_ENHANCEMENTS/#proposed-approach","title":"Proposed approach","text":"<p>Precompute a normalized-key index once per resolver (or per cached model data). Use that index for O(1) lookups while preserving ambiguity detection when multiple original keys normalize to the same value.</p>"},{"location":"dev/FUTURE_ENHANCEMENTS/#why-this-matters","title":"Why this matters","text":"<p>Large resultsets or frequent interactive queries can feel sluggish due to repeated normalization and full-map scans. Indexing would improve responsiveness without changing output semantics.</p>"},{"location":"dev/RELEASING/","title":"Release Process","text":"<p>Back to main README</p> <p>This document provides a checklist for releasing new versions of cov-loupe.</p>"},{"location":"dev/RELEASING/#pre-release-checklist","title":"Pre-Release Checklist","text":""},{"location":"dev/RELEASING/#1-documentation-review","title":"1. Documentation Review","text":"<ul> <li>[ ] RELEASE_NOTES.md: Update version header</li> <li>Update the version section header to final version (e.g., <code>## v#{version}</code>)</li> <li>For major releases: Ensure all breaking changes are documented with migration examples</li> <li> <p>Verify new features and bug fixes are listed</p> </li> <li> <p>[ ] README.md: Verify examples and feature list are current</p> </li> <li> <p>[ ] Documentation: Ensure all docs in <code>docs/</code> are up to date</p> </li> </ul>"},{"location":"dev/RELEASING/#2-code-quality","title":"2. Code Quality","text":"<ul> <li>[ ] Tests: All tests passing (<code>bundle exec rspec</code>)</li> <li>Verify via git hooks or run manually</li> <li> <p>Check coverage is still excellent (&gt;95%)</p> </li> <li> <p>[ ] Linting: No Rubocop violations (<code>bundle exec rubocop</code>)</p> </li> <li> <p>Verify via git hooks or run manually</p> </li> <li> <p>[ ] Version: Update <code>lib/cov_loupe/version.rb</code> to release version</p> </li> <li>Remove <code>.pre.X</code> suffix for stable releases</li> </ul>"},{"location":"dev/RELEASING/#3-cleanup","title":"3. Cleanup","text":"<ul> <li>[ ] Untracked files: Review <code>git status</code> for files that should be:</li> <li>Added to <code>.gitignore</code> (temp files, local experiments, AI reports)</li> <li>Committed (valuable documentation or examples)</li> <li> <p>Deleted (obsolete files)</p> </li> <li> <p>[ ] Temporary files: Remove or ignore:</p> </li> <li><code>*.txt</code> files (r.txt, rubocop.txt, todo.txt, etc.)</li> <li>Experimental config files (<code>.rubocop.yml.new</code>, etc.)</li> <li>Local notes (CODING_AGENT_NOTES.md, architecture_insights.md, etc.)</li> <li>Work-in-progress directories (screencast/, untracked-ai-reports/, etc.)</li> </ul>"},{"location":"dev/RELEASING/#4-build-verification","title":"4. Build Verification","text":"<ul> <li> <p>[ ] Build gem: Verify gem builds without errors <pre><code>gem build cov-loupe.gemspec\n</code></pre></p> </li> <li> <p>[ ] Test installation: Install and test locally <pre><code>gem install cov-loupe-*.gem\ncov-loupe --version\ncov-loupe --help\n# Test on actual project\ncd /path/to/test/project\ncov-loupe list\n</code></pre></p> </li> </ul>"},{"location":"dev/RELEASING/#5-git-release","title":"5. Git Release","text":"<ul> <li> <p>[ ] Commit changes: Commit version bump and RELEASE_NOTES.md updates <pre><code>git add lib/cov_loupe/version.rb RELEASE_NOTES.md\ngit commit -m \"Release version #{version}\"\n</code></pre></p> </li> <li> <p>[ ] Create tag: Tag the release <pre><code>git tag -a v#{version} -m \"Version #{version}\"\n</code></pre></p> </li> <li> <p>[ ] Push: Push commits and tags <pre><code>git push origin main --follow-tags\n</code></pre></p> </li> </ul>"},{"location":"dev/RELEASING/#6-publish-gem","title":"6. Publish Gem","text":"<ul> <li> <p>[ ] Build final gem: Build from tagged version <pre><code>gem build cov-loupe.gemspec\n</code></pre></p> </li> <li> <p>[ ] Push to RubyGems: Publish the gem <pre><code>gem push cov-loupe-#{version}.gem\n</code></pre></p> </li> <li> <p>[ ] Verify publication: Check gem appears on RubyGems.org</p> </li> <li>Visit https://rubygems.org/gems/cov-loupe</li> <li>Verify new version is listed</li> <li>Check that documentation links work</li> </ul>"},{"location":"dev/RELEASING/#7-github-release","title":"7. GitHub Release","text":"<ul> <li>[ ] Create GitHub release: Go to https://github.com/keithrbennett/cov-loupe/releases/new</li> <li>Select the tag you just pushed</li> <li>Title: <code>Version #{version}</code></li> <li>Description: Copy relevant sections from RELEASE_NOTES.md</li> <li>Attach the <code>.gem</code> file (optional)</li> </ul>"},{"location":"dev/RELEASING/#8-post-release","title":"8. Post-Release","text":"<ul> <li>[ ] Announcement: Consider announcing on:</li> <li>Ruby Weekly</li> <li>Reddit (r/ruby)</li> <li>Slack/Discord communities</li> <li> <p>Social media</p> </li> <li> <p>[ ] Update dependencies: For projects using this gem</p> </li> <li>Update your own projects to use new version</li> <li> <p>Test integration</p> </li> <li> <p>[ ] Prepare for next release:</p> </li> <li>Optionally create a new section in RELEASE_NOTES.md for next version</li> <li>Consider bumping to next pre-release version if starting new development cycle</li> </ul>"},{"location":"dev/RELEASING/#version-numbering","title":"Version Numbering","text":"<p>Follow Semantic Versioning:</p> <ul> <li>Major (X.0.0): Breaking changes</li> <li>Minor (0.X.0): New features, backward compatible</li> <li>Patch (0.0.X): Bug fixes, backward compatible</li> <li>Pre-release (X.Y.Z.pre.N): Development versions</li> </ul>"},{"location":"dev/RELEASING/#rollback-procedure","title":"Rollback Procedure","text":"<p>If a critical issue is discovered after release:</p> <ol> <li> <p>Yank the gem (removes from RubyGems but preserves install history): <pre><code>gem yank cov-loupe -v #{version}\n</code></pre></p> </li> <li> <p>Fix the issue in a new patch version</p> </li> <li> <p>Release the fixed version following this checklist</p> </li> <li> <p>Communicate: Update GitHub release notes and announce the issue + fix</p> </li> </ol>"},{"location":"dev/RELEASING/#notes","title":"Notes","text":"<ul> <li>GitHub Actions runs tests and Rubocop on every commit (via hooks)</li> <li>Pre-commit hooks ensure code quality before commits</li> </ul>"},{"location":"dev/arch-decisions/","title":"Architecture Decision Records","text":"<p>Back to main README | Architecture Overview</p>"},{"location":"dev/arch-decisions/#what-is-an-adr","title":"What is an ADR?","text":"<p>An Architecture Decision Record (ADR) captures a significant architectural decision made during the development of this project, along with its context and consequences.</p>"},{"location":"dev/arch-decisions/#adr-format","title":"ADR Format","text":"<p>Each ADR follows this structure:</p>"},{"location":"dev/arch-decisions/#title","title":"Title","text":"<p>A short phrase describing the decision (e.g., \"Dual-Mode Operation: CLI and MCP Server\")</p>"},{"location":"dev/arch-decisions/#status","title":"Status","text":"<ul> <li>Accepted: The decision has been made and is currently in effect</li> <li>Proposed: Under consideration</li> <li>Deprecated: No longer applicable</li> <li>Superseded: Replaced by a newer decision</li> </ul>"},{"location":"dev/arch-decisions/#context","title":"Context","text":"<p>The background, problem statement, and constraints that led to the decision.</p>"},{"location":"dev/arch-decisions/#decision","title":"Decision","text":"<p>The architectural choice that was made.</p>"},{"location":"dev/arch-decisions/#consequences","title":"Consequences","text":"<p>The implications of this decision, both positive and negative. This includes: - Benefits gained - Trade-offs accepted - Complexity introduced - Future constraints</p>"},{"location":"dev/arch-decisions/#references","title":"References","text":"<p>Links to related code, issues, documentation, or other ADRs.</p>"},{"location":"dev/arch-decisions/#index-of-adrs","title":"Index of ADRs","text":"<p>ADRs are organized by topic area rather than chronologically:</p> <ul> <li>Application Architecture - Dual-mode operation (CLI/MCP) and context-aware error handling</li> <li>Coverage Data Quality - Staleness detection system</li> <li>Output Character Mode - Global ASCII vs Unicode output control</li> <li>Path Resolution - Path matching strategy and cross-OS coverage support</li> <li>Policy Validation - Success predicates using Ruby <code>instance_eval</code></li> <li>SimpleCov Integration - Dependency strategy and data loading (replaced)</li> </ul>"},{"location":"dev/arch-decisions/#when-to-create-an-adr","title":"When to Create an ADR","text":"<p>Create an ADR when: - Making a decision that affects the structure or behavior of the system - Choosing between multiple viable approaches - Accepting significant trade-offs - Making decisions that future maintainers should understand</p>"},{"location":"dev/arch-decisions/#contributing","title":"Contributing","text":"<p>When adding a new ADR: 1. Add it to the appropriate topic-based file, or create a new file if it covers a new area 2. Follow the format outlined above 3. Update this README's index 4. Link to relevant code and documentation</p>"},{"location":"dev/arch-decisions/application-architecture/","title":"Application Architecture","text":"<p>Back to main README</p> <p>This document describes the core architectural decisions that shape how cov-loupe operates: its dual-mode design and context-aware error handling strategy.</p>"},{"location":"dev/arch-decisions/application-architecture/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Dual-Mode Operation (CLI and MCP Server)</li> <li>Context-Aware Error Handling</li> </ul>"},{"location":"dev/arch-decisions/application-architecture/#dual-mode-operation-cli-and-mcp-server","title":"Dual-Mode Operation (CLI and MCP Server)","text":""},{"location":"dev/arch-decisions/application-architecture/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"dev/arch-decisions/application-architecture/#context","title":"Context","text":"<p>cov-loupe needed to serve two distinct use cases:</p> <ol> <li>Human users wanting a command-line tool to inspect coverage reports in their terminal</li> <li>AI agents and MCP clients needing programmatic access to coverage data via the Model Context Protocol (MCP) over JSON-RPC</li> </ol> <p>We considered three approaches:</p> <ol> <li>Separate binaries/gems: Create <code>simplecov-cli</code> and <code>cov-loupe</code> as separate projects</li> <li>Single binary with explicit mode flags: Require users to pass <code>--mode mcp</code> to run as MCP server</li> <li>Automatic mode detection: Single binary that automatically detects the operating mode based on input (TTY status, stdin)</li> </ol>"},{"location":"dev/arch-decisions/application-architecture/#key-constraints","title":"Key Constraints","text":"<ul> <li>MCP servers communicate via JSON-RPC over stdin/stdout, so any human-readable output would corrupt the protocol</li> <li>CLI users expect immediate, readable output without ceremony</li> <li>The gem should be simple to install and use for both audiences</li> <li>Mode selection must be reliable and unambiguous</li> </ul>"},{"location":"dev/arch-decisions/application-architecture/#decision-v400","title":"Decision (v4.0.0+)","text":"<p>We implemented explicit mode selection via the <code>-m/--mode</code> flag. The default mode is <code>cli</code>, and MCP users must pass <code>-m mcp</code> or <code>--mode mcp</code> to run the server.</p>"},{"location":"dev/arch-decisions/application-architecture/#mode-selection-logic","title":"Mode Selection Logic","text":"<p>The mode is determined by parsing the <code>-m/--mode</code> flag from argv (including environment variables via <code>COV_LOUPE_OPTS</code>):</p> <ul> <li>Default: CLI mode (when <code>-m/--mode</code> is not specified)</li> <li>MCP mode: Must explicitly pass <code>-m mcp</code> or <code>--mode mcp</code></li> </ul> <p>The implementation parses the configuration from the command-line arguments and routes to either <code>CoverageCLI</code> or <code>MCPServer</code> based on the mode setting.</p>"},{"location":"dev/arch-decisions/application-architecture/#why-this-works","title":"Why This Works","text":"<ul> <li>MCP clients are configured once with <code>-m mcp</code> or <code>--mode mcp</code> in their server config \u2192 always routes to MCP server</li> <li>CLI users don't need to specify anything \u2192 defaults to CLI mode</li> <li>No ambiguity: Mode is explicit and deterministic based on the <code>-m/--mode</code> flag</li> </ul>"},{"location":"dev/arch-decisions/application-architecture/#historical-note","title":"Historical Note","text":"<p>Prior to v4.0.0, cov-loupe used automatic mode detection based on TTY status and presence of subcommands. This was removed because: - Automatic detection caused issues with piped input (<code>cov-loupe --format json &gt; output.json</code> would hang in MCP mode) - CI environments and non-TTY contexts were unpredictable - CLI-only flags without subcommands (<code>--format</code>, <code>--sort-order</code>) couldn't be reliably detected - Explicit mode selection is more predictable and follows standard practice for language servers</p>"},{"location":"dev/arch-decisions/application-architecture/#consequences","title":"Consequences","text":""},{"location":"dev/arch-decisions/application-architecture/#positive","title":"Positive","text":"<ol> <li>User convenience: Single gem to install (<code>gem install cov-loupe</code>), single executable (<code>cov-loupe</code>)</li> <li>Predictable behavior: Mode is explicit and deterministic - no surprises based on environment</li> <li>Simpler implementation: No complex mode detection logic to maintain</li> <li>Clear separation: CLI and MCP server implementations remain completely separate after routing</li> <li>Follows conventions: Matches standard practice for language servers (e.g., <code>typescript-language-server --stdio</code>)</li> </ol>"},{"location":"dev/arch-decisions/application-architecture/#negative","title":"Negative","text":"<ol> <li>Breaking change: Users upgrading from v3.x must update MCP server configuration to include <code>-m mcp</code> or <code>--mode mcp</code></li> <li>Slight verbosity: MCP users must include <code>-m mcp</code> or <code>--mode mcp</code> in their server config (but this is one-time setup)</li> <li>Shared dependencies: Some components (error handling, coverage model) must work correctly in both modes</li> </ol>"},{"location":"dev/arch-decisions/application-architecture/#trade-offs","title":"Trade-offs","text":"<ul> <li>Versus automatic detection: More explicit, but eliminates ambiguity and edge cases</li> <li>Versus separate gems: Single installation is simpler, but requires mode flag for MCP</li> </ul>"},{"location":"dev/arch-decisions/application-architecture/#future-constraints","title":"Future Constraints","text":"<ul> <li>Shared components (like <code>CoverageModel</code>) must never output to stdout/stderr in ways that differ by mode</li> <li>Default mode must remain <code>cli</code> for backward compatibility with existing CLI users</li> </ul>"},{"location":"dev/arch-decisions/application-architecture/#references","title":"References","text":"<ul> <li>Implementation: <code>lib/cov_loupe.rb</code> (<code>CovLoupe.run</code>)</li> <li>Configuration: <code>lib/cov_loupe/app_config.rb</code></li> <li>CLI implementation: <code>lib/cov_loupe/cli.rb</code></li> <li>MCP server implementation: <code>lib/cov_loupe/mcp_server.rb</code></li> <li>Related section: Context-Aware Error Handling</li> </ul>"},{"location":"dev/arch-decisions/application-architecture/#context-aware-error-handling","title":"Context-Aware Error Handling","text":""},{"location":"dev/arch-decisions/application-architecture/#status_1","title":"Status","text":"<p>Accepted</p>"},{"location":"dev/arch-decisions/application-architecture/#context_1","title":"Context","text":"<p>cov-loupe operates in three distinct contexts, each with different error handling requirements:</p> <ol> <li>CLI mode: Human users expect friendly error messages, exit codes, and optional debug traces</li> <li>MCP server mode: AI agents/clients need structured error responses that don't crash the server</li> <li>Library mode: Embedding applications need exceptions they can catch and handle programmatically</li> </ol> <p>Initially, we considered uniform error handling across all modes, but this created poor user experiences:</p> <ul> <li>CLI users saw raw exceptions with stack traces (scary and unhelpful)</li> <li>MCP servers crashed on errors instead of returning error responses</li> <li>Library users got friendly messages logged to stderr (unwanted side effects in their applications)</li> </ul>"},{"location":"dev/arch-decisions/application-architecture/#key-requirements","title":"Key Requirements","text":"<ul> <li>CLI: User-friendly messages, meaningful exit codes, optional stack traces for debugging</li> <li>MCP Server: Logged errors (to file, not stdout), structured JSON-RPC error responses, no server crashes</li> <li>Library: Raise custom exceptions with no logging, allowing consumers to handle errors as needed</li> <li>Consistency: Same underlying error types, but different presentation strategies</li> </ul>"},{"location":"dev/arch-decisions/application-architecture/#decision","title":"Decision","text":"<p>We implemented a context-aware error handling strategy using three components:</p>"},{"location":"dev/arch-decisions/application-architecture/#1-custom-exception-hierarchy","title":"1. Custom Exception Hierarchy","text":"<p>All errors inherit from <code>CovLoupe::Error</code> (lib/cov_loupe/errors.rb) with a <code>user_friendly_message</code> method:</p> <pre><code>class Error &lt; StandardError\n  def user_friendly_message\n    message  # Can be overridden in subclasses\n  end\nend\n\nclass FileNotFoundError &lt; FileError; end\nclass CoverageDataError &lt; Error; end\nclass ResultsetNotFoundError &lt; CoverageDataError; end\n# ... etc\n</code></pre> <p>This provides a unified interface for presenting errors to users while preserving exception types for programmatic handling.</p>"},{"location":"dev/arch-decisions/application-architecture/#2-errorhandler-class","title":"2. ErrorHandler Class","text":"<p>The <code>ErrorHandler</code> class (see <code>lib/cov_loupe/error_handler.rb</code>) provides configurable error handling behavior:</p> <pre><code>class ErrorHandler\n  attr_accessor :error_mode, :logger\n\n  VALID_ERROR_MODES = [:off, :log, :debug].freeze\n\n  def initialize(error_mode: :log, logger: nil)\n    @error_mode = error_mode\n    @logger = logger\n  end\n\n  def handle_error(error, context: nil, reraise: true)\n    log_error(error, context)\n    if reraise\n      raise error.is_a?(CovLoupe::Error) ? error : convert_standard_error(error)\n    end\n  end\nend\n</code></pre> <p>The <code>convert_standard_error</code> method transforms Ruby's standard errors into user-friendly custom exceptions:</p> <ul> <li><code>Errno::ENOENT</code> \u2192 <code>FileNotFoundError</code></li> <li><code>JSON::ParserError</code> \u2192 <code>CoverageDataError</code></li> <li><code>Errno::EACCES</code> \u2192 <code>FilePermissionError</code></li> </ul>"},{"location":"dev/arch-decisions/application-architecture/#3-errorhandlerfactory","title":"3. ErrorHandlerFactory","text":"<p>The <code>ErrorHandlerFactory</code> (defined in <code>lib/cov_loupe/error_handler_factory.rb</code>) creates mode-specific handlers:</p> <pre><code>module ErrorHandlerFactory\n  def self.for_cli(error_mode: :log)\n    ErrorHandler.new(error_mode: error_mode)\n  end\n\n  def self.for_library(error_mode: :off)\n    ErrorHandler.new(error_mode: :off)  # No logging\n  end\n\n  def self.for_mcp_server(error_mode: :log)\n    ErrorHandler.new(error_mode: :log)   # Logs to file\n  end\nend\n</code></pre>"},{"location":"dev/arch-decisions/application-architecture/#error-flow-by-mode","title":"Error Flow by Mode","text":"<p>CLI Mode (lib/cov_loupe/cli.rb): 1. Catches all exceptions in the main run loop 2. Uses <code>for_cli</code> handler to log errors if debug mode is enabled 3. Displays <code>user_friendly_message</code> to the user 4. Exits with appropriate code (1 for errors, 2 for usage errors)</p> <p>MCP Server Mode (<code>lib/cov_loupe/base_tool.rb</code>): 1. Each tool wraps execution in a rescue block 2. Uses <code>for_mcp_server</code> handler to log errors to <code>~/cov_loupe.log</code> 3. Returns structured JSON-RPC error response 4. Server continues running (no crashes)</p> <p>Library Mode (<code>lib/cov_loupe.rb</code>): 1. Uses <code>for_library</code> handler with <code>error_mode: :off</code> (no logging) 2. Raises custom exceptions directly 3. Consumers catch and handle <code>CovLoupe::Error</code> subclasses</p>"},{"location":"dev/arch-decisions/application-architecture/#consequences_1","title":"Consequences","text":""},{"location":"dev/arch-decisions/application-architecture/#positive_1","title":"Positive","text":"<ol> <li>Excellent UX: Each context gets appropriate error handling behavior</li> <li>Robustness: MCP server never crashes on tool errors</li> <li>Debuggability: CLI users can enable stack traces with error modes, MCP errors are logged</li> <li>Clean library API: No unwanted side effects (logging, stderr output) when used as a library</li> <li>Type safety: Custom exceptions allow programmatic error handling by type</li> </ol>"},{"location":"dev/arch-decisions/application-architecture/#negative_1","title":"Negative","text":"<ol> <li>Complexity: Three error handling paths to maintain and test</li> <li>Coordination required: All error types must implement <code>user_friendly_message</code> consistently</li> <li>Error conversion overhead: Standard errors must be converted to custom exceptions</li> </ol>"},{"location":"dev/arch-decisions/application-architecture/#trade-offs_1","title":"Trade-offs","text":"<ul> <li>Versus uniform error handling: More code complexity, but dramatically better UX in each context</li> <li>Versus separate error classes per mode: Single error hierarchy is simpler, factory pattern adds mode-specific behavior</li> </ul>"},{"location":"dev/arch-decisions/application-architecture/#implementation-notes","title":"Implementation Notes","text":"<p>The <code>ErrorHandler.convert_standard_error</code> method uses pattern matching on exception types and error messages to provide helpful, context-aware error messages. This includes:</p> <ul> <li>Extracting filenames from system error messages</li> <li>Detecting SimpleCov-specific error patterns</li> <li>Providing actionable suggestions (\"please run your tests first\")</li> </ul>"},{"location":"dev/arch-decisions/application-architecture/#references_1","title":"References","text":"<ul> <li>Custom exceptions: <code>lib/cov_loupe/errors.rb</code></li> <li>ErrorHandler implementation: <code>lib/cov_loupe/error_handler.rb</code></li> <li>ErrorHandlerFactory: <code>lib/cov_loupe/error_handler_factory.rb</code></li> <li>CLI error handling: <code>lib/cov_loupe/cli.rb</code> (rescue block in <code>CoverageCLI#run</code>)</li> <li>MCP tool error handling: <code>lib/cov_loupe/base_tool.rb</code> (<code>BaseTool#call</code>)</li> <li>Library mode: <code>lib/cov_loupe.rb</code> (error handling within <code>CovLoupe.run</code>)</li> <li>Related section: Dual-Mode Operation</li> </ul>"},{"location":"dev/arch-decisions/coverage-data-quality/","title":"Coverage Data Quality","text":"<p>Back to main README</p> <p>This document describes how cov-loupe ensures the accuracy and reliability of coverage data through staleness detection.</p>"},{"location":"dev/arch-decisions/coverage-data-quality/#coverage-staleness-detection","title":"Coverage Staleness Detection","text":""},{"location":"dev/arch-decisions/coverage-data-quality/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"dev/arch-decisions/coverage-data-quality/#context","title":"Context","text":"<p>Coverage data can become outdated when source files are modified after tests run. This creates misleading results:</p> <ul> <li>Coverage percentages appear lower/higher than reality</li> <li>Line numbers in coverage reports don't match the current source</li> <li>AI agents and users may make decisions based on stale data</li> </ul> <p>We needed a staleness detection system that could:</p> <ol> <li>Detect when source files have been modified since coverage was collected</li> <li>Detect when source files have different line counts than coverage data</li> <li>Handle edge cases (deleted files)</li> <li>Support both file-level and project-level checks</li> <li>Allow users to control whether staleness is reported or causes errors</li> </ol>"},{"location":"dev/arch-decisions/coverage-data-quality/#alternative-approaches-considered","title":"Alternative Approaches Considered","text":"<ol> <li>No staleness checking: Simple, but leads to confusing/incorrect reports</li> <li>Single timestamp check: Fast, but misses line count mismatches (files edited and reverted)</li> <li>Content hashing: Accurate, but expensive for large projects</li> <li>Multi-type detection with modes: More complex, but provides accurate detection with user control</li> </ol>"},{"location":"dev/arch-decisions/coverage-data-quality/#decision","title":"Decision","text":"<p>We implemented a staleness detection system with configurable error modes that can identify four distinct staleness conditions.</p>"},{"location":"dev/arch-decisions/coverage-data-quality/#four-staleness-types","title":"Four Staleness Types","text":"<p>The <code>StalenessChecker</code> class (defined in <code>lib/cov_loupe/staleness/staleness_checker.rb</code>) detects four distinct types of staleness:</p> <ol> <li>Type \"error\" (Error): The staleness check itself failed</li> <li>Returned by <code>CoverageModel#staleness_for</code> when an exception is raised during staleness checking</li> <li>Example: File permission errors, resolver failures, or other unexpected issues</li> <li> <p>The error is logged but execution continues with an \"error\" status instead of crashing</p> </li> <li> <p>Type \"missing\" (Missing): The source file exists in coverage but is now deleted/missing</p> </li> <li>Returned by <code>file_staleness_status</code> when <code>File.file?(file_abs)</code> returns false</li> <li> <p>Example: File was deleted after tests ran</p> </li> <li> <p>Type \"newer\" (Timestamp): The source file's mtime is newer than coverage timestamp</p> </li> <li>Detected by comparing <code>File.mtime(file_abs)</code> with coverage timestamp</li> <li> <p>Example: File was edited after tests ran</p> </li> <li> <p>Type \"length_mismatch\" (Length): The source file line count doesn't match the coverage lines array length</p> </li> <li>Detected by comparing <code>File.foreach(path).count</code> with <code>coverage_lines.length</code></li> <li> <p>Example: Lines were added/removed without changing mtime (rare but possible with version control)</p> </li> <li> <p>Type \"ok\" (Not stale): The file is not stale</p> </li> <li>Returned when none of the above staleness conditions apply</li> <li>Indicates the coverage data is current and accurate</li> </ol>"},{"location":"dev/arch-decisions/coverage-data-quality/#implementation-details","title":"Implementation Details","text":"<p>The core algorithm lives in <code>CovLoupe::StalenessChecker#compute_file_staleness_details</code>:</p> <pre><code>def compute_file_staleness_details(file_abs, coverage_lines)\n  coverage_ts = coverage_timestamp\n  exists = File.file?(file_abs)\n  file_mtime = exists ? File.mtime(file_abs) : nil\n\n  cov_len = coverage_lines.respond_to?(:length) ? coverage_lines.length : 0\n  src_len = exists ? safe_count_lines(file_abs) : 0\n\n  # If coverage timestamp is 0 (missing/invalid), we cannot determine if file is newer\n  newer = if coverage_ts.to_i &gt; 0\n            !!(file_mtime &amp;&amp; file_mtime.to_i &gt; coverage_ts.to_i)\n          else\n            false\n          end\n\n  len_mismatch = (cov_len.positive? &amp;&amp; src_len != cov_len)\n  newer &amp;&amp;= !len_mismatch  # Prioritize length mismatch over timestamp\n\n  {\n    exists: exists,\n    file_mtime: file_mtime,\n    coverage_timestamp: coverage_ts,\n    cov_len: cov_len,\n    src_len: src_len,\n    newer: newer,\n    len_mismatch: len_mismatch\n  }\nend\n</code></pre>"},{"location":"dev/arch-decisions/coverage-data-quality/#staleness-modes","title":"Staleness Modes","text":"<p>The checker supports two modes, configured when instantiating <code>StalenessChecker</code>:</p> <ul> <li><code>:off</code> (default): Staleness is detected but only reported in responses, never raises errors</li> <li>\"error\": Staleness raises <code>CoverageDataStaleError</code> or <code>CoverageDataProjectStaleError</code></li> </ul> <p>This allows: - Interactive tools to show warnings without crashing - CI systems to fail builds on stale coverage - AI agents to decide how to handle staleness based on their goals</p>"},{"location":"dev/arch-decisions/coverage-data-quality/#file-level-vs-project-level-checks","title":"File-Level vs Project-Level Checks","text":"<p>File-level (<code>check_file!</code> and <code>file_staleness_status</code>): - Checks a single file's staleness - Returns one of the staleness status strings (\"ok\", \"missing\", \"newer\", \"length_mismatch\", \"error\") - Used by single-file tools (summary, detailed, uncovered)</p> <p>Project-level (<code>check_project!</code>): - Checks all covered files plus optionally tracked files - Detects:   - Files newer than coverage timestamp   - Files deleted since coverage was collected   - Tracked files missing from coverage (newly added files) - Raises <code>CoverageDataProjectStaleError</code> with lists of problematic files - Used by <code>list_tool</code> and <code>coverage_table_tool</code></p> <p>Totals behavior: - <code>project_totals</code> excludes any stale files (\"missing\", \"newer\", \"length_mismatch\", \"error\") from aggregate counts. - Totals include explicit <code>with_coverage</code>/<code>without_coverage</code> breakdowns so callers can reconcile what was omitted. - The <code>without_coverage</code> payload includes counts for three categories:   - <code>missing_from_coverage</code>: Tracked files that have no coverage data in the resultset   - <code>unreadable</code>: Files that exist but could not be read (e.g., due to permission errors, I/O issues, or staleness check failures)   - <code>skipped</code>: Files that were skipped during list processing due to coverage data errors (e.g., malformed entries) - The <code>unreadable</code> count is populated from <code>list_result['unreadable_files']</code>, which is collected during staleness checking when files exist but cannot be accessed or validated.</p>"},{"location":"dev/arch-decisions/coverage-data-quality/#tracked-globs-feature","title":"Tracked Globs Feature","text":"<p>The project-level check supports <code>tracked_globs</code> parameter to detect newly added files:</p> <pre><code># Detects if lib/**/*.rb files exist that have no coverage data\nchecker.check_project!(coverage_map)  # with tracked_globs: ['lib/**/*.rb']\n</code></pre> <p>This helps teams ensure new files are included in test runs.</p>"},{"location":"dev/arch-decisions/coverage-data-quality/#resultset-path-consistency-simplecov","title":"Resultset Path Consistency (SimpleCov)","text":"<p>SimpleCov can emit mixed path forms for the same file when resultsets are merged across suites or environments (for example, absolute vs relative paths, or different roots). This is a SimpleCov data consistency risk, not a cov-loupe behavior. Downstream tools that normalize paths may treat one entry as overriding another when multiple keys map to the same absolute path.</p> <p>Guidance: Keep <code>SimpleCov.root</code> consistent across all suites and avoid manual path rewriting before merging resultsets.</p>"},{"location":"dev/arch-decisions/coverage-data-quality/#consequences","title":"Consequences","text":""},{"location":"dev/arch-decisions/coverage-data-quality/#positive","title":"Positive","text":"<ol> <li>Accurate detection: Three types catch different staleness scenarios comprehensively</li> <li>User control: Modes allow errors or warnings based on use case</li> <li>Detailed information: Staleness errors include specific file lists and timestamps</li> <li>Project awareness: Can detect newly added files that lack coverage</li> <li>Conservative totals: Aggregate totals only include fresh coverage data</li> </ol>"},{"location":"dev/arch-decisions/coverage-data-quality/#negative","title":"Negative","text":"<ol> <li>Complexity: Three staleness types are harder to understand than a single timestamp check</li> <li>Performance: Line counting and mtime checks for every file add overhead</li> <li>Ambiguity: When multiple staleness types apply, prioritization logic (length &gt; timestamp) may surprise users</li> </ol>"},{"location":"dev/arch-decisions/coverage-data-quality/#trade-offs","title":"Trade-offs","text":"<ul> <li>Versus timestamp-only: More accurate but slower and more complex</li> <li>Versus content hashing: Fast enough for most projects, but can't detect \"edit then revert\" scenarios</li> <li>Versus no checking: Essential for reliable coverage reporting, worth the complexity</li> </ul>"},{"location":"dev/arch-decisions/coverage-data-quality/#edge-cases-handled","title":"Edge Cases Handled","text":"<ol> <li>Deleted files: Appear as \"missing\" type staleness</li> <li>Empty files: <code>cov_len.positive?</code> guard prevents false positives</li> <li>No coverage timestamp: Defaults to 0, effectively disabling timestamp checks</li> </ol>"},{"location":"dev/arch-decisions/coverage-data-quality/#references","title":"References","text":"<ul> <li>Implementation: <code>lib/cov_loupe/staleness_checker.rb</code> (<code>StalenessChecker</code> class)</li> <li>File-level checking: <code>StalenessChecker#check_file!</code> and <code>#file_staleness_status</code></li> <li>Project-level checking: <code>StalenessChecker#check_project!</code></li> <li>Staleness detail computation: <code>StalenessChecker#compute_file_staleness_details</code></li> <li>Error types: <code>lib/cov_loupe/errors.rb</code> (<code>CoverageDataStaleError</code>, <code>CoverageDataProjectStaleError</code>)</li> <li>Usage in tools: <code>lib/cov_loupe/tools/list_tool.rb</code>, <code>lib/cov_loupe/model.rb</code></li> </ul>"},{"location":"dev/arch-decisions/output-character-mode/","title":"Output Character Mode","text":"<p>Back to main README</p> <p>This document describes the architectural decision for implementing a global output character mode that controls ASCII vs Unicode output across CLI and MCP interfaces.</p>"},{"location":"dev/arch-decisions/output-character-mode/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"dev/arch-decisions/output-character-mode/#context","title":"Context","text":"<p>cov-loupe outputs data in multiple formats across two interfaces:</p> <ol> <li>CLI mode: Human users read terminal output including tables, error messages, and formatted coverage reports</li> <li>MCP server mode: AI agents receive JSON responses containing coverage data and metadata</li> </ol>"},{"location":"dev/arch-decisions/output-character-mode/#the-problem","title":"The Problem","text":"<p>Modern projects often contain file paths with Unicode characters (e.g., accented characters, non-Latin scripts). The original implementation used Unicode characters throughout:</p> <ul> <li>Table borders using box-drawing characters (\u2502 \u2500 \u250c \u2510 \u2514 \u2518 \u251c \u2524 \u252c \u2534 \u253c)</li> <li>Source code markers (\u2713 for covered, \u00b7 for uncovered)</li> <li>Error messages with file paths preserved as-is</li> </ul> <p>This caused issues in environments that don't support Unicode:</p> <ul> <li>Windows terminals with legacy encoding</li> <li>CI/CD systems with ASCII-only terminals</li> <li>Piped output to files or tools expecting ASCII</li> <li>Legacy systems without UTF-8 support</li> </ul> <p>Users experienced garbled output, corrupted tables, and unreadable error messages.</p>"},{"location":"dev/arch-decisions/output-character-mode/#requirements","title":"Requirements","text":"<ul> <li>ASCII mode: Must produce ASCII-only output (0-127 characters) when requested</li> <li>Fancy mode: Should use Unicode characters for enhanced readability when supported</li> <li>Auto-detection: Default mode should intelligently choose based on environment</li> <li>MCP integration: MCP tools must support the same output modes as CLI</li> <li>Comprehensive coverage: All output channels must respect the mode setting</li> <li>Backward compatibility: Existing behavior (Unicode) should remain the default when supported</li> </ul>"},{"location":"dev/arch-decisions/output-character-mode/#considered-approaches","title":"Considered Approaches","text":"<ol> <li>Separate ASCII formatters: Create duplicate formatter implementations for ASCII output</li> <li>Too much code duplication</li> <li> <p>Maintenance burden (two implementations of each formatter)</p> </li> <li> <p>Post-process all output: Apply ASCII conversion after formatting</p> </li> <li>Inefficient (convert entire formatted output)</li> <li> <p>Could corrupt already-encoded data (JSON structure)</p> </li> <li> <p>Centralized conversion with charsets: Define separate charsets and convert at formatting time</p> </li> <li>Clean separation of concerns</li> <li>Efficient (convert only what's displayed)</li> <li>Consistent across all formatters</li> </ol>"},{"location":"dev/arch-decisions/output-character-mode/#decision","title":"Decision","text":"<p>We implemented global output character mode with centralized conversion using charset definitions.</p>"},{"location":"dev/arch-decisions/output-character-mode/#mode-options","title":"Mode Options","text":"<p>Three modes are available: - <code>default</code>: Auto-detects terminal UTF-8 support at runtime \u2192 fancy if supported, otherwise ASCII - <code>fancy</code>: Forces Unicode output with box-drawing characters and fancy markers - <code>ascii</code>: Forces ASCII-only output with transliteration fallback to <code>?</code> for unknown characters</p>"},{"location":"dev/arch-decisions/output-character-mode/#configuration","title":"Configuration","text":"<ul> <li>CLI: <code>-O/--output-chars MODE</code> flag (case-insensitive, short forms <code>d|f|a</code>)</li> <li>MCP: Optional <code>output_chars</code> parameter in tool requests (overrides server default)</li> <li>No environment variable: Intentionally omitted to keep configuration simple and explicit</li> </ul>"},{"location":"dev/arch-decisions/output-character-mode/#core-implementation","title":"Core Implementation","text":"<p>The <code>OutputChars</code> module (<code>lib/cov_loupe/output_chars.rb</code>) provides:</p> <pre><code>module OutputChars\n  # Mode resolution\n  def self.resolve_mode(mode)\n    return :fancy if mode == :fancy\n    return :ascii if mode == :ascii\n    # default: detect terminal UTF-8 support\n    stdout_utf8? ? :fancy : :ascii\n  end\n\n  # Character conversion using transliteration map\n  def self.convert(text, mode)\n    return text unless mode == :ascii\n    text.chars.map { |c| TRANSLITERATIONS[c] || c.ascii_only? ? c : '?' }.join\n  end\n\n  # Charset selection\n  def self.charset_for(mode)\n    mode == :fancy ? FANCY_CHARSET : ASCII_CHARSET\n  end\nend\n</code></pre>"},{"location":"dev/arch-decisions/output-character-mode/#transliteration-strategy","title":"Transliteration Strategy","text":"<p>Instead of a generic library (like <code>ActiveSupport::Multibyte</code>), we use an internal <code>TRANSLITERATIONS</code> hash mapping common characters to ASCII equivalents:</p> <ul> <li>Accented Latin characters (\u00e1 \u2192 a, \u00e9 \u2192 e, \u00f1 \u2192 n, etc.)</li> <li>Symbols and punctuation (\u2192 -&gt;, \u2014 --, \u00a9 (C), etc.)</li> <li>Box-drawing characters (\u2502 \u2192 |, \u2500 \u2192 -, \u250c \u2192 +, etc.)</li> </ul> <p>Characters without defined mappings fall back to <code>?</code> to maintain ASCII-only output.</p>"},{"location":"dev/arch-decisions/output-character-mode/#formatter-integration","title":"Formatter Integration","text":"<p>All formatters respect the <code>output_chars</code> parameter:</p> <ol> <li>JSON: Uses <code>JSON.generate(..., ascii_only: true)</code> in ASCII mode</li> <li>YAML: Post-processes through <code>OutputChars.convert</code></li> <li>AmazingPrint: Post-processes through <code>OutputChars.convert</code></li> <li>Tables: Uses appropriate charset (<code>OutputChars.charset_for</code>) and converts cell contents</li> <li>Source: Uses ASCII-safe markers (<code>+</code>/<code>-</code> instead of <code>\u2713</code>/<code>\u00b7</code>) and converts source code</li> </ol>"},{"location":"dev/arch-decisions/output-character-mode/#error-message-integration","title":"Error Message Integration","text":"<ul> <li>CLI error handlers convert messages via <code>OutputChars.convert</code></li> <li>Staleness error messages convert file paths via <code>convert_path</code> lambda</li> <li>Option parser errors converted before display</li> <li>Backtrace lines converted in debug mode</li> </ul>"},{"location":"dev/arch-decisions/output-character-mode/#scope-of-conversion","title":"Scope of Conversion","text":"<p>Converted in ASCII mode: - All CLI error messages and option parser errors - Staleness error messages and file paths - Command literal strings (via <code>convert_text</code> helper in BaseCommand) - MCP tool JSON responses (via <code>respond_json</code> with <code>ascii_only: true</code>) - All formatted output (tables, source, JSON, YAML)</p> <p>Not converted in ASCII mode: - Log files: Preserved in original encoding for debugging fidelity. Log files are system/debugging artifacts, not user-facing output. Converting would lose exact file paths and error details needed for troubleshooting, create inconsistency between logged paths and actual filesystem paths, and provides no user value since logs are developer artifacts. - Gem post-install message: Intentionally left unchanged per requirements</p>"},{"location":"dev/arch-decisions/output-character-mode/#consequences","title":"Consequences","text":""},{"location":"dev/arch-decisions/output-character-mode/#positive","title":"Positive","text":"<ol> <li>Broad compatibility: Works in any terminal environment, including legacy systems</li> <li>Better UX: Fancy mode provides enhanced readability when Unicode is supported</li> <li>Auto-detection: Default mode adapts to environment without user configuration</li> <li>Comprehensive coverage: All output channels respect the mode setting</li> <li>MCP parity: CLI and MCP interfaces have identical behavior</li> <li>No dependencies: Internal transliteration map avoids external dependencies</li> <li>Consistent behavior: Single source of truth for character conversion</li> </ol>"},{"location":"dev/arch-decisions/output-character-mode/#negative","title":"Negative","text":"<ol> <li>Complexity: Additional configuration option and conversion logic to maintain</li> <li>Transliteration coverage: Not all Unicode characters have mappings (falls back to <code>?</code>)</li> <li>Performance: Conversion overhead for every output operation (minimal in practice)</li> <li>Test burden: Comprehensive tests needed across all formatters and modes</li> </ol>"},{"location":"dev/arch-decisions/output-character-mode/#trade-offs","title":"Trade-offs","text":"<ul> <li>Internal vs external transliteration: Internal map is less comprehensive but avoids dependencies and keeps behavior predictable</li> <li>Charset vs post-processing: Charsets are cleaner but require formatter awareness; post-processing is simpler but can corrupt structured data</li> <li>Auto-detection vs explicit default: Auto-detection is more convenient but less predictable; explicit default is clearer but requires configuration</li> </ul>"},{"location":"dev/arch-decisions/output-character-mode/#future-constraints","title":"Future Constraints","text":"<ul> <li>Any new formatters must respect <code>output_chars</code> parameter</li> <li>New output channels (e.g., HTML) need ASCII mode support</li> <li>Transliteration map must be maintained as new characters are encountered</li> <li>Log files must never be converted (documented design decision)</li> </ul>"},{"location":"dev/arch-decisions/output-character-mode/#implementation-notes","title":"Implementation Notes","text":""},{"location":"dev/arch-decisions/output-character-mode/#mode-precedence","title":"Mode Precedence","text":"<ol> <li>Explicit mode parameter (CLI flag or MCP tool parameter)</li> <li>Server default (for MCP)</li> <li>Built-in default (auto-detect UTF-8 support)</li> </ol>"},{"location":"dev/arch-decisions/output-character-mode/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Conversion only applies in ASCII mode (fancy mode is a no-op)</li> <li>Transliteration map lookup is O(1) per character</li> <li>JSON <code>ascii_only: true</code> is optimized by the json gem</li> <li>Overall performance impact is negligible (&lt; 1ms for typical outputs)</li> </ul>"},{"location":"dev/arch-decisions/output-character-mode/#testing-strategy","title":"Testing Strategy","text":"<p>Comprehensive test coverage ensures correctness:</p> <ul> <li>Mode resolution and normalization tests</li> <li>Formatter tests for both ASCII and fancy modes</li> <li>CLI option parsing tests for <code>--output-chars</code> flag</li> <li>MCP tool output mode tests</li> <li>Staleness error message tests with Unicode file paths</li> <li>Integration tests across all subcommands with Unicode file names</li> </ul>"},{"location":"dev/arch-decisions/output-character-mode/#references","title":"References","text":"<ul> <li>Core implementation: <code>lib/cov_loupe/output_chars.rb</code></li> <li>Configuration: <code>lib/cov_loupe/config/app_config.rb</code>, <code>lib/cov_loupe/config/option_normalizers.rb</code></li> <li>Formatters:</li> <li><code>lib/cov_loupe/formatters/formatters.rb</code> (JSON, YAML, AmazingPrint)</li> <li><code>lib/cov_loupe/formatters/table_formatter.rb</code> (tables)</li> <li><code>lib/cov_loupe/formatters/source_formatter.rb</code> (source code)</li> <li>Error handling: <code>lib/cov_loupe/cli.rb</code>, <code>lib/cov_loupe/errors/error_handler.rb</code></li> <li>MCP integration: <code>lib/cov_loupe/base_tool.rb</code>, <code>lib/cov_loupe/tools/*.rb</code></li> <li>CLI option parsing: <code>lib/cov_loupe/config/option_parser_builder.rb</code></li> <li>Tests:</li> <li><code>spec/cov_loupe/output_chars_spec.rb</code></li> <li><code>spec/cov_loupe/formatters/*_spec.rb</code></li> <li><code>spec/cov_loupe/cli/cli_output_chars_spec.rb</code></li> <li><code>spec/cov_loupe/tools/*_spec.rb</code></li> <li>Review document: <code>docs/dev/output-chars-review.md</code></li> </ul>"},{"location":"dev/arch-decisions/path-resolution/","title":"Path Resolution Strategy","text":"<p>Back to ADR Index</p>"},{"location":"dev/arch-decisions/path-resolution/#cross-os-coverage-data-support","title":"Cross-OS Coverage Data Support","text":""},{"location":"dev/arch-decisions/path-resolution/#status","title":"Status","text":"<p>Accepted (2025-12-26)</p>"},{"location":"dev/arch-decisions/path-resolution/#context","title":"Context","text":"<p>SimpleCov's <code>.resultset.json</code> files contain file paths as keys in the coverage data hash. These paths are typically absolute paths from the machine where tests were run. Different operating systems use different path separators: - Unix/Linux/macOS: <code>/</code> - Windows: <code>\\</code> (backslash)</p> <p>Early versions of cov-loupe included path normalization logic that converted backslashes to forward slashes, enabling cross-platform path matching. This was motivated by a theoretical use case: analyzing a <code>.resultset.json</code> file generated on one OS (e.g., Windows) on a different OS (e.g., Linux/macOS).</p> <p>Upon closer examination, this cross-OS scenario is unrealistic for several reasons:</p> <ol> <li>CI/CD workflows \u2013 While coverage files might be generated in CI (often Linux), developers typically either:</li> <li>Re-run tests locally to generate fresh coverage</li> <li>View coverage reports rendered by SimpleCov's HTML formatter</li> <li> <p>Use hosted coverage services (Codecov, Coveralls)</p> </li> <li> <p>Docker development \u2013 When tests run in containers, volume mounting ensures paths already match the host environment</p> </li> <li> <p>Path structure differences \u2013 Cross-OS paths differ in more ways than just separators (drive letters, root paths, etc.), making simple separator normalization insufficient</p> </li> <li> <p>Same-machine path variations \u2013 The legitimate use case is handling different working directories or relative vs absolute paths on the same machine, not across different OSes</p> </li> </ol>"},{"location":"dev/arch-decisions/path-resolution/#decision","title":"Decision","text":"<p>Do not support analyzing <code>.resultset.json</code> files across different operating systems.</p> <p>Specifically: - Normalize backslashes to forward slashes on Windows only - Apply case-insensitive path matching on Windows (filesystem is case-insensitive) - Apply case-sensitive path matching on Unix (filesystem is case-sensitive) - Keep path resolution focused on same-OS scenarios:   - Exact absolute path matching   - Relative path matching (stripping project root) - Trust that paths in coverage data use the native separator for the OS where cov-loupe runs</p>"},{"location":"dev/arch-decisions/path-resolution/#consequences","title":"Consequences","text":"<p>Benefits: - Simpler code \u2013 No need for path separator normalization logic - Clearer semantics \u2013 Path matching behavior is more predictable - Fewer edge cases \u2013 No ambiguity around mixed separator styles - Honest API \u2013 We don't promise cross-OS compatibility we can't fully deliver</p> <p>Trade-offs: - Users cannot analyze Windows <code>.resultset.json</code> files on Linux/macOS or vice versa   - This is acceptable because this scenario is impractical anyway   - Users who encounter this should re-run tests in their current environment</p> <p>No impact on: - Same-OS path resolution (absolute, relative) - Normal development workflows - CI/CD integration - Docker/container-based development</p>"},{"location":"dev/arch-decisions/path-resolution/#implementation","title":"Implementation","text":"<p>Path normalization is centralized in the <code>PathUtils</code> module (<code>lib/cov_loupe/path_utils.rb</code>). It handles: - Normalizing path separators (backslashes to forward slashes on Windows) - Case normalization for case-insensitive volumes (autodetected or explicit) - Path cleaning</p> <p><code>CoverageLineResolver</code> delegates all path normalization to <code>PathUtils.normalize</code>, avoiding scattered platform checks and keeping the resolver logic focused on lookup strategies.</p>"},{"location":"dev/arch-decisions/path-resolution/#path-comparison-strategy","title":"Path Comparison Strategy","text":"<p>Path comparison uses a normalize-for-comparison-only approach rather than normalize-and-store:</p> <ul> <li>Original paths are preserved - <code>PathUtils.expand</code> preserves the original case to avoid corrupting displayed file paths</li> <li>Normalization happens at comparison time - The <code>normalized_start_with?</code> helper method normalizes both paths internally for comparison but doesn't modify the originals</li> <li>Boundary checking - Prevents false matches where a path starts with a prefix string but isn't actually within that directory (e.g., <code>/home/user/project</code> should not match <code>/home/user/project-backup/file.rb</code>)</li> </ul> <p>This approach ensures: 1. User-visible paths maintain original casing for better UX 2. Path matching works correctly on case-insensitive volumes (Windows, most macOS) 3. Mixed path separators (forward slash vs backslash) are handled transparently 4. Directory boundary checking prevents incorrect prefix matches</p>"},{"location":"dev/arch-decisions/path-resolution/#references","title":"References","text":"<ul> <li>Implementation: <code>lib/cov_loupe/resolvers/coverage_line_resolver.rb</code> (delegates to <code>PathUtils</code>)</li> <li>Central Logic: <code>lib/cov_loupe/path_utils.rb</code></li> <li>Related tests removed: <code>spec/resolvers/coverage_line_resolver_spec.rb</code> (cross-OS separator normalization context)</li> </ul>"},{"location":"dev/arch-decisions/policy-validation/","title":"Policy Validation","text":"<p>Back to main README</p> <p>This document describes how cov-loupe allows users to define and enforce custom coverage policies through success predicates.</p>"},{"location":"dev/arch-decisions/policy-validation/#ruby-instance_eval-for-success-predicates","title":"Ruby <code>instance_eval</code> for Success Predicates","text":""},{"location":"dev/arch-decisions/policy-validation/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"dev/arch-decisions/policy-validation/#context","title":"Context","text":"<p>cov-loupe needed a mechanism for users to define custom coverage policies beyond simple percentage thresholds. Different projects have different requirements:</p> <ul> <li>Some want all files above 80%, others allow a few files below threshold</li> <li>Some need different thresholds for different directories (e.g., 90% for API code, 60% for legacy)</li> <li>Some want total project coverage minimums</li> <li>CI/CD pipelines need exit codes based on policy compliance</li> </ul> <p>We considered several approaches:</p> <ol> <li>Built-in policy DSL: Define a limited language for expressing policies (e.g., YAML/JSON config)</li> <li>Plugin architecture: Define a protocol/interface, require users to create Ruby classes implementing it</li> <li>Ruby file evaluation: Load and execute arbitrary Ruby code that returns a callable predicate</li> <li>Sandboxed DSL: Use a restricted Ruby environment (e.g., <code>$SAFE</code> levels, isolated VMs)</li> </ol>"},{"location":"dev/arch-decisions/policy-validation/#key-requirements","title":"Key Requirements","text":"<ul> <li>Flexibility: Support arbitrarily complex coverage policies</li> <li>Simplicity: Easy for users to write and understand</li> <li>Debuggability: Users can use standard Ruby debugging tools</li> <li>CI/CD integration: Clear exit codes (0 = pass, 1 = fail, 2 = error)</li> <li>Access to coverage data: Predicates need access to the full <code>CoverageModel</code> API</li> </ul>"},{"location":"dev/arch-decisions/policy-validation/#why-not-a-custom-dsl","title":"Why Not a Custom DSL?","text":"<p>A custom DSL would be: - Limited in expressiveness (hard to predict all future use cases) - Harder to debug (users can't use standard Ruby tools) - More maintenance burden (parsing, validation, documentation) - Still vulnerable to injection if it allowed any dynamic computation</p>"},{"location":"dev/arch-decisions/policy-validation/#why-not-sandboxing","title":"Why Not Sandboxing?","text":"<p>Ruby's sandboxing options are limited: - <code>$SAFE</code> levels were deprecated and removed in Ruby 2.7+ - Full VM isolation (Docker, etc.) is too heavy for a CLI tool - Any Turing-complete sandbox can be escaped given enough effort - True security requires not executing untrusted code at all</p>"},{"location":"dev/arch-decisions/policy-validation/#decision","title":"Decision","text":"<p>We chose to evaluate Ruby files using <code>instance_eval</code> with prominent security warnings rather than attempting to create a false sense of security through incomplete sandboxing.</p>"},{"location":"dev/arch-decisions/policy-validation/#implementation","title":"Implementation","text":"<p>The implementation is in <code>lib/cov_loupe/cli.rb</code> (<code>CoverageCLI#load_success_predicate</code>):</p> <pre><code>def load_success_predicate(path)\n  unless File.exist?(path)\n    raise \"Success predicate file not found: #{path}\"\n  end\n\n  content = File.read(path)\n\n  # WARNING: The predicate code executes with full Ruby privileges.\n  # It has unrestricted access to the file system, network, and system commands.\n  # Only use predicate files from trusted sources.\n  #\n  # We evaluate in a fresh Object context to prevent accidental access to\n  # CLI internals, but this provides NO security isolation.\n  evaluation_context = Object.new\n  predicate = evaluation_context.instance_eval(content, path, 1)\n\n  unless predicate.respond_to?(:call)\n    raise \"Success predicate must be callable (lambda, proc, or object with #call method)\"\n  end\n\n  predicate\nrescue SyntaxError =&gt; e\n  raise \"Syntax error in success predicate file: #{e.message}\"\nend\n</code></pre> <p>The predicate is then called with a <code>CoverageModel</code> instance:</p> <pre><code>def run_success_predicate\n  predicate = load_success_predicate(config.success_predicate)\n  model = CoverageModel.new(**config.model_options)\n\n  result = predicate.call(model)\n  exit(result ? 0 : 1)  # 0 = success, 1 = failure\nrescue =&gt; e\n  warn \"Success predicate error: #{e.message}\"\n  warn e.backtrace.first(5).join(\"\\n\") if config.error_mode == :debug\n  exit 2  # Exit code 2 for predicate errors\nend\n</code></pre>"},{"location":"dev/arch-decisions/policy-validation/#security-model-treat-as-executable-code","title":"Security Model: Treat as Executable Code","text":"<p>Rather than pretending to sandbox untrusted code, we treat success predicates exactly like any other Ruby code in the project:</p> <ol> <li> <p>Prominent warnings in documentation (highlighted near the top of <code>examples/success_predicates/README.md</code>):    <pre><code>\u26a0\ufe0f SECURITY WARNING\n\nSuccess predicates execute as arbitrary Ruby code with full system privileges.\nOnly use predicate files from trusted sources.\n- Never use predicates from untrusted or unknown sources\n- Review predicates before use, especially in CI/CD environments\n- Store predicates in version control with code review\n</code></pre></p> </li> <li> <p>Code review workflow: Predicates live in version control alongside tests</p> </li> <li>CI/CD best practices: Same permissions model as running tests themselves</li> <li>Example predicates: Well-documented examples showing safe patterns</li> </ol>"},{"location":"dev/arch-decisions/policy-validation/#predicate-api","title":"Predicate API","text":"<p>Success predicates must be callable (lambda, proc, or object with <code>#call</code> method):</p> <p>Lambda example: <pre><code>-&gt;(model) do\n  model.list.all? { |f| f['percentage'] &gt;= 80 }\nend\n</code></pre></p> <p>Class example:</p> <pre><code>class CoveragePolicy\n  def call(model)\n    api_files = model.list['files'].select { |f| f['file'].start_with?('lib/api/') }\n    api_files.all? { |f| f['percentage'] &gt;= 90 }\n  end\nend\n\nAllFilesAboveThreshold.new\n</code></pre> <p>The predicate receives a full <code>CoverageModel</code> instance with access to: - <code>list(tracked_globs:, sort_order:)</code> - All file coverage data - <code>summary_for(path)</code> - Coverage summary for a specific file - <code>uncovered_for(path)</code> - Uncovered lines for a specific file - <code>detailed_for(path)</code> - Per-line coverage data</p>"},{"location":"dev/arch-decisions/policy-validation/#consequences","title":"Consequences","text":""},{"location":"dev/arch-decisions/policy-validation/#positive","title":"Positive","text":"<ol> <li>Maximum flexibility: Users can express arbitrarily complex coverage policies using full Ruby</li> <li>Familiar tooling: Users can debug predicates with standard Ruby tools (pry, byebug, etc.)</li> <li>Simplicity: No custom DSL to learn, document, or maintain</li> <li>Honesty: Security model is clear and doesn't provide false confidence</li> <li>Composability: Users can require other libraries, define helper methods, etc.</li> <li>Excellent examples: We provide 5+ well-documented example predicates</li> </ol>"},{"location":"dev/arch-decisions/policy-validation/#negative","title":"Negative","text":"<ol> <li>Security responsibility: Users must understand the security implications</li> <li>Potential misuse: Users might mistakenly trust untrusted predicate files</li> <li>No isolation: Buggy predicates can access/modify anything in the system</li> <li>Documentation burden: Must clearly communicate security model</li> </ol>"},{"location":"dev/arch-decisions/policy-validation/#trade-offs","title":"Trade-offs","text":"<ul> <li>Versus custom DSL: More powerful and debuggable, but requires user awareness of security</li> <li>Versus plugin architecture: Simpler (no gem dependencies, no protocol to learn), but same security profile</li> <li>Versus incomplete sandboxing: Honest about capabilities rather than security theater</li> </ul>"},{"location":"dev/arch-decisions/policy-validation/#threat-model","title":"Threat Model","text":"<p>This approach is appropriate when: - Predicate files are stored in version control with code review - Users treat predicates like any other code in their project (tests, Rakefile, etc.) - CI/CD environments already execute arbitrary code (tests, build scripts)</p> <p>This approach is inappropriate when: - Processing untrusted predicate files from unknown sources - Allowing users to upload predicates via web interface - Running in a multi-tenant environment without isolation</p>"},{"location":"dev/arch-decisions/policy-validation/#future-considerations","title":"Future Considerations","text":"<p>If demand arises for truly untrusted predicate execution, alternatives include:</p> <ol> <li>JSON-based policy format: Limited expressiveness but safe</li> <li>WebAssembly sandbox: Execute policies in an isolated WASM runtime</li> <li>External process: Run predicates in separate process with restricted permissions</li> </ol> <p>However, for the primary use case (CI/CD policy enforcement), the current approach is simpler and more flexible than these alternatives.</p>"},{"location":"dev/arch-decisions/policy-validation/#references","title":"References","text":"<ul> <li>Implementation: <code>lib/cov_loupe/cli.rb</code> (<code>CoverageCLI#load_success_predicate</code> and <code>#run_success_predicate</code>)</li> <li>Security warnings: <code>examples/success_predicates/README.md</code></li> <li>Example predicates: <code>examples/success_predicates/*.rb</code></li> <li>CoverageModel API: <code>lib/cov_loupe/model.rb</code></li> <li>CLI config: <code>lib/cov_loupe/cli_config.rb</code> (<code>success_predicate</code> field)</li> <li>Option parsing: <code>lib/cov_loupe/option_parser_builder.rb</code> (<code>--success-predicate</code> flag)</li> </ul>"},{"location":"dev/arch-decisions/simplecov-integration/","title":"SimpleCov Integration","text":"<p>Back to main README</p> <p>This document describes how cov-loupe integrates with SimpleCov and manages its dependency on the SimpleCov gem.</p>"},{"location":"dev/arch-decisions/simplecov-integration/#simplecov-runtime-dependency","title":"SimpleCov Runtime Dependency","text":""},{"location":"dev/arch-decisions/simplecov-integration/#status","title":"Status","text":"<p>Replaced \u2013 cov-loupe now requires SimpleCov at runtime so that multi-suite resultsets can be merged using SimpleCov's combine helpers.</p>"},{"location":"dev/arch-decisions/simplecov-integration/#original-context","title":"Original Context","text":"<p>cov-loupe provides tooling for inspecting SimpleCov coverage reports. When designing the gem, we had to decide whether to depend on SimpleCov as a runtime dependency.</p>"},{"location":"dev/arch-decisions/simplecov-integration/#alternative-approaches","title":"Alternative Approaches","text":"<ol> <li>Runtime dependency on SimpleCov: Use SimpleCov's API to read and process coverage data</li> <li>Development-only dependency: Read SimpleCov's <code>.resultset.json</code> files directly without requiring SimpleCov at runtime</li> <li>Support multiple coverage formats: Parse coverage data from multiple tools (SimpleCov, Coverage, etc.)</li> </ol>"},{"location":"dev/arch-decisions/simplecov-integration/#key-considerations","title":"Key Considerations","text":"<p>Dependency weight: SimpleCov itself has dependencies: - <code>docile</code> (~&gt; 1.1) - <code>simplecov-html</code> (~&gt; 0.11) - <code>simplecov_json_formatter</code> (~&gt; 0.1)</p> <p>Use case separation: - SimpleCov is needed when running tests to collect coverage - cov-loupe is needed when inspecting coverage after tests complete - These are temporally separated activities</p> <p>Deployment contexts: - CI/CD: Coverage collection happens in test job, inspection might happen in a separate analysis job - Production: Some teams want to analyze coverage data without installing test dependencies - Developer machines: May want to inspect coverage without full test suite dependencies</p> <p>Format stability: - SimpleCov's <code>.resultset.json</code> format is stable and well-documented - The format is simple JSON with predictable structure - Breaking changes would affect all SimpleCov users, so the format is unlikely to change</p>"},{"location":"dev/arch-decisions/simplecov-integration/#original-decision","title":"Original Decision","text":"<p>We initially chose to make SimpleCov a development dependency only and read <code>.resultset.json</code> files directly using Ruby's standard library JSON parser.</p>"},{"location":"dev/arch-decisions/simplecov-integration/#revision-simplecov-as-runtime-dependency","title":"Revision: SimpleCov as Runtime Dependency","text":"<p>cov-loupe now depends on SimpleCov at runtime for the following reasons:</p> <ol> <li>Multi-suite merging: Projects using multiple test suites (e.g., RSpec + Minitest) produce separate coverage results that must be merged using SimpleCov's <code>SimpleCov::ResultMerger.merge_results</code></li> <li>Consistent calculations: SimpleCov's coverage percentage algorithms handle edge cases that are difficult to replicate correctly</li> <li>Format compatibility: Changes to SimpleCov's internal data structures are automatically handled by using its API</li> </ol>"},{"location":"dev/arch-decisions/simplecov-integration/#current-implementation","title":"Current Implementation","text":"<p>cov-loupe currently depends on <code>amazing_print</code>, <code>mcp</code>, and <code>simplecov</code> at runtime.</p> <p>Coverage data is read directly from JSON files by <code>CovLoupe::CoverageModel#load_coverage_data</code>: <pre><code>rs = Resolvers::ResolverHelpers.find_resultset(@root, resultset: resultset)\nloaded = ResultsetLoader.load(resultset_path: rs)\ncoverage_map = loaded.coverage_map or raise(CoverageDataError, \"No 'coverage' key found in resultset file: #{rs}\")\n@cov = coverage_map.transform_keys { |k| File.absolute_path(k, @root) }\n@cov_timestamp = loaded.timestamp\n</code></pre></p> <p>Coverage calculations use simple algorithms in <code>CovLoupe::CoverageCalculator</code> (<code>summary</code>, <code>uncovered</code>, <code>detailed</code>): <pre><code>def summary(arr)\n  total = 0\n  covered = 0\n  arr.compact.each do |hits|\n    total += 1\n    covered += 1 if hits.to_i &gt; 0\n  end\n  percentage = total.zero? ? 100.0 : ((covered.to_f * 100.0 / total) * 100).round / 100.0\n  { 'covered' =&gt; covered, 'total' =&gt; total, 'percentage' =&gt; percentage }\nend\n\ndef uncovered(arr)\n  out = []\n  arr.each_with_index do |hits, i|\n    next if hits.nil?\n    out &lt;&lt; (i + 1) if hits.to_i.zero?\n  end\n  out\nend\n\ndef detailed(arr)\n  rows = []\n  arr.each_with_index do |hits, i|\n    h = hits&amp;.to_i\n    rows &lt;&lt; { 'line' =&gt; i + 1, 'hits' =&gt; h, 'covered' =&gt; h.positive? } if h\n  end\n  rows\nend\n</code></pre></p>"},{"location":"dev/arch-decisions/simplecov-integration/#simplecov-resultsetjson-format","title":"SimpleCov .resultset.json Format","text":"<p>The format we parse has this structure: <pre><code>{\n  \"RSpec\": {\n    \"coverage\": {\n      \"/absolute/path/to/file.rb\": {\n        \"lines\": [null, 1, 3, 0, null, 5, ...]\n      }\n    },\n    \"timestamp\": 1633072800\n  }\n}\n</code></pre></p> <p>Where: - Top level keys are test suite names (e.g., \"RSpec\", \"Minitest\") - <code>coverage</code> contains file paths mapped to coverage data - <code>lines</code> is an array where each index represents a line number (0-indexed) - Array values: <code>null</code> = not executable, <code>0</code> = not covered, <code>&gt;0</code> = hit count - <code>timestamp</code> is Unix timestamp when coverage was collected</p>"},{"location":"dev/arch-decisions/simplecov-integration/#resultset-discovery","title":"Resultset Discovery","text":"<p>We implement flexible discovery of <code>.resultset.json</code> files via <code>Resolvers::ResultsetPathResolver::DEFAULT_CANDIDATES</code>: <pre><code>DEFAULT_CANDIDATES = [\n  '.resultset.json',\n  'coverage/.resultset.json',\n  'tmp/.resultset.json'\n].freeze\n</code></pre></p> <p>This supports common SimpleCov configurations without requiring SimpleCov to be loaded.</p>"},{"location":"dev/arch-decisions/simplecov-integration/#consequences","title":"Consequences","text":""},{"location":"dev/arch-decisions/simplecov-integration/#positive-original-development-only-approach","title":"Positive (Original Development-Only Approach)","text":"<ol> <li>Lightweight installation: No transitive dependencies beyond <code>mcp</code> gem</li> <li>Deployment flexibility: Can analyze coverage in environments without test dependencies</li> <li>Faster installation: Fewer gems to download and install</li> <li>Clear separation of concerns: Coverage collection vs. coverage analysis are independent</li> <li>CI/CD optimization: Analysis jobs don't need full test suite dependencies</li> <li>Production-safe: Can be deployed to production environments if needed (e.g., for monitoring)</li> </ol>"},{"location":"dev/arch-decisions/simplecov-integration/#negative-original-development-only-approach","title":"Negative (Original Development-Only Approach)","text":"<ol> <li>Format dependency: Tightly coupled to SimpleCov's JSON format</li> <li>Breaking changes risk: If SimpleCov changes <code>.resultset.json</code> structure, we must adapt</li> <li>Limited to SimpleCov: Cannot read coverage data from other Ruby coverage tools</li> <li>Duplicate logic: Coverage percentage calculations reimplemented (though simple)</li> <li>Maintenance: Must track SimpleCov format changes manually</li> </ol>"},{"location":"dev/arch-decisions/simplecov-integration/#trade-offs-current-runtime-dependency-approach","title":"Trade-offs (Current Runtime Dependency Approach)","text":"<ul> <li>Versus development-only dependency: Heavier installation footprint, but better multi-suite support and format compatibility</li> <li>Versus multi-format support: Simpler implementation but locked to SimpleCov ecosystem</li> <li>Versus custom merging logic: More reliable but requires SimpleCov at runtime</li> </ul>"},{"location":"dev/arch-decisions/simplecov-integration/#risk-mitigation","title":"Risk Mitigation","text":"<ol> <li>Format stability: SimpleCov has maintained <code>.resultset.json</code> compatibility for years</li> <li>Simple format: JSON structure is straightforward and unlikely to change dramatically</li> <li>Development dependency: We still use SimpleCov in our own tests, so format changes would be detected immediately</li> <li>Documentation: AGENTS.md documents the format dependency explicitly</li> <li>Error handling: Robust error messages when format doesn't match expectations</li> </ol>"},{"location":"dev/arch-decisions/simplecov-integration/#format-evolution-strategy","title":"Format Evolution Strategy","text":"<p>If SimpleCov's format changes: 1. Minor additions (new keys): Ignore unknown keys, only parse what we need 2. Breaking changes (structure changes): Version detection logic to support multiple formats 3. Alternative formats: Could add support for other coverage tools' JSON formats if needed</p>"},{"location":"dev/arch-decisions/simplecov-integration/#current-limitations-accepted","title":"Current Limitations Accepted","text":"<ul> <li>Only supports SimpleCov (not Coverage gem, other tools)</li> <li>Assumes standard <code>.resultset.json</code> locations</li> <li>Multi-suite merging requires SimpleCov runtime dependency</li> <li>No support for branch coverage (SimpleCov feature not widely used yet)</li> </ul>"},{"location":"dev/arch-decisions/simplecov-integration/#references","title":"References","text":"<ul> <li>Gemspec dependencies: <code>cov-loupe.gemspec</code> (<code>spec.add_dependency</code> entries)</li> <li>JSON parsing: <code>lib/cov_loupe/resultset_loader.rb</code> (<code>ResultsetLoader.load</code>)</li> <li>Coverage calculations: <code>lib/cov_loupe/coverage_calculator.rb</code> (<code>CoverageCalculator.summary</code>, <code>.uncovered</code>, <code>.detailed</code>)</li> <li>Resultset discovery: <code>lib/cov_loupe/resolvers/resultset_path_resolver.rb</code> (<code>ResultsetPathResolver::DEFAULT_CANDIDATES</code>)</li> <li>SimpleCov format documentation: https://github.com/simplecov-ruby/simplecov</li> <li>Development usage: Uses SimpleCov in <code>spec/spec_helper.rb</code> to test itself</li> </ul>"},{"location":"dev/presentations/cov-loupe-presentation/","title":"Presentations","text":"<p>Back to main README</p> <p>marp: true theme: default class: lead paginate: true backgroundColor: #fff color: #333</p>"},{"location":"dev/presentations/cov-loupe-presentation/#covloupe","title":"CovLoupe","text":""},{"location":"dev/presentations/cov-loupe-presentation/#mcp-server-cli-and-library-for-simplecov-ruby-test-coverage","title":"MCP Server, CLI, and Library for SimpleCov Ruby Test Coverage","text":"<ul> <li>Keith Bennett</li> <li>First presented to PhRUG (Philippines Ruby User Group), 2025-10-01</li> </ul>"},{"location":"dev/presentations/cov-loupe-presentation/#what-is-cov-loupe","title":"What is cov-loupe?","text":"<p>A three-in-one gem that makes SimpleCov coverage data accessible to:</p> <ul> <li>\ud83e\udd16 AI agents via Model Context Protocol (MCP)</li> <li>\ud83d\udcbb Command line via its command line interface</li> <li>\ud83d\udcda Ruby scripts and applications as a library</li> </ul> <p>Lazy dependency on SimpleCov - single-suite resultsets avoid loading it; multi-suite files trigger a merge via SimpleCov\u2019s combine helpers.</p> <p>What is it not? It is not a replacement for SimpleCov's generated web presentation of the coverage data.</p> <p>This code base requires a Ruby version &gt;= 3.2.0, because this is required by the mcp gem it uses.</p>"},{"location":"dev/presentations/cov-loupe-presentation/#high-level-objectives","title":"High Level Objectives","text":"<ul> <li>Query coverage programmatically</li> <li>Integrate with AI tools</li> <li>Automate coverage analysis</li> <li>Focus on specific files/patterns</li> </ul>"},{"location":"dev/presentations/cov-loupe-presentation/#key-features","title":"Key Features","text":"<ul> <li>Lazy SimpleCov dependency - only loaded when multi-suite resultsets need merging</li> <li>Flexible resultset location - via CLI flags, passed parameter, or env var</li> <li>Staleness detection - warns or optionally errors when files newer than coverage</li> <li>JSON output - perfect for jq, scripts, CI/CD</li> <li>Source code integration - show uncovered lines with or without context</li> <li>Colored output - readable terminal display</li> </ul>"},{"location":"dev/presentations/cov-loupe-presentation/#demo-1-mcp-server-mode","title":"Demo 1: MCP Server Mode","text":""},{"location":"dev/presentations/cov-loupe-presentation/#ai-coverage-assistant","title":"AI Coverage Assistant","text":"<pre><code># Test the MCP server manually\necho '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"coverage_summary_tool\",\"arguments\":{\"path\":\"lib/cov_loupe/model.rb\"}}}' | cov-loupe -m mcp\n</code></pre> <p>What AI agents can do: - Analyze coverage gaps - Suggest testing priorities - Generate ad-hoc coverage reports</p>"},{"location":"dev/presentations/cov-loupe-presentation/#mcp-tools-functions-available","title":"MCP Tools (Functions) Available","text":"Tool Purpose Example CLI Command <code>list_tool</code> Project-wide coverage data <code>cov-loupe list</code> <code>coverage_detailed_tool</code> Per-line hit counts <code>cov-loupe detailed lib/cov_loupe/model.rb</code> <code>coverage_raw_tool</code> Raw SimpleCov lines array <code>cov-loupe raw lib/cov_loupe/model.rb</code> <code>coverage_summary_tool</code> Get coverage % for a file <code>cov-loupe summary lib/cov_loupe/model.rb</code> <code>coverage_table_tool</code> Formatted coverage table <code>cov-loupe list</code> <code>coverage_totals_tool</code> Aggregated line totals <code>cov-loupe totals</code> <code>validate_tool</code> Validate coverage policy <code>cov-loupe validate coverage_policy.rb</code> <code>help_tool</code> Tool usage guidance <code>cov-loupe --help</code> <code>uncovered_lines_tool</code> Find missing test coverage <code>cov-loupe uncovered lib/cov_loupe/cli.rb</code> <code>version_tool</code> Display version info <code>cov-loupe version</code>"},{"location":"dev/presentations/cov-loupe-presentation/#demo-2-cli-tool","title":"Demo 2: CLI Tool","text":""},{"location":"dev/presentations/cov-loupe-presentation/#_1","title":"Presentations","text":"<pre><code># Show all files, best coverage first\ncov-loupe\n\n# Focus on a specific file\ncov-loupe summary lib/cov_loupe/cli.rb\n\n# Find untested lines with source context\ncov-loupe uncovered lib/cov_loupe/cli.rb --source=uncovered --context-lines 3\n\n# JSON for scripts\ncov-loupe -fJ | jq '.files[] | select(.percentage &lt; 80)'\n\n# Ruby alternative:\ncov-loupe -fJ | ruby -r json -e '\n  JSON.parse($stdin.read)[\"files\"].select { |f| f[\"percentage\"] &lt; 80 }.each do |f|\n    puts JSON.pretty_generate(f)\n  end\n'\n\n# Rexe alternative:\ncov-loupe -fJ | rexe -ij -mb -oJ 'self[\"files\"].select { |f| f[\"percentage\"] &lt; 80 }'\n</code></pre>"},{"location":"dev/presentations/cov-loupe-presentation/#demo-2-cli-tool-contd","title":"Demo 2: CLI Tool (cont'd.)","text":"<pre><code># Custom resultset location\ncov-loupe --resultset coverage-all/\n\n# Sort by highest coverage\ncov-loupe --sort-order d\n\n# Staleness checking (file newer than coverage?)\ncov-loupe --raise-on-stale true\n\n# Track new files missing from coverage\ncov-loupe --tracked-globs \"lib/**/tools/*.rb\"\n</code></pre>"},{"location":"dev/presentations/cov-loupe-presentation/#demo-3-ruby-library","title":"Demo 3: Ruby Library","text":""},{"location":"dev/presentations/cov-loupe-presentation/#programmatic-integration","title":"Programmatic Integration","text":"<pre><code>require 'cov_loupe'\n\nmodel = CovLoupe::CoverageModel.new\n\n# Get project overview\nfiles = model.list\nputs \"Lowest coverage: #{files.first['percentage']}%\"\n\n# Focus on specific concerns\nuncovered = model.uncovered_for(\"lib/wifi-wand/models/ubuntu_model.rb\")\nputs \"Uncovered hash's keys: #{uncovered.keys.inspect}\" \nputs \"Missing lines: #{uncovered['uncovered'].inspect}\"\n\n# Output:\n# Lowest coverage: 17.0%\n# Uncovered hash's keys: [\"file\", \"uncovered\", \"summary\"]\n# Missing lines: [13, 17, 21,...200, 203]\n</code></pre>"},{"location":"dev/presentations/cov-loupe-presentation/#custom-threshold-git-pre-commit-hook","title":"Custom Threshold Git Pre-Commit Hook","text":"<pre><code>require 'cov_loupe'\n\nfiles = CovLoupe::CoverageModel.new.list\ncritical, other = files.partition { |f| f['file'].include?('/lib/critical/') }\n\nfails = critical.select { |f| f['percentage'] &lt; 100.0 } + \n        other.select { |f| f['percentage'] &lt; 90.0 }\n\nif fails.any?\n  puts \"\u274c Coverage failures:\"\n  fails.each { |f| puts \"  #{f['file']}: #{f['percentage']}%\" }\n  exit 1\nelse\n  puts \"\u2705 All thresholds met!\"\nend\n</code></pre>"},{"location":"dev/presentations/cov-loupe-presentation/#architecture-overview","title":"Architecture Overview","text":"<pre><code>lib/cov_loupe\n\u251c\u2500\u2500 base_tool.rb\n\u251c\u2500\u2500 cli.rb\n\u251c\u2500\u2500 error_handler_factory.rb\n\u251c\u2500\u2500 error_handler.rb\n\u251c\u2500\u2500 errors.rb\n\u251c\u2500\u2500 mcp_server.rb\n\u251c\u2500\u2500 model.rb\n\u251c\u2500\u2500 path_relativizer.rb\n\u251c\u2500\u2500 staleness_checker.rb\n\u251c\u2500\u2500 version.rb\n\u251c\u2500\u2500 tools\n\u2502 \u251c\u2500\u2500 list_tool.rb\n\u2502 \u251c\u2500\u2500 coverage_detailed_tool.rb\n\u2502 \u251c\u2500\u2500 coverage_raw_tool.rb\n\u2502 \u251c\u2500\u2500 coverage_summary_tool.rb\n\u2502 \u251c\u2500\u2500 coverage_table_tool.rb\n\u2502 \u251c\u2500\u2500 coverage_totals_tool.rb\n\u2502 \u251c\u2500\u2500 validate_tool.rb\n\u2502 \u251c\u2500\u2500 help_tool.rb\n\u2502 \u251c\u2500\u2500 uncovered_lines_tool.rb\n\u2502 \u2514\u2500\u2500 version_tool.rb\n\u2514\u2500\u2500 util.rb\n</code></pre> <p>Clean separation: CLI \u2194 Model \u2194 MCP Tools</p>"},{"location":"dev/presentations/cov-loupe-presentation/#mcp-plumbing-the-mcp-gem","title":"MCP Plumbing - the MCP Gem","text":""},{"location":"dev/presentations/cov-loupe-presentation/#basetool-subclasses-the-mcp-gems-tool-class-and-defines-a-schema-see-base_toolrb","title":"BaseTool subclasses the <code>mcp</code> gem's Tool class and defines a schema (see base_tool.rb):","text":"<pre><code>class BaseTool &lt; ::MCP::Tool\n  # ...\nend\n</code></pre> <ul> <li>BaseTool source</li> <li>BaseTool subclass source</li> </ul> <p>The MCP tools available to the model subclass BaseTool and implement their respective tasks.</p>"},{"location":"dev/presentations/cov-loupe-presentation/#mcp_serverrb-creates-an-instance-of-the-mcp-gems-server-class-and-runs-it","title":"mcp_server.rb creates an instance of the mcp gem's Server class and runs it:","text":"<pre><code>server = ::MCP::Server.new(\n  name:    'cov-loupe',\n  version: CovLoupe::VERSION,\n  tools:   tools\n)\n::MCP::Server::Transports::StdioTransport.new(server).open\n</code></pre>"},{"location":"dev/presentations/cov-loupe-presentation/#questions","title":"Questions?","text":"<p>Demo requests: - Specific MCP tool usage? - CLI workflow examples? - Library integration patterns? - AI assistant setup?</p> <p>Contact: - GitHub issues for bugs/features - Ruby community discussions</p> <p>Thank you! \ud83d\ude4f</p> <p>Making test coverage accessible to humans and AI alike</p>"},{"location":"examples/mcp-inputs/","title":"MCP Input Examples","text":""},{"location":"examples/mcp-inputs/#mcp-json-inputs","title":"MCP JSON Inputs","text":"<p>Back to main README</p> <p>This directory contains example JSON-RPC requests that can be sent to the MCP server over stdio.</p> <p>Each file contains a single line of JSON (NDJSON-ready), so you can pipe it directly to the executable.</p> <p>Target Project: These inputs are designed to work with the demo project located at <code>docs/fixtures/demo_project</code>.</p>"},{"location":"examples/mcp-inputs/#running-the-examples","title":"Running the Examples","text":"<p>From the repository root:</p> <pre><code>exe/cov-loupe -m mcp &lt; examples/mcp-inputs/coverage_summary.json\nexe/cov-loupe -m mcp &lt; examples/mcp-inputs/uncovered_lines.json\n</code></pre> <p>If <code>cov-loupe</code> is installed globally and available on your <code>PATH</code>:</p> <pre><code>cov-loupe -m mcp &lt; examples/mcp-inputs/coverage_summary.json\n</code></pre>"},{"location":"examples/mcp-inputs/#formatting-tips-jq-and-rexe","title":"Formatting Tips (jq and rexe)","text":"<p>You can use tools like jq or rexe to format the JSON input and output, which is especially helpful for debugging.</p> <p>Pretty-print an input file:</p> <p>Using <code>jq</code>: <pre><code>jq . examples/mcp-inputs/coverage_summary.json\n</code></pre></p> <p>Using Ruby: <pre><code>ruby -r json -e '\n  puts JSON.pretty_generate(JSON.parse(File.read(\"examples/mcp-inputs/coverage_summary.json\")))\n'\n</code></pre></p> <p>Using <code>rexe</code>: <pre><code>rexe -f examples/mcp-inputs/coverage_summary.json -oJ\n</code></pre></p> <p>Pretty-print the MCP server's JSON response (NDJSON):</p> <p>Using <code>jq</code>: <pre><code>exe/cov-loupe -m mcp &lt; examples/mcp-inputs/coverage_summary.json | jq .\n</code></pre></p> <p>Using Ruby: <pre><code>exe/cov-loupe -m mcp &lt; examples/mcp-inputs/coverage_summary.json | ruby -r json -e '\n  puts JSON.pretty_generate(JSON.parse($stdin.read))\n'\n</code></pre></p> <p>Using <code>rexe</code>: <pre><code>exe/cov-loupe -m mcp &lt; examples/mcp-inputs/coverage_summary.json | rexe -ml -ij -oJ\n</code></pre></p>"},{"location":"examples/success_predicates/","title":"Success Predicate Examples","text":""},{"location":"examples/success_predicates/#coverage-validation-predicate-examples","title":"Coverage Validation Predicate Examples","text":"<p>Back to main README</p> <p>This directory contains example coverage validation predicates for use with the <code>validate</code> subcommand.</p> <p>\u26a0\ufe0f SECURITY WARNING</p> <p>Success predicates execute as arbitrary Ruby code with full system privileges. They have unrestricted access to: - File system operations (read, write, delete) - Network operations (HTTP requests, sockets) - System commands (via backticks, <code>system()</code>, <code>exec()</code>, etc.) - Environment variables and sensitive data</p> <p>Only use predicate files from trusted sources. Treat them like any other executable code in your project. - Never use predicates from untrusted or unknown sources - Review predicates before use, especially in CI/CD environments - Store predicates in version control with code review - Be cautious when copying examples from the internet</p>"},{"location":"examples/success_predicates/#usage","title":"Usage","text":"<p>File mode: <pre><code>cov-loupe validate examples/success_predicates/&lt;filename&gt;.rb\n</code></pre></p> <p>String mode: <pre><code>cov-loupe validate -i '-&gt;(model) { model.list[\"files\"].all? { |f| f[\"percentage\"] &gt;= 80 } }'\n</code></pre></p> <p>The predicate receives a <code>CoverageModel</code> instance and returns: - Truthy value \u2192 Exit code 0 (success) - Falsy value \u2192 Exit code 1 (failure) - Exception \u2192 Exit code 2 (error)</p>"},{"location":"examples/success_predicates/#available-examples","title":"Available Examples","text":""},{"location":"examples/success_predicates/#all_files_above_threshold_predicaterb","title":"<code>all_files_above_threshold_predicate.rb</code>","text":"<p>All files must have &gt;= 80% coverage.</p> <pre><code>cov-loupe validate examples/success_predicates/all_files_above_threshold_predicate.rb\n</code></pre>"},{"location":"examples/success_predicates/#project_coverage_minimum_predicaterb","title":"<code>project_coverage_minimum_predicate.rb</code>","text":"<p>Total project coverage must be &gt;= 85%.</p> <pre><code>cov-loupe validate examples/success_predicates/project_coverage_minimum_predicate.rb\n</code></pre>"},{"location":"examples/success_predicates/#directory_specific_thresholds_predicaterb","title":"<code>directory_specific_thresholds_predicate.rb</code>","text":"<p>Different thresholds for different directories: - <code>lib/api/</code> - 90% required - <code>lib/core/</code> - 85% required - <code>lib/legacy/</code> - 60% required</p> <pre><code>cov-loupe validate examples/success_predicates/directory_specific_thresholds_predicate.rb\n</code></pre>"},{"location":"examples/success_predicates/#creating-custom-predicates","title":"Creating Custom Predicates","text":"<p>A predicate must be a callable object (lambda, proc, or class with <code>#call</code> method):</p> <p>Lambda example: <pre><code>-&gt;(model) do\n  model.list['files'].all? { |f| f['percentage'] &gt;= 80 }\nend\n</code></pre></p> <p>Class method example: <pre><code>class MyPolicy\n  def self.call(model)\n    model.list['files'].all? { |f| f['percentage'] &gt;= @threshold }\n  end\nend\n\nMyPolicy  # The class itself\n</code></pre></p> <p>Instance method example: <pre><code>class MyPolicy\n  def initialize(threshold = 80)\n    @threshold = threshold\n  end\n\n  def call(model)\n    model.list['files'].all? { |f| f['percentage'] &gt;= @threshold }\n  end\nend\n\nMyPolicy\n</code></pre></p>"},{"location":"examples/success_predicates/#coveragemodel-api","title":"CoverageModel API","text":"<p>The <code>model</code> parameter provides:</p> <pre><code># Get all files\nfiles = model.list['files']\n# =&gt; [{ \"file\" =&gt; \"...\", \"covered\" =&gt; 12, \"total\" =&gt; 14, \"percentage\" =&gt; 85.71, \"stale\" =&gt; false }, ...]\n\n# Filter by globs\napi_files = model.list(tracked_globs: ['lib/api/**/*.rb'])['files']\n\n# Get specific file data\nsummary = model.summary_for('lib/model.rb')\nuncovered = model.uncovered_for('lib/model.rb')\n</code></pre> <p>See docs/user/LIBRARY_API.md for the complete API.</p>"},{"location":"examples/success_predicates/#when-to-use-standalone-scripts-instead","title":"When to Use Standalone Scripts Instead","text":"<p>For more complex scenarios, you may prefer writing a standalone Ruby script that uses the <code>cov-loupe</code> library directly instead of using the <code>validate</code> subcommand.</p> <p>Use a standalone script when: - External dependencies needed - Your policy requires other gems or libraries - Complex setup required - You need custom logging, database connections, or API calls - Easier testing desired - Standalone scripts can be tested like any Ruby code - More explicit control - You want full control over model initialization and error handling - Sophisticated logic - Multi-step analysis, data aggregation, or integration with other tools</p> <p>Predicate approach is better when: - Policy is simple and self-contained (most common use case) - You want the tool to handle option parsing (--resultset, --raise-on-stale, etc.) - Consistent error handling and exit codes are desired - Less boilerplate is preferred</p> <p>Example standalone script: <pre><code>#!/usr/bin/env ruby\nrequire 'cov_loupe'\nrequire 'httparty'  # External gem\n\n# Custom initialization\nmodel = CovLoupe::CoverageModel.new(\n  resultset: ENV['COVERAGE_PATH'],\n  raise_on_stale: true\n)\n\n# Complex logic with external API\nfiles = model.list['files']\nlow_coverage_files = files.select { |f| f['percentage'] &lt; 80 }\n\n# Post to Slack\nif low_coverage_files.any?\n  HTTParty.post(\n    ENV['SLACK_WEBHOOK_URL'],\n    body: { text: \"#{low_coverage_files.size} files below 80%\" }.to_json\n  )\n  exit 1\nelse\n  exit 0\nend\n</code></pre></p> <p>Both approaches execute arbitrary code with full system privileges, so the security considerations are identical. Choose the approach that best fits your use case.</p>"},{"location":"examples/success_predicates/#cicd-integration","title":"CI/CD Integration","text":"<p>GitHub Actions: <pre><code>- name: Enforce Coverage Policy\n  run: bundle exec cov-loupe validate coverage_policy.rb\n</code></pre></p> <p>GitLab CI: <pre><code>coverage:enforce:\n  script:\n    - bundle exec cov-loupe validate coverage_policy.rb\n</code></pre></p> <p>Jenkins: <pre><code>stage('Coverage Policy') {\n    steps {\n        sh 'bundle exec cov-loupe validate coverage_policy.rb'\n    }\n}\n</code></pre></p>"},{"location":"examples/success_predicates/#exit-codes","title":"Exit Codes","text":"<ul> <li>0 - Predicate returned truthy (success)</li> <li>1 - Predicate returned falsy (failure)</li> <li>2 - Predicate raised an error</li> </ul> <p>Use exit code 1 to fail CI/CD builds when coverage doesn't meet policy.</p>"},{"location":"user/","title":"User Documentation","text":"<p>Back to main README</p> <p>Guides for installing, configuring, and using cov-loupe in day-to-day workflows.</p> <ul> <li>Installation \u2013 environment setup across platforms</li> <li>CLI Usage \u2013 command reference with examples</li> <li>Examples \u2013 common coverage workflows</li> <li>Advanced Usage \u2013 resultset paths, staleness, predicates</li> <li>Error Handling \u2013 modes, exceptions, logging</li> <li>MCP Integration \u2013 configuring AI assistants</li> <li>CLI Fallback for LLMs \u2013 when MCP isn't available</li> <li>Library API \u2013 embedding the gem in Ruby code</li> <li>Troubleshooting \u2013 diagnostics for common issues</li> <li>Migration Guides \u2013 breaking change notes for v2 through v4</li> <li>Prompt Library \u2013 copy/paste instructions for MCP clients when you need coverage analyses fast</li> </ul>"},{"location":"user/ADVANCED_USAGE/","title":"Advanced Usage Guide","text":"<p>Back to main README</p> <p>Examples use <code>clp</code>, an alias pointed at the demo fixture with partial coverage:</p> <p><code>alias clp='cov-loupe -R docs/fixtures/demo_project'</code>  # -R = --root</p> <p>Replace <code>clp</code> with <code>cov-loupe</code> if you want to target your own project/resultset.</p>"},{"location":"user/ADVANCED_USAGE/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Advanced MCP Integration</li> <li>Staleness Detection &amp; Validation</li> <li>Advanced Path Resolution</li> <li>Error Handling Strategies</li> <li>Custom Ruby Integration</li> <li>CI/CD Integration</li> <li>Advanced Filtering &amp; Glob Patterns</li> <li>Performance Optimization</li> <li>Custom Output Processing</li> <li>Multi-Suite Coverage Merging</li> </ul>"},{"location":"user/ADVANCED_USAGE/#advanced-mcp-integration","title":"Advanced MCP Integration","text":""},{"location":"user/ADVANCED_USAGE/#mcp-error-handling","title":"MCP Error Handling","text":"<p>The MCP server uses structured error responses:</p> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"error\": {\n    \"code\": -32603,\n    \"message\": \"Coverage data not found at coverage/.resultset.json\",\n    \"data\": {\n      \"type\": \"FileError\",\n      \"context\": \"MCP tool execution\"\n    }\n  },\n  \"id\": 1\n}\n</code></pre>"},{"location":"user/ADVANCED_USAGE/#mcp-server-logging","title":"MCP Server Logging","text":"<p>The MCP server logs to <code>cov_loupe.log</code> in the current directory by default.</p> <p>To override the default log file location, specify the <code>--log-file</code> (or <code>-l</code>) argument wherever and however you configure your MCP server. For example, to log to a different file path, include <code>-l /path/to/logfile.log</code> in your server configuration. To log to standard error, use <code>-l stderr</code>.</p> <p>Warning: Log files may grow unbounded in long-running or CI usage. Consider using a log rotation tool or periodically cleaning up the log file if this is a concern.</p> <p>Note: Logging to <code>stdout</code> is not permitted in MCP mode since it would interfere with the request processing.</p>"},{"location":"user/ADVANCED_USAGE/#testing-mcp-server-manually","title":"Testing MCP Server Manually","text":"<p>Use JSON-RPC over stdin to test the MCP server. Note: CLI flags set defaults for MCP tool calls, but per-request JSON parameters still win. Use <code>-R</code>/<code>-r</code> when you want server-wide defaults, or pass <code>root</code>/<code>resultset</code> per request.</p> <pre><code># Get version (no parameters needed)\necho '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"version_tool\",\"arguments\":{}}}' | cov-loupe -m mcp\n\n# Get file summary (include root parameter in JSON)\necho '{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"coverage_summary_tool\",\"arguments\":{\"path\":\"app/models/order.rb\",\"root\":\"docs/fixtures/demo_project\"}}}' | cov-loupe -m mcp\n\n# List all files with sorting (include root parameter)\necho '{\"jsonrpc\":\"2.0\",\"id\":3,\"method\":\"tools/call\",\"params\":{\"name\":\"list_tool\",\"arguments\":{\"sort_order\":\"ascending\",\"root\":\"docs/fixtures/demo_project\"}}}' | cov-loupe -m mcp\n\n# Get uncovered lines (include root parameter)\necho '{\"jsonrpc\":\"2.0\",\"id\":4,\"method\":\"tools/call\",\"params\":{\"name\":\"uncovered_lines_tool\",\"arguments\":{\"path\":\"app/controllers/orders_controller.rb\",\"root\":\"docs/fixtures/demo_project\"}}}' | cov-loupe -m mcp\n</code></pre> <p>Why not use <code>clp</code> alias here? <code>clp</code> is useful for CLI subcommands, but MCP calls run a long-lived server process. You can pass <code>-R</code> at startup to set defaults, or set <code>root</code> explicitly in each JSON request when you want to be explicit or override the defaults.</p>"},{"location":"user/ADVANCED_USAGE/#sorting-coverage-lists-with-na-entries","title":"Sorting Coverage Lists with n/a Entries","text":"<p>When a file has no executable lines, its coverage percentage is reported as <code>n/a</code>. In list outputs, <code>n/a</code> entries are grouped separately from numeric percentages. The default descending sort order places <code>n/a</code> entries above <code>100%</code> coverage so they appear earlier in the list, while still keeping low numeric percentages toward the bottom for attention.</p> <p>If you need to treat <code>n/a</code> differently, post-process the JSON output from <code>list</code> or <code>list_tool</code> and apply your own sort or filtering rules.</p>"},{"location":"user/ADVANCED_USAGE/#staleness-detection-validation","title":"Staleness Detection &amp; Validation","text":""},{"location":"user/ADVANCED_USAGE/#understanding-staleness-checks","title":"Understanding Staleness Checks","text":"<p>Staleness checking prevents using outdated coverage data. The behavior is controlled by the boolean <code>raise_on_stale</code> setting:</p> <p><code>raise_on_stale: false</code> (default) - Coverage data is returned even if stale - Stale indicators are still computed - Best for exploratory reporting</p> <p><code>raise_on_stale: true</code> - Raises errors when stale coverage is detected - Recommended for CI/CD enforcement</p>"},{"location":"user/ADVANCED_USAGE/#file-level-staleness","title":"File-Level Staleness","text":"<p>A file is considered stale when any of the following are true: 1. Source file modified after coverage generation (requires timestamps - see Timestamp Warnings) 2. Line count differs from coverage array length 3. File exists in coverage but deleted from filesystem</p> <p>CLI Usage: <pre><code># Fail if the file is stale\nclp -S true summary app/models/order.rb  # -S = --raise-on-stale\n</code></pre></p> <p>Ruby API: <pre><code>model = CovLoupe::CoverageModel.new(\n  raise_on_stale: true\n)\n\nbegin\n  summary = model.summary_for('app/models/order.rb')\nrescue CovLoupe::CoverageDataStaleError =&gt; e\n  puts \"File modified after coverage: #{e.file_path}\"\n  puts \"Coverage timestamp: #{e.cov_timestamp}\"\n  puts \"File mtime: #{e.file_mtime}\"\n  puts \"Source lines: #{e.src_len}, Coverage lines: #{e.cov_len}\"\nend\n</code></pre></p>"},{"location":"user/ADVANCED_USAGE/#project-level-staleness","title":"Project-Level Staleness","text":"<p>Detects system-wide staleness issues:</p> <p>Conditions Checked: 1. Newer files - Any tracked file modified after coverage (requires timestamps - see Timestamp Warnings) 2. Missing files - Tracked files with no coverage data 3. Deleted files - Coverage exists for non-existent files</p> <p>CLI Usage:</p> <p>You can see if any files in the project are stale by running the (implicit here) <code>list</code> command with <code>--raise-on-stale</code> and checking the exit code:</p> <pre><code>$ cov-loupe -S true list\nCoverage data stale (project): CovLoupe::CoverageDataProjectStaleError\nCoverage  - time: 2025-12-10T18:23:00Z (local 2025-12-11T02:23:00+08:00)\nNewer files (1):  - lib/cov_loupe/version.rb\nResultset - /path/to/project/coverage/.resultset.json\n$ echo $?\n1\n</code></pre> <p>Ruby API: <pre><code>model = CovLoupe::CoverageModel.new(raise_on_stale: true)\n\nbegin\n  model.list(raise_on_stale: true)\nrescue CovLoupe::CoverageDataProjectStaleError =&gt; e\n  puts \"Newer files: #{e.newer_files.join(', ')}\"\n  puts \"Missing from coverage: #{e.missing_files.join(', ')}\"\n  puts \"Deleted but in coverage: #{e.deleted_files.join(', ')}\"\nend\n</code></pre></p>"},{"location":"user/ADVANCED_USAGE/#timestamp-warnings","title":"Timestamp Warnings","text":"<p>When coverage data lacks timestamps (e.g., manually created resultsets or older SimpleCov versions), cov-loupe displays a warning in both CLI and MCP modes:</p> <pre><code>WARNING: Coverage timestamps are missing. Time-based staleness checks were skipped.\nFiles may appear \"ok\" even if source code is newer than the coverage data.\nCheck your coverage tool configuration to ensure timestamps are recorded.\n</code></pre> <p>What this means: - Time-based staleness checks (the <code>\"newer\"</code> indicator) cannot run without timestamps - Files modified after coverage collection won't be flagged as stale - Only line count mismatches and missing files will be detected - The <code>timestamp_status</code> field in JSON output will show <code>\"missing\"</code> instead of <code>\"ok\"</code></p> <p>Where it appears: - CLI table format: After the coverage table in <code>list</code> output - CLI JSON format: After JSON output, and in the <code>timestamp_status</code> field - MCP mode: In <code>coverage_table_tool</code> output after the exclusions summary - MCP JSON: In the <code>timestamp_status</code> field of <code>list_tool</code> responses</p> <p>How to fix:</p> <p>Modern SimpleCov versions automatically include timestamps in <code>.resultset.json</code>. If you see this warning:</p> <ol> <li>Ensure SimpleCov is up to date (<code>gem update simplecov</code>)</li> <li>Regenerate coverage data (<code>bundle exec rspec</code>)</li> <li>If using custom resultset generation, ensure timestamps are included</li> </ol> <p>Example timestamp in <code>.resultset.json</code>: <pre><code>{\n  \"RSpec\": {\n    \"coverage\": { ... },\n    \"timestamp\": 1704067200\n  }\n}\n</code></pre></p>"},{"location":"user/ADVANCED_USAGE/#advanced-path-resolution","title":"Advanced Path Resolution","text":""},{"location":"user/ADVANCED_USAGE/#path-matching-strategy","title":"Path Matching Strategy","text":"<p>Path resolution uses two strategies in order:</p> <ol> <li>Exact absolute path match - Direct lookup using the full path</li> <li>Relative path resolution - Strips project root and retries with relative path</li> </ol> <pre><code>model = CovLoupe::CoverageModel.new(root: '/path/to/project')\n\nmodel.summary_for('/path/to/project/app/models/order.rb')  # Absolute\nmodel.summary_for('app/models/order.rb')                   # Relative\n</code></pre>"},{"location":"user/ADVANCED_USAGE/#working-with-multiple-projects","title":"Working with Multiple Projects","text":"<pre><code># Project A\nmodel_a = CovLoupe::CoverageModel.new(\n  root: '/path/to/projects/service-a',\n  resultset: '/path/to/projects/service-a/coverage/.resultset.json'\n)\n\n# Project B\nmodel_b = CovLoupe::CoverageModel.new(\n  root: '/path/to/projects/service-b',\n  resultset: '/path/to/projects/service-b/tmp/coverage/.resultset.json'\n)\n\n# Compare coverage\ncoverage_a = model_a.list\ncoverage_b = model_b.list\n</code></pre>"},{"location":"user/ADVANCED_USAGE/#error-handling-strategies","title":"Error Handling Strategies","text":""},{"location":"user/ADVANCED_USAGE/#context-aware-error-handling","title":"Context-Aware Error Handling","text":"<p>CLI Mode: user-facing messages, exit codes, optional debug mode</p> <p>Library Mode: typed exceptions with full details</p> <p>MCP Server Mode: JSON-RPC errors logged to file with structured data</p>"},{"location":"user/ADVANCED_USAGE/#error-modes","title":"Error Modes","text":"<p>CLI Error Modes: <pre><code># Silent mode - minimal output\nclp --error-mode off summary app/models/order.rb\n\n# Standard mode - user-friendly errors (default)\nclp --error-mode log summary app/models/order.rb\n\n# Verbose mode - full stack traces\nclp --error-mode debug summary app/models/order.rb\n</code></pre></p> <p>Ruby API Error Handling: <pre><code>require 'cov_loupe'\n\nbegin\n  model = CovLoupe::CoverageModel.new(\n    root: '/path/to/project',\n    resultset: '/nonexistent/.resultset.json'\n  )\nrescue CovLoupe::FileError =&gt; e\n  # Handle missing resultset\n  puts \"Coverage file not found: #{e.message}\"\nrescue CovLoupe::CoverageDataError =&gt; e\n  # Handle corrupt/invalid coverage data\n  puts \"Invalid coverage data: #{e.message}\"\nend\n</code></pre></p>"},{"location":"user/ADVANCED_USAGE/#custom-error-handlers","title":"Custom Error Handlers","text":"<p>Provide custom error handlers when embedding the CLI:</p> <pre><code>class CustomErrorHandler\n  def handle_error(error, context: nil)\n    # Log to custom service\n    ErrorTracker.notify(error, context: context)\n\n    # Re-raise or handle gracefully\n    raise error\n  end\nend\n\ncli = CovLoupe::CoverageCLI.new(error_handler: CustomErrorHandler.new)\n</code></pre>"},{"location":"user/ADVANCED_USAGE/#custom-ruby-integration","title":"Custom Ruby Integration","text":""},{"location":"user/ADVANCED_USAGE/#building-custom-coverage-policies","title":"Building Custom Coverage Policies","text":"<p>Use the <code>validate</code> subcommand to enforce custom coverage policies in CI/CD. Example predicates are in <code>examples/success_predicates/</code>.</p> <p>The predicate can be any Ruby object that responds to <code>call</code> and accepts a <code>CoverageModel</code> as its argument. This is usually a lambda (proc), but it can also be a nonlambda proc, a class, or an instance with a <code>call</code> method. The predicate should return a truthy value for success  or <code>false</code>/<code>nil</code> for failure.</p> <p>\u26a0\ufe0f SECURITY WARNING</p> <p>Success predicates execute as arbitrary Ruby code with full system privileges. They have unrestricted access to: - File system operations (read, write, delete) - Network operations (HTTP requests, sockets) - System commands (via backticks, <code>system()</code>, <code>exec()</code>, etc.) - Environment variables and sensitive data</p> <p>Only use predicate files from trusted sources. Treat them like any other executable code in your project. - Never use predicates from untrusted or unknown sources - Review predicates before use, especially in CI/CD environments - Store predicates in version control with code review - Be cautious when copying examples from the internet</p> <p>Quick Usage: <pre><code># All files must be &gt;= 80%\nclp validate examples/success_predicates/list_above_threshold_predicate.rb\n\n# Total project coverage &gt;= 85%\nclp validate examples/success_predicates/project_coverage_minimum_predicate.rb\n\n# Custom predicate from file\nclp validate coverage_policy.rb\n\n# Inline string mode\nclp validate -i '-&gt;(m) { m.list[\"files\"].all? { |f| f[\"percentage\"] &gt;= 80 } }'\n</code></pre></p> <p>Creating a predicate: <pre><code># coverage_policy.rb\n-&gt;(model) do\n  # All files must have &gt;= 80% coverage\n  model.list['files'].all? { |f| f['percentage'] &gt;= 80 }\nend\n</code></pre></p> <p>Advanced predicate with reporting:</p> <pre><code># coverage_policy.rb\nclass CoveragePolicy\n  def call(model)\n    threshold = 80\n    low_files = model.list['files'].select { |f| f['percentage'] &lt; threshold }\n\n    if low_files.empty?\n      puts \"\u2713 All files have &gt;= #{threshold}% coverage\"\n      true\n    else\n      warn \"\u2717 Files below #{threshold}%:\"\n      low_files.each { |f| warn \"  #{f['file']}: #{f['percentage']}%\" }\n      false\n    end\n  end\nend\n\nCoveragePolicy.new\n</code></pre> <p>Exit codes: - <code>0</code> - Predicate returned truthy (pass) - <code>1</code> - Predicate returned falsy (fail) - <code>2</code> - Predicate raised an error</p> <p>See examples/success_predicates/README.md for more examples.</p>"},{"location":"user/ADVANCED_USAGE/#path-relativization","title":"Path Relativization","text":"<p>Convert absolute paths to relative for cleaner output:</p> <pre><code>model = CovLoupe::CoverageModel.new(root: '/path/to/project')\n\n# Get data with absolute paths\ndata = model.summary_for('app/models/order.rb')\n# =&gt; { 'file' =&gt; '/path/to/project/app/models/order.rb', ... }\n\n# Relativize paths\nrelative_data = model.relativize(data)\n# =&gt; { 'file' =&gt; 'app/models/order.rb', ... }\n\n# Works with list payloads too\nlist_result = model.list\nrelative_list = model.relativize(list_result)\nrelative_files = relative_list['files']\n</code></pre>"},{"location":"user/ADVANCED_USAGE/#cicd-integration","title":"CI/CD Integration","text":"<p>The CLI is designed for CI/CD use with features that integrate naturally into pipeline workflows:</p>"},{"location":"user/ADVANCED_USAGE/#key-integration-features","title":"Key Integration Features","text":"<ul> <li>Exit codes: Non-zero on failure, making it suitable for pipeline failure conditions</li> <li>JSON output: <code>-fJ</code> format for parsing by CI tools and custom processing</li> <li>Staleness checking: <code>--raise-on-stale true</code> to fail on outdated coverage data</li> <li>Success predicates: Custom Ruby policies for coverage enforcement</li> </ul>"},{"location":"user/ADVANCED_USAGE/#basic-ci-pattern","title":"Basic CI Pattern","text":"<pre><code># 1. Run tests to generate coverage\nbundle exec rspec\n\n# 2. Validate coverage freshness (fails with exit code 1 if stale)\nclp -S true -g \"lib/**/*.rb\"\n\n# 3. Export data for CI artifacts or further processing\nclp -fJ list &gt; coverage.json\n</code></pre>"},{"location":"user/ADVANCED_USAGE/#using-coverage-validation","title":"Using Coverage Validation","text":"<p>Enforce custom coverage policies with the <code>validate</code> subcommand:</p> <pre><code># Run tests\nbundle exec rspec\n\n# Apply coverage policy (fails with exit code 1 if predicate returns false)\nclp validate coverage_policy.rb\n</code></pre> <p>Exit codes: - <code>0</code> - Success (coverage meets requirements) - <code>1</code> - Failure (coverage policy not met or stale data detected) - <code>2</code> - Error (invalid predicate or system error)</p>"},{"location":"user/ADVANCED_USAGE/#platform-specific-examples","title":"Platform-Specific Examples","text":"<p>For platform-specific integration examples (GitHub Actions, GitLab CI, Jenkins, CircleCI, etc.), see community contributions in the GitHub Discussions.</p>"},{"location":"user/ADVANCED_USAGE/#advanced-filtering-glob-patterns","title":"Advanced Filtering &amp; Glob Patterns","text":""},{"location":"user/ADVANCED_USAGE/#tracked-globs-overview","title":"Tracked Globs Overview","text":"<p>Default behavior: By default, <code>--tracked-globs</code> is empty (<code>[]</code>), which means all files in the coverage resultset are shown. This ensures transparency\u2014you see exactly what SimpleCov measured without any filtering.</p> <p>Why opt-in filtering? - Coverage results are not hidden - Results are not excluded because their filespecs did not match default tracked globs - Meaningful validation - <code>missing_tracked_files</code> only flags files you explicitly expect to have coverage - Project flexibility - Different projects use different directory structures</p> <p>Important: Files lacking any coverage at all (not loaded during tests) will not appear in the resultset and therefore won't be visible with the default empty array. To detect such files, you must set <code>--tracked-globs</code> to match the files you expect to have coverage.</p> <p>Two purposes of tracked globs: 1. Exclude unwanted results - Only show files from the resultset that match the patterns 2. Include files with or without coverage - Report files that match the patterns but aren't in the resultset (reported in <code>missing_tracked_files</code> for <code>list</code>, <code>missing_from_coverage</code> for <code>totals</code>)</p> <p>Best practice: Set <code>COV_LOUPE_OPTS</code> to match your SimpleCov <code>track_files</code> configuration:</p> <pre><code># spec_helper.rb\nSimpleCov.start do\n  add_filter '/spec/'\n  track_files 'lib/**/*.rb'\n  track_files 'app/**/*.rb'\nend\n</code></pre> <pre><code># Shell config (.bashrc, .zshrc, etc.)\nexport COV_LOUPE_OPTS=\"--tracked-globs lib/**/*.rb,app/**/*.rb\"\n</code></pre> <p>This alignment ensures: - <code>list</code> and <code>totals</code> output matches SimpleCov's scope - <code>missing_tracked_files</code> (in <code>list</code>) reports files that SimpleCov should track but hasn't measured - No surprises from default patterns that don't match your project</p>"},{"location":"user/ADVANCED_USAGE/#pattern-syntax","title":"Pattern Syntax","text":"<p>Uses Ruby's <code>File.fnmatch</code> with extended glob support:</p> <pre><code># Single directory, recursive\n-g \"lib/**/*.rb\"\n\n# Multiple patterns\n-g \"lib/payments/**/*.rb\" -g \"lib/ops/jobs/**/*.rb\"\n\n# Exclude patterns (use CLI filtering to exclude ops jobs)\nclp -fJ list | jq '.files[] | select(.file | test(\"ops\") | not)'\n\n# Ruby alternative:\nclp -fJ list | ruby -r json -e '\n  JSON.parse($stdin.read)[\"files\"].reject { |f| f[\"file\"].include?(\"ops\") }.each do |f|\n    puts JSON.pretty_generate(f)\n  end\n'\n\n# Rexe alternative:\nclp -fJ list | rexe -ij -mb -oJ 'self[\"files\"].reject { |f| f[\"file\"].include?(\"ops\") }'\n\n# Complex patterns\n-g \"lib/{models,controllers}/**/*.rb\"\n-g \"app/**/concerns/*.rb\"\n</code></pre>"},{"location":"user/ADVANCED_USAGE/#use-cases","title":"Use Cases","text":"<p>1. Monitor Subsystem Coverage: <pre><code># API layer only\nclp -g \"lib/api/**/*.rb\" list\n\n# Core business logic\nclp -g \"lib/domain/**/*.rb\" list\n</code></pre></p> <p>2. Ensure New Files Have Coverage: <pre><code># Fail if any tracked file lacks coverage\nclp -S true -g \"lib/features/**/*.rb\"\n</code></pre></p> <p>3. Multi-tier Reporting: <pre><code># Generate separate reports per layer\nfor layer in models views controllers; do\n  clp -g \"app/${layer}/**/*.rb\" -fJ list &gt; \"coverage-${layer}.json\"\ndone\n</code></pre></p>"},{"location":"user/ADVANCED_USAGE/#ruby-api-with-globs","title":"Ruby API with Globs","text":"<pre><code>model = CovLoupe::CoverageModel.new\n\n# Filter files in output\napi_files = model.list(\n  tracked_globs: ['lib/api/**/*.rb']\n)['files']\n\n# Multi-pattern filtering\ncore_files = model.list(\n  tracked_globs: [\n    'lib/core/**/*.rb',\n    'lib/domain/**/*.rb'\n  ]\n)['files']\n\n# Validate specific subsystems\nbegin\n  model.list(\n    raise_on_stale: true,\n    tracked_globs: ['lib/critical/**/*.rb']\n  )\nrescue CovLoupe::CoverageDataProjectStaleError =&gt; e\n  # Handle missing coverage for critical files\n  puts \"Critical files missing coverage:\"\n  e.missing_files.each { |f| puts \"  - #{f}\" }\nend\n</code></pre>"},{"location":"user/ADVANCED_USAGE/#performance-optimization","title":"Performance Optimization","text":""},{"location":"user/ADVANCED_USAGE/#minimizing-coverage-reads","title":"Minimizing Coverage Reads","text":"<p>The <code>CoverageModel</code> reads <code>.resultset.json</code> once at initialization:</p> <pre><code># Good: Single model for multiple queries\nmodel = CovLoupe::CoverageModel.new\nfiles = model.list['files']\nfile1 = model.summary_for('lib/a.rb')\nfile2 = model.summary_for('lib/b.rb')\n\n# Bad: Re-reads coverage for each operation\nmodel1 = CovLoupe::CoverageModel.new\nfiles = model1.list['files']\n\nmodel2 = CovLoupe::CoverageModel.new\nfile1 = model2.summary_for('lib/a.rb')\n</code></pre>"},{"location":"user/ADVANCED_USAGE/#batch-processing","title":"Batch Processing","text":"<pre><code># Process multiple files in one pass\nfiles_to_analyze = ['lib/a.rb', 'lib/b.rb', 'lib/c.rb']\nmodel = CovLoupe::CoverageModel.new\n\nresults = files_to_analyze.each_with_object({}) do |file, hash|\n  hash[file] = {\n    summary: model.summary_for(file),\n    uncovered: model.uncovered_for(file)\n  }\nrescue CovLoupe::FileError\n  hash[file] = { error: 'No coverage' }\nend\n</code></pre>"},{"location":"user/ADVANCED_USAGE/#filtering-early","title":"Filtering Early","text":"<p>Use <code>tracked_globs</code> to reduce data processing:</p> <pre><code># Bad: Filter after loading all data\nlist = model.list['files']\napi_files = list.select { |f| f['file'].include?('api') }\n\n# Good: Filter during query\napi_files = model.list(\n  tracked_globs: ['lib/api/**/*.rb']\n)['files']\n</code></pre>"},{"location":"user/ADVANCED_USAGE/#caching-coverage-models","title":"Caching Coverage Models","text":"<p>For long-running processes:</p> <pre><code>class CoverageCache\n  def initialize(ttl: 300) # 5 minute cache\n    @cache = {}\n    @ttl = ttl\n  end\n\n  def model_for(root)\n    key = root.to_s\n    now = Time.now\n\n    if @cache[key] &amp;&amp; (now - @cache[key][:time] &lt; @ttl)\n      @cache[key][:model]\n    else\n      @cache[key] = {\n        model: CovLoupe::CoverageModel.new(root: root),\n        time: now\n      }\n      @cache[key][:model]\n    end\n  end\nend\n\ncache = CoverageCache.new\nmodel = cache.model_for('/path/to/project')\n</code></pre>"},{"location":"user/ADVANCED_USAGE/#custom-output-processing","title":"Custom Output Processing","text":""},{"location":"user/ADVANCED_USAGE/#format-conversion","title":"Format Conversion","text":"<p>CSV Export: <pre><code>require 'csv'\n\nmodel = CovLoupe::CoverageModel.new\nfiles = model.list['files']\n\nCSV.open('coverage.csv', 'w') do |csv|\n  csv &lt;&lt; ['File', 'Coverage %', 'Lines Covered', 'Total Lines', 'Stale']\n  files.each do |f|\n    csv &lt;&lt; [\n      model.relativize(f)['file'],\n      f['percentage'],\n      f['covered'],\n      f['total'],\n      f['stale']\n    ]\n  end\nend\n</code></pre></p> <p>HTML Report: <pre><code>require 'erb'\n\ntemplate = ERB.new(&lt;&lt;~HTML)\n  &lt;html&gt;\n    &lt;head&gt;&lt;title&gt;Coverage Report&lt;/title&gt;&lt;/head&gt;\n    &lt;body&gt;\n      &lt;h1&gt;Coverage Report&lt;/h1&gt;\n      &lt;table&gt;\n        &lt;tr&gt;\n          &lt;th&gt;File&lt;/th&gt;&lt;th&gt;Coverage&lt;/th&gt;&lt;th&gt;Covered&lt;/th&gt;&lt;th&gt;Total&lt;/th&gt;\n        &lt;/tr&gt;\n        &lt;% files.each do |f| %&gt;\n          &lt;tr class=\"&lt;%= f['percentage'] &lt; 80 ? 'low' : 'ok' %&gt;\"&gt;\n            &lt;td&gt;&lt;%= f['file'] %&gt;&lt;/td&gt;\n            &lt;td&gt;&lt;%= f['percentage'].round(2) %&gt;%&lt;/td&gt;\n            &lt;td&gt;&lt;%= f['covered'] %&gt;&lt;/td&gt;\n            &lt;td&gt;&lt;%= f['total'] %&gt;&lt;/td&gt;\n          &lt;/tr&gt;\n        &lt;% end %&gt;\n      &lt;/table&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;\nHTML\n\nmodel = CovLoupe::CoverageModel.new\nlist_result = model.list\nrelative_list = model.relativize(list_result)\nfiles = relative_list['files']\nFile.write('coverage.html', template.result(binding))\n</code></pre></p>"},{"location":"user/ADVANCED_USAGE/#annotated-source-output","title":"Annotated Source Output","text":"<p>The CLI supports annotated source viewing:</p> <pre><code># Show uncovered lines with context\nclp uncovered app/models/order.rb \\\n  -s uncovered \\\n  -c 3  # -s = --source, -c = --context-lines\n\n# Show full file with coverage annotations\nclp uncovered app/models/order.rb \\\n  -s full \\\n  -c 0\n</code></pre> <p>Programmatic Source Annotation: <pre><code>def annotate_source(file_path)\n  model = CovLoupe::CoverageModel.new\n  details = model.detailed_for(file_path)\n  source_lines = File.readlines(file_path)\n\n  output = []\n  details['lines'].each do |line_data|\n    line_num = line_data['line']\n    hits = line_data['hits']\n    source = source_lines[line_num - 1]\n\n    marker = case hits\n             when nil then '     '\n             when 0   then '  \u2717  '\n             else          \"  #{hits}  \"\n             end\n\n    output &lt;&lt; \"#{marker}#{line_num.to_s.rjust(4)}: #{source}\"\n  end\n\n  output.join\nend\n\nputs annotate_source('app/models/order.rb')\n</code></pre></p>"},{"location":"user/ADVANCED_USAGE/#integration-with-coverage-trackers","title":"Integration with Coverage Trackers","text":"<p>Send to Codecov: <pre><code>#!/bin/bash\nbundle exec rspec\nclp -fJ list &gt; coverage.json\n\n# Transform to Codecov format (example)\njq '{\n  coverage: [\n    .files[] | {\n      name: .file,\n      coverage: .percentage\n    }\n  ]\n}' coverage.json | curl -X POST \\\n  -H \"Authorization: token $CODECOV_TOKEN\" \\\n  -d @- https://codecov.io/upload\n\n# Ruby alternative:\nruby -r json -e '\n  data = JSON.parse(File.read(\"coverage.json\"))\n  transformed = {\n    coverage: data[\"files\"].map { |f|\n      {name: f[\"file\"], coverage: f[\"percentage\"]}\n    }\n  }\n  puts JSON.pretty_generate(transformed)\n' | curl -X POST \\\n  -H \"Authorization: token $CODECOV_TOKEN\" \\\n  -d @- https://codecov.io/upload\n\n# Rexe alternative:\nrexe -f coverage.json -oJ '\n  {\n    coverage: self[\"files\"].map { |f|\n      {name: f[\"file\"], coverage: f[\"percentage\"]}\n    }\n  }\n' | curl -X POST \\\n  -H \"Authorization: token $CODECOV_TOKEN\" \\\n  -d @- https://codecov.io/upload\n</code></pre></p> <p>Send to Coveralls: <pre><code>require 'cov_loupe'\nrequire 'net/http'\nrequire 'json'\n\nmodel = CovLoupe::CoverageModel.new\nfiles = model.list['files']\n\ncoveralls_data = {\n  repo_token: ENV['COVERALLS_REPO_TOKEN'],\n  source_files: files.map { |f|\n    {\n      name: f['file'],\n      coverage: model.raw_for(f['file'])['lines']\n    }\n  }\n}\n\nuri = URI('https://coveralls.io/api/v1/jobs')\nNet::HTTP.post(uri, coveralls_data.to_json, {\n  'Content-Type' =&gt; 'application/json'\n})\n</code></pre></p>"},{"location":"user/ADVANCED_USAGE/#multi-suite-coverage-merging","title":"Multi-Suite Coverage Merging","text":""},{"location":"user/ADVANCED_USAGE/#how-it-works","title":"How It Works","text":"<p>When a <code>.resultset.json</code> file contains multiple test suites (e.g., RSpec + Cucumber), <code>cov-loupe</code> automatically merges them using SimpleCov's combine logic. All covered files from every suite become available to the CLI, library, and MCP tools.</p> <p>Performance: Single-suite projects avoid loading SimpleCov at runtime. Multi-suite resultsets trigger a lazy SimpleCov load only when needed, keeping the tool fast for the simpler coverage configurations.</p>"},{"location":"user/ADVANCED_USAGE/#current-limitations","title":"Current Limitations","text":"<p>Staleness checks: When suites are merged, we keep a single \"latest suite\" timestamp. This matches prior behavior but may under-report stale files if only some suites were re-run after a change. Use <code>--raise-on-stale</code> (or <code>-S</code>) on the CLI, <code>raise_on_stale: true</code> via the Ruby API, or the MCP tool parameter to turn these warnings into hard failures. A per-file timestamp refinement is planned; until then, treat multi-suite staleness flags as advisory rather than definitive.</p> <p>Multiple resultset files: Only suites stored inside a single <code>.resultset.json</code> are merged automatically. If your project produces separate resultset files (e.g., different CI jobs writing <code>coverage/job1/.resultset.json</code>, <code>coverage/job2/.resultset.json</code>), you must merge them yourself before pointing <code>cov-loupe</code> at the combined file.</p>"},{"location":"user/ADVANCED_USAGE/#additional-resources","title":"Additional Resources","text":"<ul> <li>CLI Usage Guide</li> <li>Library API Reference</li> <li>MCP Integration Guide</li> <li>Error Handling Details</li> <li>Troubleshooting</li> </ul>"},{"location":"user/CLI_FALLBACK_FOR_LLMS/","title":"CLI Fallback for LLMs","text":"<p>Back to main README</p> <p>When the MCP server integration isn't working or available, LLMs can use the <code>cov-loupe</code> CLI directly with the <code>-fJ</code> flag to get the same coverage data that the MCP tools provide.</p>"},{"location":"user/CLI_FALLBACK_FOR_LLMS/#overview","title":"Overview","text":"<p>The <code>cov-loupe</code> CLI provides all the same functionality as the MCP tools: - JSON output via <code>-fJ</code> flag for machine-readable responses - Same coverage data: summaries, uncovered lines, detailed per-line data, project-wide tables - Same configuration options: custom resultset paths, staleness checking, etc.</p>"},{"location":"user/CLI_FALLBACK_FOR_LLMS/#sample-prompt-for-users","title":"Sample Prompt for Users","text":"<p>If MCP isn't working, provide this prompt to your LLM:</p> <pre><code>The cov-loupe MCP server isn't available. Please use the cov-loupe CLI\ninstead with the -fJ flag for pretty-printed JSON output.\n\nTo discover available commands and options:\n  cov-loupe --help\n\nAll commands support -fJ for structured, pretty-printed output.\n\nFor detailed documentation, see:\n- README.md in the gem root\n- docs/user/ directory (CLI_USAGE.md, EXAMPLES.md, etc.)\n</code></pre>"},{"location":"user/CLI_FALLBACK_FOR_LLMS/#related-documentation","title":"Related Documentation","text":"<ul> <li>CLI Usage Guide - Complete CLI reference</li> <li>MCP Integration - MCP server setup</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"user/CLI_USAGE/","title":"CLI Usage Guide","text":"<p>Back to main README</p> <p>Complete reference for using cov-loupe from the command line.</p> <p>Docs use <code>clp</code> as a shortcut pointing at the demo fixture with partial coverage: <code>alias clp='cov-loupe -R docs/fixtures/demo_project'</code>  # -R = --root Replace <code>clp</code> with <code>cov-loupe</code> to run commands against your own project. The demo fixture is a small Rails-like project in <code>docs/fixtures/demo_project</code> with intentional coverage gaps for testing <code>--tracked-globs</code>.</p>"},{"location":"user/CLI_USAGE/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Reference</li> <li>Subcommands</li> <li>Global Options</li> <li>Output Formats</li> <li>Environment Variables</li> <li>Examples</li> </ul>"},{"location":"user/CLI_USAGE/#quick-reference","title":"Quick Reference","text":"<pre><code># Show coverage table for all files\nclp\nclp list\n\n# Check specific file\nclp summary app/models/order.rb\n\n# Find uncovered lines\nclp uncovered app/models/order.rb\n\n# Get detailed per-line coverage\nclp detailed app/models/order.rb\n\n# Get raw SimpleCov data\nclp raw app/models/order.rb\n\n# Get project totals\nclp totals\nclp -fp totals\n\n# Show version\nclp version\n\n# Get help\nclp -h  # -h = --help\n</code></pre>"},{"location":"user/CLI_USAGE/#subcommands","title":"Subcommands","text":""},{"location":"user/CLI_USAGE/#list","title":"<code>list</code>","text":"<p>Show coverage summary for all files (default subcommand).</p> <pre><code>clp list\nclp -o d list  # -o = --sort-order, d = descending\nclp -fp list           \n</code></pre> <p>Default sort order is descending (highest coverage first) so the lowest-coverage files stay visible at the bottom of the scrollback.</p> <p>Options:</p> Short Long Description <code>-o</code> <code>--sort-order</code> Sort by coverage percentage (ascending or descending) <code>-g</code> <code>--tracked-globs</code> Filter to specific file patterns <code>-S</code> <code>--raise-on-stale</code> Raise error if coverage is stale (default false) <code>-fp</code> <code>--format pretty-json</code> Output as pretty-printed JSON <code>-fj</code> <code>--format json</code> Output as single-line JSON <code>-f y</code> <code>--format yaml</code> Output as YAML <code>-f ap</code> <code>--format amazing_print</code> Output using AmazingPrint <p>Output (table format): <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 File                                   \u2502        % \u2502   Covered \u2502   Total \u2502 Stale \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 app/models/user.rb                     \u2502  100.00% \u2502         6 \u2502       6 \u2502       \u2502\n\u2502 lib/api/client.rb                      \u2502   88.89% \u2502         8 \u2502       9 \u2502       \u2502\n\u2502 app/models/order.rb                    \u2502   85.71% \u2502         6 \u2502       7 \u2502       \u2502\n\u2502 lib/ops/jobs/report_job.rb             \u2502   80.00% \u2502         4 \u2502       5 \u2502       \u2502\n\u2502 lib/payments/processor.rb              \u2502   80.00% \u2502         4 \u2502       5 \u2502       \u2502\n\u2502 app/controllers/orders_controller.rb   \u2502   70.00% \u2502         7 \u2502      10 \u2502       \u2502\n\u2502 lib/payments/refund_service.rb         \u2502   60.00% \u2502         3 \u2502       5 \u2502       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nFiles: total 7, ok 7, stale 0\n</code></pre></p> <p>Stale indicators: missing (missing file), newer (timestamp mismatch), length_mismatch (line count mismatch), error (staleness check error)</p>"},{"location":"user/CLI_USAGE/#summary-path","title":"<code>summary &lt;path&gt;</code>","text":"<p>Show covered/total/percentage for a specific file.</p> <pre><code>clp summary app/models/order.rb\nclp -fp summary app/models/order.rb\nclp -s full summary app/models/order.rb  # -s = --source\n</code></pre> <p>Arguments: - <code>&lt;path&gt;</code> - File path (relative to project root or absolute)</p> <p>Options:</p> Short Long Description <code>-fp</code> <code>--format pretty-json</code> Output as pretty-printed JSON <code>-fj</code> <code>--format json</code> Output as single-line JSON <code>-f y</code> <code>--format yaml</code> Output as YAML <code>-f ap</code> <code>--format amazing_print</code> Output using AmazingPrint <code>-s</code> <code>--source MODE</code> Include source code (full or uncovered) <p>Output (default format): <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 File                  \u2502        % \u2502 Covered \u2502 Total \u2502 Stale \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 app/models/order.rb   \u2502   85.71% \u2502       6 \u2502     7 \u2502       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Output (JSON format): <pre><code>{\n  \"file\": \"app/models/order.rb\",\n  \"summary\": {\n    \"covered\": 6,\n    \"total\": 7,\n    \"percentage\": 85.71\n  },\n  \"stale\": \"ok\"\n}\n</code></pre></p>"},{"location":"user/CLI_USAGE/#uncovered-path","title":"<code>uncovered &lt;path&gt;</code>","text":"<p>Show uncovered line numbers for a specific file.</p> <pre><code>clp uncovered app/controllers/orders_controller.rb\nclp -s uncovered uncovered app/controllers/orders_controller.rb  # -s = --source\nclp -s uncovered -c 3 uncovered app/controllers/orders_controller.rb  # -s = --source, -c = --context-lines\n</code></pre> <p>Arguments: - <code>&lt;path&gt;</code> - File path (relative to project root or absolute)</p> <p>Options:</p> Short Long Description <code>-s</code> <code>--source uncovered</code> Show uncovered lines with context <code>-c</code> <code>--context-lines N</code> Lines of context around uncovered lines (default: 2) <code>-C</code> <code>--color BOOLEAN</code> Enable (<code>true</code>)/disable (<code>false</code>) syntax coloring <code>-fp</code> <code>--format pretty-json</code> Output as pretty-printed JSON <code>-fj</code> <code>--format json</code> Output as single-line JSON <code>-f y</code> <code>--format yaml</code> Output as YAML <code>-f ap</code> <code>--format amazing_print</code> Output using AmazingPrint <p>Output (default format): <pre><code>File:            app/controllers/orders_controller.rb\nUncovered lines: 14, 15, 20\nSummary:         70.0%      7/10\n</code></pre></p> <p>Output (with source): <pre><code>File:            app/controllers/orders_controller.rb\nUncovered lines: 14, 15, 20\nSummary:         70.0%      7/10\n\n  Line     | Source\n  ------+-----------------------------------------------------------\n    14  \u00b7 |       def show(id)\n    15  \u00b7 |         @repo.find(id)\n    16  \u2713 |       end\n    17    |\n    18  \u2713 |       def cancel(id)\n    19  \u2713 |         order = @repo.find(id)\n    20  \u00b7 |         return :missing unless order\n</code></pre></p> <p>Legend: - <code>\u2713</code> - Line is covered - <code>\u00b7</code> - Line is not covered - <code></code> - Line is not executable (comments, blank lines)</p>"},{"location":"user/CLI_USAGE/#detailed-path","title":"<code>detailed &lt;path&gt;</code>","text":"<p>Show per-line coverage with hit counts.</p> <pre><code>clp detailed app/models/order.rb\nclp -fp detailed app/models/order.rb\nclp -s full detailed app/models/order.rb  # -s = --source\n</code></pre> <p>Arguments: - <code>&lt;path&gt;</code> - File path (relative to project root or absolute)</p> <p>Options:</p> Short Long Description <code>-fp</code> <code>--format pretty-json</code> Output as pretty-printed JSON <code>-fj</code> <code>--format json</code> Output as single-line JSON <code>-f y</code> <code>--format yaml</code> Output as YAML <code>-f ap</code> <code>--format amazing_print</code> Output using AmazingPrint <code>-s</code> <code>--source MODE</code> Include source code <p>Output (default format): <pre><code>File: app/models/order.rb\nCoverage: 6/7 lines (85.71%)\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Line \u2502 Hits \u2502 Covered \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    6 \u2502    1 \u2502   yes   \u2502\n\u2502    7 \u2502    1 \u2502   yes   \u2502\n\u2502    8 \u2502    1 \u2502   yes   \u2502\n\u2502   11 \u2502    1 \u2502   yes   \u2502\n\u2502   12 \u2502    1 \u2502   yes   \u2502\n\u2502   15 \u2502    1 \u2502   yes   \u2502\n\u2502   16 \u2502    0 \u2502   no    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Output (JSON format): <pre><code>{\n  \"file\": \"app/models/order.rb\",\n  \"lines\": [\n    { \"line\": 6, \"hits\": 1, \"covered\": true },\n    { \"line\": 7, \"hits\": 1, \"covered\": true },\n    { \"line\": 8, \"hits\": 1, \"covered\": true },\n    { \"line\": 11, \"hits\": 1, \"covered\": true },\n    { \"line\": 12, \"hits\": 1, \"covered\": true },\n    { \"line\": 15, \"hits\": 1, \"covered\": true },\n    { \"line\": 16, \"hits\": 0, \"covered\": false }\n  ],\n  \"summary\": {\n    \"covered\": 6,\n    \"total\": 7,\n    \"percentage\": 85.71\n  },\n  \"stale\": \"ok\"\n}\n</code></pre></p>"},{"location":"user/CLI_USAGE/#raw-path","title":"<code>raw &lt;path&gt;</code>","text":"<p>Show the raw SimpleCov lines array.</p> <pre><code>clp raw app/models/order.rb\nclp -fp raw app/models/order.rb\n</code></pre> <p>Arguments: - <code>&lt;path&gt;</code> - File path (relative to project root or absolute)</p> <p>Output (default format): <pre><code>File: app/models/order.rb\n[nil, nil, nil, nil, nil, 1, 1, 1, nil, nil, 1, 1, nil, nil, 1, 0, nil, nil, nil, nil]\n</code></pre></p> <p>Output (JSON format): <pre><code>{\n  \"file\": \"app/models/order.rb\",\n  \"lines\": [null, null, null, null, null, 1, 1, 1, null, null, 1, 1, null, null, 1, 0, null, null, null, null],\n  \"stale\": \"ok\"\n}\n</code></pre></p> <p>Array explanation: - Integer (e.g., <code>1</code>, <code>5</code>) - Number of times line was executed - <code>0</code> - Line is executable but was not executed - <code>null</code> - Line is not executable (comment, blank line)</p>"},{"location":"user/CLI_USAGE/#totals","title":"<code>totals</code>","text":"<p>Show aggregated totals for all tracked files.</p> <pre><code>clp totals\nclp -fp totals\nclp -g \"lib/ops/jobs/*.rb\" totals  # -g = --tracked-globs\n</code></pre> <p>Output (default format): <pre><code>Tracked globs:\n  - lib/**/*.rb\n  - app/**/*.rb\n  - src/**/*.rb\n\nTotals\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Metric   \u2502 Total \u2502 Covered \u2502 Uncovered \u2502      % \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Lines    \u2502    47 \u2502      38 \u2502         9 \u2502 80.85% \u2502\n\u2502 Files    \u2502     7 \u2502       7 \u2502         0 \u2502        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nFile breakdown:\n  With coverage: 7 total, 7 ok, 0 stale\n    Stale: missing on disk = 0, newer than coverage = 0, line mismatch = 0, unreadable = 0\n  Without coverage: 0 total\n    Missing from coverage = 0, unreadable = 0, skipped (errors) = 0\n</code></pre></p> <p>Tracked globs (shown when tracking is enabled): <pre><code>Tracked globs:\n  - lib/**/*.rb\n  - app/**/*.rb\n</code></pre></p> <p>Output (JSON format): <pre><code>{\n  \"lines\": { \"total\": 47, \"covered\": 38, \"uncovered\": 9, \"percent_covered\": 80.85 },\n  \"tracking\": { \"enabled\": true, \"globs\": [\"lib/**/*.rb\", \"app/**/*.rb\"] },\n  \"files\": {\n    \"total\": 7,\n    \"with_coverage\": {\n      \"total\": 7,\n      \"ok\": 7,\n      \"stale\": {\n        \"total\": 0,\n        \"by_type\": {\n          \"missing_from_disk\": 0,\n          \"newer\": 0,\n          \"length_mismatch\": 0,\n          \"unreadable\": 0\n        }\n      }\n    },\n    \"without_coverage\": {\n      \"total\": 0,\n      \"by_type\": {\n        \"missing_from_coverage\": 0,\n        \"unreadable\": 0,\n        \"skipped\": 0\n      }\n    }\n  }\n}\n</code></pre></p> <p>Notes: - <code>lines</code> are based on fresh coverage entries only. - <code>with_coverage.stale.by_type</code> uses readable labels: <code>missing_from_disk</code>, <code>newer</code>,   <code>length_mismatch</code>, <code>unreadable</code>. - <code>without_coverage</code> is only present when tracking is enabled (tracked globs provided). - Respects <code>-g</code> / <code>--tracked-globs</code> when you only want to aggregate a subset of files. - Totals exclude stale files (<code>\"missing\"</code>, <code>\"newer\"</code>, <code>\"length_mismatch\"</code>, <code>\"error\"</code>) so the aggregate reflects only fresh coverage data. - Honors <code>-S</code> / <code>--raise-on-stale</code> to raise if coverage data is out of date.</p>"},{"location":"user/CLI_USAGE/#version","title":"<code>version</code>","text":"<p>Show version information.</p> <pre><code>clp version\nclp -fp version\n</code></pre> <p>Output: <pre><code>CovLoupe version 1.0.0\n</code></pre></p>"},{"location":"user/CLI_USAGE/#global-options","title":"Global Options","text":"<p>These options work with all subcommands.</p>"},{"location":"user/CLI_USAGE/#-r-resultset-path","title":"<code>-r, --resultset PATH</code>","text":"<p>Path to the <code>.resultset.json</code> file or a directory containing it.</p> <p>For a detailed explanation of how to configure the resultset location, including the default search path, environment variables, and MCP configuration, see the Configuring the Resultset section in the main README.</p>"},{"location":"user/CLI_USAGE/#-r-root-path","title":"<code>-R, --root PATH</code>","text":"<p>Project root directory (default: current directory).</p> <pre><code>clp -R /path/to/project  # -R = --root\n</code></pre>"},{"location":"user/CLI_USAGE/#-fp","title":"<code>-fp</code>","text":"<p>Output as pretty-printed JSON instead of human-readable format.</p> <pre><code>clp -fp summary lib/api/client.rb\n</code></pre> <p>Useful for: - Parsing in scripts - Integration with other tools - Machine consumption</p>"},{"location":"user/CLI_USAGE/#-o-sort-order-order","title":"<code>-o, --sort-order ORDER</code>","text":"<p>Sort order for <code>list</code> subcommand.</p> <p>Values: - <code>descending</code>, <code>d</code> - Highest coverage first (default) - <code>ascending</code>, <code>a</code> - Lowest coverage first</p> <pre><code>clp -o d list  # d = descending (default)\nclp -o a list  # a = ascending\n</code></pre>"},{"location":"user/CLI_USAGE/#-s-source-mode","title":"<code>-s, --source MODE</code>","text":"<p>Include source code in output.</p> <p>Modes:</p> Short Long Description <code>f</code> <code>full</code> Show all source lines <code>u</code> <code>uncovered</code> Show only uncovered lines with context <pre><code># Show full source\nclp -s full summary lib/api/client.rb      # -s = --source\nclp -s f summary lib/api/client.rb         # f = full\n\n# Show only uncovered lines\nclp -s u uncovered lib/api/client.rb       # u = uncovered\n</code></pre>"},{"location":"user/CLI_USAGE/#-c-context-lines-n","title":"<code>-c, --context-lines N</code>","text":"<p>Number of context lines around uncovered code (for <code>-s uncovered</code> / <code>--source uncovered</code>). Must be a non-negative integer.</p> <pre><code>clp -s u -c 3 uncovered lib/api/client.rb  # -s u = uncovered, -c = --context-lines\n</code></pre> <p>Default: 2 lines</p>"},{"location":"user/CLI_USAGE/#boolean-flags-color-c-raise-on-stale","title":"Boolean Flags (<code>--color</code> / <code>-C</code>, <code>--raise-on-stale</code>)","text":"<p>These options require explicit boolean values. Recognized literals:</p> true false <code>yes</code> <code>no</code> <code>y</code> <code>n</code> <code>true</code> <code>false</code> <code>t</code> <code>f</code> <code>on</code> <code>off</code> <code>+</code> <code>-</code> <code>1</code> <code>0</code> <pre><code>clp --color false           # disable color\nclp --raise-on-stale yes    # enforce stale coverage failures\n</code></pre>"},{"location":"user/CLI_USAGE/#-c-color-boolean","title":"<code>-C, --color BOOLEAN</code>","text":"<p>Enable or disable ANSI color codes in source output. Requires an explicit boolean value.</p> <pre><code>clp -s uncovered --color true uncovered lib/api/client.rb\nclp -s uncovered -C false uncovered lib/api/client.rb\n</code></pre> <p>Default: Colors enabled if output is a TTY</p>"},{"location":"user/CLI_USAGE/#-s-raise-on-stale-boolean","title":"<code>-S, --raise-on-stale BOOLEAN</code>","text":"<p>Raise error if coverage is stale. Requires an explicit boolean value. Default is <code>false</code> (only report staleness in output).</p> <pre><code># Enable raising an error if coverage is stale\nclp -S true\nclp --raise-on-stale yes\n\n# Explicitly disable raising an error (useful to override COV_LOUPE_OPTS)\nclp --raise-on-stale false\n</code></pre> <p>Staleness conditions: - \"missing\" (Missing): Source file no longer exists on disk - \"newer\" (Timestamp): Source file modified after coverage was generated - \"length_mismatch\" (Length): Source file line count differs from coverage data - \"error\" (Error): Staleness check failed due to permission or I/O errors - Tracked files missing from coverage (with --tracked-globs)</p>"},{"location":"user/CLI_USAGE/#-g-tracked-globs-patterns","title":"<code>-g, --tracked-globs PATTERNS</code>","text":"<p>Comma-separated glob patterns for files that should be tracked.</p> <p>Default: <code>[]</code> (empty - shows all files in the resultset)</p> <p>Why no default patterns? 1. Transparency - Shows all coverage data without hiding files that don't match assumptions 2. Avoids false positives - Broad patterns like <code>**/*.rb</code> flag migrations, bin scripts, etc. as \"missing\" 3. Project variety - Coverage patterns vary by project structure (lib/, app/, src/, config/, etc.)</p> <p>Important: Files lacking any coverage at all (not loaded during tests) will not appear in the resultset and therefore won't be visible with the default empty array. To detect such files, you must set <code>--tracked-globs</code> to match the files you expect to have coverage.</p> <p>Best practice: Match your SimpleCov configuration by setting <code>COV_LOUPE_OPTS</code>:</p> <pre><code># In spec_helper.rb or similar\nSimpleCov.start do\n  add_filter '/spec/'\n  add_filter '/test/'\n  track_files 'lib/**/*.rb'\n  track_files 'app/**/*.rb'\nend\n</code></pre> <pre><code># In your shell config (.bashrc, .zshrc, etc.)\n# Match the track_files patterns above\nexport COV_LOUPE_OPTS=\"--tracked-globs lib/**/*.rb,app/**/*.rb\"\n</code></pre> <p>Usage:</p> <pre><code># Use environment variable for project-wide default\nexport COV_LOUPE_OPTS=\"--tracked-globs lib/**/*.rb,app/**/*.rb\"\nclp list  # Uses globs from env var\n\n# Or specify per-command\nclp -g \"lib/api/**/*.rb\" list\n\n# Multiple patterns\nclp -g \"lib/**/*.rb,app/models/**/*.rb\" list\n\n# Export for CI (with globs to match SimpleCov)\nclp -g \"lib/**/*.rb,app/**/*.rb\" -fp list &gt; coverage.json\n</code></pre> <p>Use cases: - Exclude unwanted results - Narrow focus to a subsystem or layer - Include files without coverage - Report files that should be tracked but aren't in the resultset - CI validation - Use with <code>-S</code>/<code>--raise-on-stale</code> to catch coverage gaps</p> <p>Important: The <code>missing_tracked_files</code> array (in <code>list</code> output) only includes files that: 1. Match the tracked globs 2. Exist in the filesystem 3. Are NOT in the coverage resultset</p> <p>Without globs, this array is empty (no expectations = no violations).</p>"},{"location":"user/CLI_USAGE/#-l-log-file-path","title":"<code>-l, --log-file PATH</code>","text":"<p>Log file location. Use 'stdout' or 'stderr' to log to standard streams.</p> <pre><code>clp -l /var/log/simplecov.log  # -l = --log-file\nclp -l stdout                   # Log to standard output\nclp -l stderr                   # Log to standard error\n</code></pre> <p>Default: <code>./cov_loupe.log</code></p> <p>Warning: Log files may grow unbounded in long-running or CI usage. Consider using a log rotation tool or periodically cleaning up the log file if this is a concern.</p>"},{"location":"user/CLI_USAGE/#-e-error-mode-mode","title":"<code>-e, --error-mode MODE</code>","text":"<p>Error handling verbosity.</p> <p>Modes:</p> Short Long Description <code>off</code> Silent (no error logging) <code>l</code> <code>log</code> Log errors without stack traces (default) <code>d</code> <code>debug</code> Log errors with full stack traces <pre><code>clp --error-mode debug summary lib/api/client.rb\nclp -e debug summary lib/api/client.rb  # -e = --error-mode\nclp -edebug summary lib/api/client.rb   # attached short option form\n</code></pre>"},{"location":"user/CLI_USAGE/#-o-output-chars-mode","title":"<code>-O, --output-chars MODE</code>","text":"<p>Control output character encoding for ASCII-only environments.</p> <p>Modes:</p> Short Long Description <code>d</code> <code>default</code> Auto-detect terminal UTF-8 support (default) <code>f</code> <code>fancy</code> Force Unicode output with box-drawing characters <code>a</code> <code>ascii</code> Force ASCII-only output with transliteration <pre><code># Default mode (auto-detect)\nclp list\n\n# Force ASCII mode (for legacy terminals or CI)\nclp -O ascii list\nclp -O a list  # a = ascii\n\n# Force fancy mode (Unicode characters)\nclp -O fancy list\nclp -O f list  # f = fancy\n</code></pre> <p>What gets converted in ASCII mode: - Table borders (\u2502 \u2500 \u250c \u2510 \u2514 \u2518 \u251c \u2524 \u252c \u2534 \u253c \u2192 | - + + + + + + + + +) - Source code markers (\u2713 \u00b7 \u2192 + -) - Error messages and file paths - All formatted output (tables, source, JSON, YAML)</p> <p>What does NOT get converted: - Log files (preserved in original encoding for debugging fidelity) - Gem post-install message</p> <p>Use cases: - CI/CD systems with ASCII-only terminals: <code>clp -O ascii list</code> - Windows with legacy encoding: <code>clp -O ascii summary lib/api/client.rb</code> - Piped output to files: <code>clp -O ascii list &gt; coverage.txt</code> - Force Unicode even if terminal detection fails: <code>clp -O fancy list</code></p> <p>Note: The default mode auto-detects whether your terminal supports UTF-8. If Unicode characters appear garbled or as question marks, try <code>clp -O ascii</code>.</p>"},{"location":"user/CLI_USAGE/#-m-mode-mode","title":"<code>-m, --mode MODE</code>","text":"<p>Specify execution mode: <code>cli</code> or <code>mcp</code> (default: <code>cli</code>). Use <code>--mode mcp</code> to run as an MCP server. In v4.0.0+, automatic mode detection was removed; you must explicitly specify <code>--mode mcp</code> to run the MCP server.</p> <pre><code>clp -m mcp               # MCP server mode (required for MCP), short option form\nclp --mode mcp           # MCP server mode (required for MCP), long option form\nclp -m cli list          # CLI mode (default), can use to override environment variable\n</code></pre>"},{"location":"user/CLI_USAGE/#validate-subcommand","title":"<code>validate</code> Subcommand","text":"<p>Validate coverage against custom policies for CI/CD enforcement.</p> <p>\u26a0\ufe0f SECURITY WARNING</p> <p>Validation predicates execute as arbitrary Ruby code with full system privileges. They have unrestricted access to file system, network, system commands, and environment variables.</p> <p>Only use predicate files from trusted sources. Review predicates before use, especially in CI/CD environments.</p> <p>The predicate must be a callable (lambda, proc, or object with <code>#call</code> method) that receives a <code>CoverageModel</code> and returns <code>true</code> or <code>false</code>.</p> <p>Predicate return values: - <code>true</code> - Coverage meets your criteria (CLI exits with code 0) - <code>false</code> - Coverage fails your criteria (CLI exits with code 1) - Exception raised - Predicate error (CLI exits with code 2)</p> <p>File mode (most common): <pre><code># Use example predicate\nclp validate examples/success_predicates/all_files_above_threshold_predicate.rb\n\n# In CI/CD\nbundle exec cov-loupe validate coverage_policy.rb\n</code></pre></p> <p>String mode (inline code): <pre><code># Simple inline validation\nclp validate -i '-&gt;(m) { m.list.all? { |f| f[\"percentage\"] &gt;= 80 } }'\n\n# With global options\nclp -r coverage validate -i '-&gt;(m) { m.list.size &gt; 0 }'\n</code></pre></p> <p>Example predicate file: <pre><code># coverage_policy.rb\n-&gt;(model) do\n  model.list.all? { |f| f['percentage'] &gt;= 80 }\nend\n</code></pre></p> <p>See examples/success_predicates/ for more examples.</p>"},{"location":"user/CLI_USAGE/#output-formats","title":"Output Formats","text":""},{"location":"user/CLI_USAGE/#table-format","title":"Table Format","text":"<p>Default for <code>list</code> subcommand. Uses Unicode box-drawing characters.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 File                             \u2502        % \u2502   Covered \u2502   Total \u2502 Stale \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 lib/payments/refund_service.rb   \u2502   60.00% \u2502         3 \u2502       5 \u2502       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"user/CLI_USAGE/#json-format","title":"JSON Format","text":"<p>Machine-readable output. Paths are relative to project root.</p> <pre><code>{\n  \"file\": \"app/models/order.rb\",\n  \"summary\": {\n    \"covered\": 6,\n    \"total\": 7,\n    \"percentage\": 85.71\n  },\n  \"stale\": \"ok\"\n}\n</code></pre> <p>Staleness values: - <code>\"ok\"</code> - Coverage data is current - <code>\"missing\"</code> - File missing (no longer exists on disk) - <code>\"newer\"</code> - Timestamp mismatch (file modified after coverage) - <code>\"length_mismatch\"</code> - Length mismatch (line count differs)</p>"},{"location":"user/CLI_USAGE/#source-display","title":"Source Display","text":"<p>With <code>--source</code> flag, shows annotated source code:</p> <pre><code>  Line     | Source\n  ------+-----------------------------------------------------------\n     1  \u2713 | class User\n     2  \u00b7 |   def initialize  # Not covered\n     3  \u2713 |     # ...\n</code></pre>"},{"location":"user/CLI_USAGE/#environment-variables","title":"Environment Variables","text":""},{"location":"user/CLI_USAGE/#cov_loupe_opts","title":"<code>COV_LOUPE_OPTS</code>","text":"<p>Default command-line options applied to all invocations.</p> <p>Format: Shell-style string containing any valid CLI options</p> <pre><code>export COV_LOUPE_OPTS=\"--resultset coverage -fp\"\nclp summary lib/api/client.rb  # Automatically uses options above\n</code></pre> <p>Precedence: Command-line arguments override environment options</p> <pre><code># Environment sets -fp; explicit CLI options still take precedence\nexport COV_LOUPE_OPTS=\"-fp\"\nclp summary lib/api/client.rb  # Uses JSON (from env)\nclp -f table summary lib/api/client.rb  # Explicit override to table format\n</code></pre> <p>Examples: <pre><code># Default resultset location\nexport COV_LOUPE_OPTS=\"-r build/coverage\"\n\n# Enable detailed error logging\nexport COV_LOUPE_OPTS=\"--error-mode debug\"\n\n# Paths with spaces\nexport COV_LOUPE_OPTS='-r \"/path with spaces/coverage\"'\n\n# Multiple options\nexport COV_LOUPE_OPTS=\"-r coverage -S -fp\"\n</code></pre></p>"},{"location":"user/CLI_USAGE/#examples","title":"Examples","text":""},{"location":"user/CLI_USAGE/#basic-coverage-check","title":"Basic Coverage Check","text":"<pre><code># Show all files sorted by highest coverage first (default)\nclp\n\n# Find the 5 files with worst coverage (account for header/footer)\nclp list | tail -7\n</code></pre>"},{"location":"user/CLI_USAGE/#detailed-file-investigation","title":"Detailed File Investigation","text":"<pre><code># Check a specific file\nclp summary lib/payments/refund_service.rb\n\n# See which lines aren't covered\nclp uncovered lib/payments/refund_service.rb\n\n# View uncovered code in context\nclp -s uncovered -c 3 uncovered lib/payments/refund_service.rb\n\n# Get detailed hit counts\nclp detailed lib/payments/refund_service.rb\n</code></pre>"},{"location":"user/CLI_USAGE/#json-output-for-scripts","title":"JSON Output for Scripts","text":"<pre><code># Get JSON for parsing\nclp -fp list &gt; coverage.json\n\n# Extract files below threshold\nclp -fp list | jq '.files[] | select(.percentage &lt; 80)'\n\n# Ruby alternative:\nclp -fp list | ruby -r json -e '\n  JSON.parse($stdin.read)[\"files\"].select { |f| f[\"percentage\"] &lt; 80 }.each do |f|\n    puts JSON.pretty_generate(f)\n  end\n'\n\n# Rexe alternative:\nclp -fp list | rexe -ij -mb -oJ 'self[\"files\"].select { |f| f[\"percentage\"] &lt; 80 }'\n\n# Count files below 80% coverage\nclp -fp list | jq '[.files[] | select(.percentage &lt; 80)] | length'\n\n# Ruby alternative:\nclp -fp list | ruby -r json -e '\n  puts JSON.parse($stdin.read)[\"files\"].count { |f| f[\"percentage\"] &lt; 80 }\n'\n\n# Rexe alternative:\nclp -fp list | rexe -ij -mb -op 'self[\"files\"].count { |f| f[\"percentage\"] &lt; 80 }'\n</code></pre>"},{"location":"user/CLI_USAGE/#filtering-and-sorting","title":"Filtering and Sorting","text":"<pre><code># Show only lib/ files\nclp -g \"lib/**/*.rb\" list\n\n# Show files sorted by highest coverage\nclp -o d list\n\n# Check specific directory\nclp -g \"lib/payments/**/*.rb\" list\n</code></pre>"},{"location":"user/CLI_USAGE/#staleness-checking","title":"Staleness Checking","text":"<pre><code># Check if coverage is stale (for CI/CD)\nclp -S true\n\n# Check with specific file patterns\nclp -S true -g \"lib/payments/**/*.rb,lib/ops/jobs/**/*.rb\" list\n\n# See which files are stale (don't error)\nclp list  # Stale column shows missing/newer/length_mismatch/error markers\n</code></pre>"},{"location":"user/CLI_USAGE/#source-code-display","title":"Source Code Display","text":"<pre><code># Show full source with coverage markers\nclp -s full summary lib/api/client.rb\n\n# Show only uncovered lines with context\nclp -s uncovered uncovered lib/api/client.rb\n\n# More context around uncovered code\nclp -s uncovered -c 5 uncovered lib/api/client.rb\n\n# Without colors (for logging)\nclp -s full --color false uncovered lib/api/client.rb\n</code></pre>"},{"location":"user/CLI_USAGE/#cicd-integration","title":"CI/CD Integration","text":"<pre><code># Fail build if coverage is stale\nclp -S true || exit 1\n\n# Generate JSON report for artifact\nclp -fp list &gt; artifacts/coverage-report.json\n\n# Check specific directory in monorepo\nclp -R services/api -r services/api/coverage  # -R = --root, -r = --resultset\n</code></pre>"},{"location":"user/CLI_USAGE/#debugging","title":"Debugging","text":"<pre><code># Verbose error output\nclp --error-mode debug summary lib/api/client.rb\n\n# Custom log file (--log-file or -l)\nclp -l /tmp/simplecov-debug.log summary lib/api/client.rb\n\n# Check what resultset is being used\nclp --error-mode debug 2&gt;&amp;1 | grep resultset\n</code></pre>"},{"location":"user/CLI_USAGE/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code> - Success</li> <li><code>1</code> - Error (file not found, coverage data missing, stale coverage with <code>-S</code> / <code>--raise-on-stale</code>, etc.)</li> </ul>"},{"location":"user/CLI_USAGE/#next-steps","title":"Next Steps","text":"<ul> <li>Library API - Use in Ruby code</li> <li>Examples - More usage examples and recipes</li> <li>Troubleshooting - Common issues and solutions</li> </ul>"},{"location":"user/ERROR_HANDLING/","title":"Error Handling Guide","text":"<p>Back to main README</p> <p>Error handling differs by usage mode:</p>"},{"location":"user/ERROR_HANDLING/#cli-mode","title":"CLI Mode","text":"<p>Errors are displayed as user-friendly messages without stack traces:</p> <pre><code>$ cov-loupe summary nonexistent.rb\nFile error: No coverage data found for the specified file\n</code></pre> <p>For debugging, use the <code>--error-mode debug</code> flag to include stack traces in log output and display the first 5 lines of the backtrace in CLI output:</p> <pre><code>$ cov-loupe --error-mode debug summary nonexistent.rb\n</code></pre>"},{"location":"user/ERROR_HANDLING/#library-mode","title":"Library Mode","text":"<p>Calls to <code>CovLoupe::CoverageModel</code> raise custom exceptions you can handle programmatically:</p> <pre><code>handler = CovLoupe::ErrorHandlerFactory.for_library  # disables CLI-style logging\ncontext = CovLoupe.create_context(error_handler: handler)\n\nCovLoupe.with_context(context) do\n  model = CovLoupe::CoverageModel.new\n  begin\n    model.summary_for('missing.rb')\n  rescue CovLoupe::FileError =&gt; e\n    puts \"Handled gracefully: #{e.user_friendly_message}\"\n  end\nend\n</code></pre> <p>Available exception classes: - <code>CovLoupe::Error</code> - Base error class - <code>CovLoupe::FileError</code> - File not found or access issues - <code>CovLoupe::CoverageDataError</code> - Invalid or missing coverage data - <code>CovLoupe::ConfigurationError</code> - Configuration problems - <code>CovLoupe::UsageError</code> - Command usage errors</p>"},{"location":"user/ERROR_HANDLING/#mcp-server-mode","title":"MCP Server Mode","text":"<p>Errors are returned as structured responses to the MCP client:</p> <ul> <li>Logging enabled - Errors go to <code>cov_loupe.log</code> in the current directory by default</li> <li>Clean error messages - User-friendly messages, no stack traces by default</li> <li>Structured responses - Tool responses instead of exceptions</li> </ul>"},{"location":"user/ERROR_HANDLING/#custom-error-handlers","title":"Custom Error Handlers","text":"<p>Library usage can opt into different logging behavior by installing a custom handler on the active context:</p> <pre><code>handler = CovLoupe::ErrorHandler.new(\n  log_errors: true,         # Enable logging when embedding\n  show_stack_traces: false  # Keep error messages clean\n)\n\ncontext = CovLoupe.create_context(error_handler: handler)\n\nCovLoupe.with_context(context) do\n  model = CovLoupe::CoverageModel.new\n  model.summary_for('lib/cov_loupe/model.rb')\nend\n</code></pre>"},{"location":"user/ERROR_HANDLING/#stale-coverage-errors","title":"Stale Coverage Errors","text":"<p>When strict staleness checking is enabled (<code>--raise-on-stale</code>), the model (and CLI) raise a <code>CoverageDataStaleError</code> if a source file appears newer than the coverage data or the line counts differ.</p> <ul> <li>Enable per instance: <code>CovLoupe::CoverageModel.new(raise_on_stale: true)</code></li> </ul> <p>The error message is detailed and includes:</p> <ul> <li>File and Coverage times (UTC and local) and line counts</li> <li>A delta indicating how much newer the file is than coverage</li> <li>The absolute path to the <code>.resultset.json</code> used</li> </ul> <p>Example excerpt:</p> <pre><code>Coverage data stale: Coverage data appears stale for lib/foo.rb\nFile      - time: 2025-09-16T14:03:22Z (local 2025-09-16T07:03:22-07:00), lines: 226\nCoverage  - time: 2025-09-15T21:11:09Z (local 2025-09-15T14:11:09-07:00), lines: 220\nDelta     - file is +123s newer than coverage\nResultset - /path/to/project/coverage/.resultset.json\n</code></pre>"},{"location":"user/EXAMPLES/","title":"Examples and Recipes","text":"<p>Back to main README</p> <p>Practical examples for common tasks with cov-loupe. Examples are organized by skill level and use case.</p> <p>For brevity, these examples use <code>clp</code>, an alias to the demo fixture with partial coverage:</p> <p><code>alias clp='cov-loupe -R docs/fixtures/demo_project'  # -R = --root</code></p> <p>Swap <code>clp</code> for <code>cov-loupe</code> to run against your own project and resultset. The demo fixture is a small Rails-like project in <code>docs/fixtures/demo_project</code> with intentional coverage gaps for testing <code>--tracked-globs</code>.</p>"},{"location":"user/EXAMPLES/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Start Examples</li> <li>CLI Examples</li> <li>Ruby Library Examples</li> <li>AI Assistant Prompts</li> <li>CI/CD Integration</li> <li>Advanced Usage</li> </ul>"},{"location":"user/EXAMPLES/#quick-start-examples","title":"Quick Start Examples","text":""},{"location":"user/EXAMPLES/#view-all-coverage","title":"View All Coverage","text":"<pre><code># Default: show all files, best coverage first\nclp\n\n# Show files with worst coverage first\nclp -o a list  # -o = --sort-order, a = ascending\n\n# Export to JSON for processing\nclp -fJ list &gt; coverage-report.json\n</code></pre>"},{"location":"user/EXAMPLES/#check-specific-file","title":"Check Specific File","text":"<pre><code># Quick summary\nclp summary app/models/order.rb\n\n# See which lines aren't covered\nclp uncovered app/controllers/orders_controller.rb\n\n# View uncovered code with context\nclp -s u -c 3 uncovered app/controllers/orders_controller.rb  # -s = --source (u = uncovered), -c = --context-lines\n</code></pre>"},{"location":"user/EXAMPLES/#find-coverage-gaps","title":"Find Coverage Gaps","text":"<pre><code># Files with worst coverage (account for header/footer)\nclp list | tail -12\n\n# Only show files below 80%\nclp -fJ list | jq '.files[] | select(.percentage &lt; 80)'\n\n# Ruby alternative:\nclp -fJ list | ruby -r json -e '\n  JSON.parse($stdin.read)[\"files\"].select { |f| f[\"percentage\"] &lt; 80 }.each do |f|\n    puts JSON.pretty_generate(f)\n  end\n'\n\n# Rexe alternative:\nclp -fJ list | rexe -ij -mb -oJ 'self[\"files\"].select { |f| f[\"percentage\"] &lt; 80 }'\n\n# Check specific directory\nclp -g \"lib/payments/**/*.rb\" list  # -g = --tracked-globs\n</code></pre>"},{"location":"user/EXAMPLES/#cli-examples","title":"CLI Examples","text":""},{"location":"user/EXAMPLES/#coverage-analysis","title":"Coverage Analysis","text":"<p>Detailed investigation: <pre><code># See detailed hit counts\nclp detailed lib/api/client.rb\n\n# Show full source with coverage markers\nclp -s f summary lib/api/client.rb  # f = full\n\n# Focus on uncovered areas only\nclp -s u -c 5 uncovered lib/payments/refund_service.rb  # u = uncovered\n</code></pre></p>"},{"location":"user/EXAMPLES/#working-with-json-output","title":"Working with JSON Output","text":"<p>In addition to the benefit of JSON encoding being human readable, it can be used in single line commands to fetch and compute values using <code>jq</code>, Ruby's JSON library, or <code>rexe</code>. Here are some examples:</p> <p>Parse and filter: <pre><code># Files below threshold\nclp -fJ list | jq '.files[] | select(.percentage &lt; 80) | {file, coverage: .percentage}'\n\n# Ruby alternative:\nclp -fJ list | ruby -r json -e '\n  JSON.parse($stdin.read)[\"files\"].select { |f| f[\"percentage\"] &lt; 80 }.each do |f|\n    puts JSON.pretty_generate({file: f[\"file\"], coverage: f[\"percentage\"]})\n  end\n'\n\n# Rexe alternative:\nclp -fJ list | rexe -ij -mb -oJ '\n  self[\"files\"].select { |f| f[\"percentage\"] &lt; 80 }.map do |f|\n    {file: f[\"file\"], coverage: f[\"percentage\"]}\n  end\n'\n\n# Count total uncovered lines\nclp -fJ totals | jq '.lines.uncovered'\n\n# Ruby alternative:\nclp -fJ totals | ruby -r json -e '\n  puts JSON.parse($stdin.read)[\"lines\"][\"uncovered\"]\n'\n\n# Rexe alternative:\nclp -fJ totals | rexe -ij -mb -op 'self[\"lines\"][\"uncovered\"]'\n\n# Group by directory (full path)\nclp -fJ list |\n  jq '.files\n      | map(. + {dir: (.file | split(\"/\") | .[0:-1] | join(\"/\"))})\n      | sort_by(.dir)\n      | group_by(.dir)\n      | map({dir: .[0].dir, avg: (map(.percentage) | add / length)})'\n\n# Ruby alternative:\nclp -fJ list | ruby -r json -e '\n  grouped = JSON.parse($stdin.read)[\"files\"]\n    .map { |f| f.merge(\"dir\" =&gt; File.dirname(f[\"file\"])) }\n    .group_by { |f| f[\"dir\"] }\n    .map { |dir, files|\n      avg = files.sum { |f| f[\"percentage\"] } / files.size\n      {dir: dir, avg: avg}\n    }\n  puts JSON.pretty_generate(grouped)\n'\n\n# Rexe alternative:\nclp -fJ list | rexe -ij -mb -oJ '\n  self[\"files\"]\n    .map { |f| f.merge(\"dir\" =&gt; File.dirname(f[\"file\"])) }\n    .group_by { |f| f[\"dir\"] }\n    .map { |dir, files|\n      avg = files.sum { |f| f[\"percentage\"] } / files.size\n      {dir: dir, avg: avg}\n    }\n'\n</code></pre></p> <p>Generate reports: <pre><code># Create markdown table\necho \"| Coverage | File |\" &gt; report.md\necho \"|----------|------|\" &gt;&gt; report.md\nclp -fJ list | jq -r '.files[] | \"| \\(.percentage)% | \\(.file) |\"' &gt;&gt; report.md\n\n# Ruby alternative:\nclp -fJ list | ruby -r json -e '\n  JSON.parse($stdin.read)[\"files\"].each do |f|\n    puts \"| #{f[\"percentage\"]}% | #{f[\"file\"]} |\"\n  end\n' &gt;&gt; report.md\n\n# Rexe alternative:\nclp -fJ list | rexe -ij -mb '\n  self[\"files\"].each { |f| puts \"| #{f[\"percentage\"]}% | #{f[\"file\"]} |\" }\n' &gt;&gt; report.md\n\n# Export for spreadsheet\nclp -fJ list | jq -r '.files[] | [.file, .percentage] | @csv' &gt; coverage.csv\n\n# Ruby alternative:\nclp -fJ list | ruby -r json -r csv -e '\n  JSON.parse($stdin.read)[\"files\"].each do |f|\n    puts CSV.generate_line([f[\"file\"], f[\"percentage\"]]).chomp\n  end\n' &gt; coverage.csv\n\n# Rexe alternative:\nclp -fJ list | rexe -r csv -ij -mb '\n  self[\"files\"].each { |f| puts CSV.generate_line([f[\"file\"], f[\"percentage\"]]).chomp }\n' &gt; coverage.csv\n</code></pre></p>"},{"location":"user/EXAMPLES/#ruby-library-examples","title":"Ruby Library Examples","text":""},{"location":"user/EXAMPLES/#basic-usage","title":"Basic Usage","text":"<pre><code>require \"cov_loupe\"\n\nroot = \"docs/fixtures/demo_project\"\nmodel = CovLoupe::CoverageModel.new(root: root)\n\n# Project totals\ntotals = model.project_totals\nputs \"Total files: #{totals['files']['total']}\"\nputs \"Average coverage: #{totals['lines']['percent_covered']}%\"\n\n# Check specific file\nsummary = model.summary_for(\"app/models/order.rb\")\nputs \"Coverage: #{summary['summary']['percentage']}%\"\n\n# Find uncovered lines\nuncovered = model.uncovered_for(\"lib/payments/refund_service.rb\")\nputs \"Uncovered lines: #{uncovered['uncovered'].join(', ')}\"\n</code></pre>"},{"location":"user/EXAMPLES/#filtering-and-analysis","title":"Filtering and Analysis","text":"<pre><code>require \"cov_loupe\"\n\nroot = \"docs/fixtures/demo_project\"\nmodel = CovLoupe::CoverageModel.new(root: root)\nlist = model.list['files']\n\n# Find files below threshold\nTHRESHOLD = 80.0\nlow_coverage = list.select { |f| f['percentage'] &lt; THRESHOLD }\n\nif low_coverage.any?\n  puts \"Files below #{THRESHOLD}%:\"\n  low_coverage.each do |file|\n    puts \"  #{file['file']}: #{file['percentage']}%\"\n  end\nend\n\n# Group by directory using totals command logic\ndirs = %w[app lib lib/payments lib/ops/jobs].uniq\ndirs.each do |dir|\n  pattern = File.join(dir, '**/*.rb')\n  totals = model.project_totals(tracked_globs: pattern)\n  puts \"#{dir}: #{totals['lines']['percent_covered'].round(2)}% (#{totals['files']['total']} files)\"\nend\n</code></pre>"},{"location":"user/EXAMPLES/#custom-formatting","title":"Custom Formatting","text":"<pre><code>require \"cov_loupe\"\nrequire \"pathname\"\n\nroot = \"docs/fixtures/demo_project\"\nmodel = CovLoupe::CoverageModel.new(root: root)\nlist = model.list['files']\n\n# Filter to lib/payments (coverage data stores absolute paths)\nlib_root = File.expand_path(\"lib/payments\", File.expand_path(root, Dir.pwd))\nlib_files = list.select { |f| f['file'].start_with?(lib_root) }\n\n# Generate custom table\ntable = model.format_table(lib_files, sort_order: :ascending)\nputs table\n\n# Or create your own format\nlib_files.each do |file|\n  status = file['percentage'] &gt;= 90 ? '\u2713' : '\u26a0'\n  relative_path = Pathname.new(file['file']).relative_path_from(Pathname.pwd)\n  puts \"#{status} #{relative_path}: #{file['percentage']}%\"\nend\n</code></pre>"},{"location":"user/EXAMPLES/#ai-assistant-prompts","title":"AI Assistant Prompts","text":""},{"location":"user/EXAMPLES/#coverage-analysis_1","title":"Coverage Analysis","text":"<p>\"Using cov-loupe, show me a table of all files sorted by coverage percentage.\"</p> <p>\"Using cov-loupe, find the 10 files with the lowest coverage and create a markdown report with: 1. File path 2. Current coverage % 3. Number of uncovered lines\"</p> <p>\"Using cov-loupe, analyze the lib/payments/ directory and identify which files should be prioritized for additional testing based on coverage gaps and file complexity.\"</p>"},{"location":"user/EXAMPLES/#finding-specific-issues","title":"Finding Specific Issues","text":"<p>\"Using cov-loupe, show me the uncovered lines in app/controllers/orders_controller.rb with 5 lines of context around each uncovered block.\"</p> <p>\"Using cov-loupe, find all files in lib/payments/ with less than 80% coverage and list the specific uncovered line numbers for each.\"</p>"},{"location":"user/EXAMPLES/#test-generation","title":"Test Generation","text":"<p>\"Using cov-loupe, identify the uncovered lines in lib/ops/jobs/report_job.rb and write meaningful RSpec tests to cover them.\"</p> <p>\"Using cov-loupe, analyze coverage gaps in the app/controllers/ directory and generate a test plan prioritizing: 1. Public API methods 2. Error handling paths 3. Edge cases\"</p>"},{"location":"user/EXAMPLES/#reporting","title":"Reporting","text":"<p>\"Using cov-loupe, create a coverage report showing: - Overall project coverage percentage - Top 5 files with worst coverage - Recommended next steps to improve coverage</p> <p>Format as markdown.\"</p>"},{"location":"user/EXAMPLES/#test-run-integration","title":"Test Run Integration","text":""},{"location":"user/EXAMPLES/#display-low-coverage-files","title":"Display Low Coverage Files","text":"<p>Add this to your <code>spec/spec_helper.rb</code> to automatically report files below a coverage threshold after each test run:</p> <pre><code>require 'simplecov'\nSimpleCov.start do\n  add_filter %r{^/spec/}\n  track_files 'lib/**/*.rb'  # Ensures new/untested files show up with 0%\nend\n\n# Report lowest coverage files at the end of the test run\nSimpleCov.at_exit do\n  SimpleCov.result.format!\n  require 'cov_loupe'\n  report = CovLoupe::CoverageReporter.report(threshold: 80, count: 5)\n  puts report if report\nend\n</code></pre> <p>This produces output like:</p> <pre><code>Lowest coverage files (&lt; 80%):\n    0.0%  lib/myapp/config_parser.rb\n   19.3%  lib/myapp/formatters/source_formatter.rb\n   24.0%  lib/myapp/model.rb\n   26.0%  lib/myapp/cli.rb\n   45.2%  lib/myapp/commands/base.rb\n</code></pre> <p>Parameters: - <code>threshold:</code> - Coverage percentage below which files are included (default: 80) - <code>count:</code> - Maximum number of files to show (default: 5) - <code>root:</code> - Project root directory (defaults to <code>SimpleCov.root</code> when SimpleCov is loaded, otherwise <code>'.'</code>) - <code>resultset:</code> - Path or directory to <code>.resultset.json</code> (defaults to <code>SimpleCov.coverage_dir/.resultset.json</code> when SimpleCov is loaded) - <code>model:</code> - Pre-configured <code>CoverageModel</code> instance (optional, overrides <code>root:</code>/<code>resultset:</code>)</p> <p>Returns: Formatted string, or <code>nil</code> if no files are below the threshold.</p> <p>SimpleCov Integration: When SimpleCov is loaded, <code>CoverageReporter.report</code> automatically uses SimpleCov's configured root and coverage directory. You can override these by passing explicit <code>root:</code> or <code>resultset:</code> parameters, or provide a custom <code>model:</code> instance.</p>"},{"location":"user/EXAMPLES/#custom-coverage-directory","title":"Custom Coverage Directory","text":"<p>If your project uses a custom coverage directory:</p> <pre><code>require 'simplecov'\nSimpleCov.start do\n  add_filter %r{^/spec/}\n  coverage_dir 'reports/coverage'  # Custom coverage directory\n  track_files 'lib/**/*.rb'\nend\n\nSimpleCov.at_exit do\n  SimpleCov.result.format!\n  require 'cov_loupe'\n\n  # CoverageReporter will automatically find the coverage in reports/coverage\n  report = CovLoupe::CoverageReporter.report(threshold: 80, count: 5)\n  puts report if report\nend\n</code></pre> <p>Or specify the resultset path explicitly:</p> <pre><code>report = CovLoupe::CoverageReporter.report(\n  threshold: 80,\n  count: 5,\n  resultset: 'reports/coverage/.resultset.json'\n)\n</code></pre>"},{"location":"user/EXAMPLES/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"user/EXAMPLES/#github-actions","title":"GitHub Actions","text":"<p>Fail on low coverage (Cross-Platform): <pre><code>name: Coverage Check\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        ruby-version: ['3.4']\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup Ruby\n        uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: ${{ matrix.ruby-version }}\n          bundler-cache: true\n\n      - name: Run tests\n        run: bundle exec rspec\n\n      - name: Install cov-loupe\n        run: gem install cov-loupe\n\n      - name: Check coverage threshold\n        shell: bash\n        run: |\n          # Generate JSON report using the full command (aliases like 'clp' are not available here)\n          cov-loupe -fJ list &gt; coverage.json\n\n          # Verify coverage using Ruby for cross-platform compatibility\n          # (Tools like jq and rexe are not guaranteed to be installed on all runners)\n          ruby -r json -e '\n            data = JSON.parse(File.read(\"coverage.json\"))\n            files = data[\"files\"]\n            low_cov_files = files.select { |f| f[\"percentage\"] &lt; 80 }\n\n            if low_cov_files.any?\n              puts \"\u274c #{low_cov_files.count} files below 80% coverage:\"\n              low_cov_files.each do |f|\n                puts \"  #{f[\"percentage\"]}% #{f[\"file\"]}\"\n              end\n              exit 1\n            end\n            puts \"\u2713 All files meet coverage threshold\"\n          '\n\n      - name: Upload coverage report\n        # Saves the coverage file as an artifact so you can download/inspect it \n        # from the GitHub Actions run summary page.\n        uses: actions/upload-artifact@v4\n        if: always()\n        with:\n          name: coverage-report-${{ matrix.os }}\n          path: coverage.json\n</code></pre></p> <p>Check for stale coverage: <pre><code>      - name: Verify coverage is fresh\n        shell: bash\n        run: cov-loupe --raise-on-stale true list || exit 1\n</code></pre></p>"},{"location":"user/EXAMPLES/#gitlab-ci","title":"GitLab CI","text":"<pre><code>test:\n  image: ruby:3.4\n  before_script:\n    - gem install cov-loupe\n  script:\n    - bundle exec rspec\n    - cov-loupe --raise-on-stale true list\n  artifacts:\n    paths:\n      - coverage/\n    reports:\n      coverage_report:\n        coverage_format: simplecov\n        path: coverage/.resultset.json\n</code></pre>"},{"location":"user/EXAMPLES/#custom-success-predicate","title":"Custom Success Predicate","text":"<pre><code># coverage_policy.rb\n-&gt;(model) do\n  list = model.list['files']\n\n  # Must have at least 80% average coverage\n  totals = model.project_totals\n  return false if totals['lines']['percent_covered'] &lt; 80.0\n\n  # No files below 60%\n  return false if list.any? { |f| f['percentage'] &lt; 60.0 }\n\n  # lib/ files must average 90%\n  lib_totals = model.project_totals(tracked_globs: ['lib/**/*.rb'])\n  return false if lib_totals['lines']['percent_covered'] &lt; 90.0\n\n  true\nend\n</code></pre> <pre><code># Use in CI\ncov-loupe validate coverage_policy.rb\n</code></pre>"},{"location":"user/EXAMPLES/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user/EXAMPLES/#directory-level-analysis","title":"Directory-Level Analysis","text":"<pre><code>require \"cov_loupe\"\n\nroot = \"docs/fixtures/demo_project\"\nmodel = CovLoupe::CoverageModel.new(root: root)\n\n# Calculate coverage by directory (uses the same data as `cov-loupe totals`)\npatterns = %w[\n  app/**/*.rb\n  lib/payments/**/*.rb\n  lib/ops/jobs/**/*.rb\n]\n\nresults = patterns.map do |pattern|\n  totals = model.project_totals(tracked_globs: pattern)\n\n  {\n    directory: pattern,\n    files: totals['files']['total'],\n    coverage: totals['lines']['percent_covered'].round(2),\n    covered: totals['lines']['covered'],\n    total: totals['lines']['total']\n  }\nend\n\n# Sort by coverage ascending\nresults.sort_by { |r| r[:coverage] }.each do |r|\n  puts \"#{r[:directory]}: #{r[:coverage]}% (#{r[:files]} files)\"\nend\n</code></pre>"},{"location":"user/EXAMPLES/#integration-with-code-review","title":"Integration with Code Review","text":"<pre><code># pr_coverage_check.rb\nrequire \"cov_loupe\"\nrequire \"json\"\n\nmodel = CovLoupe::CoverageModel.new\n\n# Get changed files from PR (example using git)\nchanged_files = `git diff --name-only origin/main`.split(\"\\n\")\nchanged_files.select! { |f| f.end_with?('.rb') }\n\nputs \"## Coverage Report for Changed Files\\n\\n\"\nputs \"| File | Coverage | Status |\"\nputs \"|------|----------|--------|\"\n\nchanged_files.each do |file|\n  begin\n    summary = model.summary_for(file)\n    percentage = summary['summary']['percentage']\n    status = percentage &gt;= 80 ? '\u2705' : '\u26a0\ufe0f'\n    puts \"| #{file} | #{percentage}% | #{status} |\"\n  rescue\n    puts \"| #{file} | N/A | \u274c No coverage |\"\n  end\nend\n</code></pre>"},{"location":"user/EXAMPLES/#example-scripts","title":"Example Scripts","text":"<p>The <code>examples/</code> directory contains runnable scripts:</p> <ul> <li>filter_and_table_demo.rb - Filter and format coverage data (in <code>examples/</code> directory)</li> <li>success_predicates - Custom coverage policy examples</li> <li>Coverage Delta Tracking recipe in the Library API Guide</li> </ul>"},{"location":"user/EXAMPLES/#related-documentation","title":"Related Documentation","text":"<ul> <li>CLI Usage Guide - Complete command reference</li> <li>Library API Guide - Ruby API documentation</li> <li>MCP Integration - AI assistant setup</li> <li>Troubleshooting - Common issues</li> </ul>"},{"location":"user/INSTALLATION/","title":"Installation Guide","text":"<p>Back to main README</p>"},{"location":"user/INSTALLATION/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ruby &gt;= 3.2 (required by the <code>mcp</code> dependency)</li> <li>SimpleCov-generated <code>.resultset.json</code> file in your project</li> </ul>"},{"location":"user/INSTALLATION/#quick-install","title":"Quick Install","text":""},{"location":"user/INSTALLATION/#via-rubygems","title":"Via RubyGems","text":"<pre><code>gem install cov-loupe\n</code></pre>"},{"location":"user/INSTALLATION/#via-bundler","title":"Via Bundler","text":"<p>Add to your <code>Gemfile</code>:</p> <pre><code>gem 'cov-loupe'\n</code></pre> <p>Then run:</p> <pre><code>bundle install\n</code></pre>"},{"location":"user/INSTALLATION/#prerelease-versions","title":"Prerelease Versions","text":"<p>See Installing a Prerelease for instructions on installing prerelease versions.</p>"},{"location":"user/INSTALLATION/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/keithrbennett/cov-loupe.git\ncd cov-loupe\nbundle install\ngem build cov-loupe.gemspec\ngem install cov-loupe-*.gem\n</code></pre>"},{"location":"user/INSTALLATION/#require-path","title":"Require Path","text":"<p>The gem uses a single require path:</p> <pre><code>require \"cov_loupe\"\n</code></pre> <p>The executable is <code>cov-loupe</code> (with hyphen).</p>"},{"location":"user/INSTALLATION/#verification","title":"Verification","text":""},{"location":"user/INSTALLATION/#test-installation","title":"Test Installation","text":"<pre><code># Check version\ncov-loupe version\n\n# Show help\ncov-loupe --help\n\n# Run on current project (requires coverage data)\ncov-loupe\n</code></pre>"},{"location":"user/INSTALLATION/#generate-test-coverage","title":"Generate Test Coverage","text":"<p>If you don't have coverage data yet:</p> <pre><code># Run your tests with SimpleCov enabled\nbundle exec rspec  # or your test command\n\n# Verify coverage file exists\nls -l coverage/.resultset.json\n\n# Now test cov-loupe\ncov-loupe\n</code></pre>"},{"location":"user/INSTALLATION/#platform-specific-notes","title":"Platform-Specific Notes","text":""},{"location":"user/INSTALLATION/#macos","title":"macOS","text":"<p>Works with system Ruby or any version manager. Recommended: use rbenv or asdf, not rvm (see note below).</p> <p>Note: RVM may not work in sandboxed environments (e.g., AI coding assistants) because it requires <code>/bin/ps</code>, which sandbox restrictions often block. Use rbenv or chruby instead for sandboxed environments.</p>"},{"location":"user/INSTALLATION/#linux","title":"Linux","text":"<p>Works with system Ruby or any version manager.</p>"},{"location":"user/INSTALLATION/#windows","title":"Windows","text":"<p>Should work with Ruby installed via RubyInstaller. PATH configuration may differ.</p>"},{"location":"user/INSTALLATION/#upgrading","title":"Upgrading","text":"<p>If you are upgrading from an earlier version of <code>cov-loupe</code>, please check the migration guides:</p> <ul> <li>Migrating to v4</li> <li>Migrating to v3</li> <li>Migrating to v2</li> </ul>"},{"location":"user/INSTALLATION/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Usage - Learn command-line options</li> <li>Library API - Use in Ruby code</li> <li>MCP Integration - Connect to AI assistants</li> <li>Troubleshooting - More detailed troubleshooting</li> </ul>"},{"location":"user/LIBRARY_API/","title":"Library API Guide","text":"<p>Back to main README</p> <p>Use this gem programmatically to inspect coverage without running the CLI or MCP server. The primary entry point is <code>CovLoupe::CoverageModel</code>.</p>"},{"location":"user/LIBRARY_API/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Start</li> <li>Method Reference</li> <li>Return Types</li> <li>Error Handling</li> <li>Advanced Recipes</li> </ul>"},{"location":"user/LIBRARY_API/#quick-start","title":"Quick Start","text":"<pre><code>require \"cov_loupe\"\n\n# Defaults (omit args; shown here with comments):\n# - root: \".\"\n# - resultset: resolved from common paths under root\n# - raise_on_stale: false (don't raise on stale data)\n# - tracked_globs: [] (no project-level file-set checks)\nmodel = CovLoupe::CoverageModel.new\n\n# Custom configuration (non-default values):\nmodel = CovLoupe::CoverageModel.new(\n  root: File.join(Dir.home, 'project'),          # non-default project root\n  resultset: \"build/coverage\",                   # file or directory containing .resultset.json\n  raise_on_stale: true,                          # enable strict staleness checks (raise on stale)\n  tracked_globs: [\"lib/cov_loupe/tools/**/*.rb\"] # for 'list' staleness: flag new/missing files\n)\n\n# List all files with coverage summary\nlist_result = model.list\nfiles = list_result['files']\n# Per-file queries\n\ntarget = 'lib/cov_loupe/base_tool.rb'\nsummary = model.summary_for(target)\nuncovered = model.uncovered_for(target)\ndetailed = model.detailed_for(target)\nraw = model.raw_for(target)\n</code></pre>"},{"location":"user/LIBRARY_API/#method-reference","title":"Method Reference","text":""},{"location":"user/LIBRARY_API/#listsort_order-descending-raise_on_stale-nil-tracked_globs","title":"<code>list(sort_order: :descending, raise_on_stale: nil, tracked_globs: [])</code>","text":"<p>Returns coverage summary for all files in the resultset.</p> <p>Parameters: - <code>sort_order</code> (Symbol, optional): <code>:descending</code> (default) or <code>:ascending</code> by coverage percentage - <code>raise_on_stale</code> (Boolean, optional): Whether to raise error if project is stale. Defaults to model setting. - <code>tracked_globs</code> (Array, optional): Patterns to filter files (also used for staleness checks) <p>Returns: <code>Hash</code> - See list return type</p> <p>Example: <pre><code>list_result = model.list\nfiles = list_result['files']\n# =&gt; [ { 'file' =&gt; '/abs/path/lib/foo.rb', 'covered' =&gt; 12, 'total' =&gt; 14, 'percentage' =&gt; 85.71, 'stale' =&gt; \"ok\" }, ... ]\n\n# Get worst coverage first\nworst_files = model.list(sort_order: :ascending)['files'].first(10)\n\n# Force staleness check\nmodel.list(raise_on_stale: true)\n</code></pre></p>"},{"location":"user/LIBRARY_API/#summary_forpath","title":"<code>summary_for(path)</code>","text":"<p>Returns coverage summary for a specific file.</p> <p>Parameters: - <code>path</code> (String): File path (absolute or relative to root)</p> <p>Returns: <code>Hash</code> - See summary_for return type</p> <p>Raises: <code>CovLoupe::FileError</code> if file not in coverage data</p> <p>Example: <pre><code>summary = model.summary_for(target)\n# =&gt; { 'file' =&gt; '/abs/.../lib/foo.rb', 'summary' =&gt; {'covered'=&gt;12, 'total'=&gt;14, 'percentage'=&gt;85.71} }\n</code></pre></p>"},{"location":"user/LIBRARY_API/#uncovered_forpath","title":"<code>uncovered_for(path)</code>","text":"<p>Returns list of uncovered line numbers for a specific file.</p> <p>Parameters: - <code>path</code> (String): File path (absolute or relative to root)</p> <p>Returns: <code>Hash</code> - See uncovered_for return type</p> <p>Raises: <code>CovLoupe::FileError</code> if file not in coverage data</p> <p>Example: <pre><code>uncovered = model.uncovered_for(\"lib/foo.rb\")\n# =&gt; { 'file' =&gt; '/abs/.../lib/foo.rb', 'uncovered' =&gt; [5, 9, 12], 'summary' =&gt; { ... } }\n</code></pre></p>"},{"location":"user/LIBRARY_API/#detailed_forpath","title":"<code>detailed_for(path)</code>","text":"<p>Returns per-line coverage details with hit counts.</p> <p>Parameters: - <code>path</code> (String): File path (absolute or relative to root)</p> <p>Returns: <code>Hash</code> - See detailed_for return type</p> <p>Raises: <code>CovLoupe::FileError</code> if file not in coverage data</p> <p>Example: <pre><code>detailed = model.detailed_for(\"lib/foo.rb\")\n# =&gt; { 'file' =&gt; '/abs/.../lib/foo.rb', 'lines' =&gt; [{'line' =&gt; 1, 'hits' =&gt; 1, 'covered' =&gt; true}, ...], 'summary' =&gt; { ... } }\n</code></pre></p>"},{"location":"user/LIBRARY_API/#raw_forpath","title":"<code>raw_for(path)</code>","text":"<p>Returns raw SimpleCov lines array for a specific file.</p> <p>Parameters: - <code>path</code> (String): File path (absolute or relative to root)</p> <p>Returns: <code>Hash</code> - See raw_for return type</p> <p>Raises: <code>CovLoupe::FileError</code> if file not in coverage data</p> <p>Example: <pre><code>raw = model.raw_for(\"lib/foo.rb\")\n# =&gt; { 'file' =&gt; '/abs/.../lib/foo.rb', 'lines' =&gt; [nil, 1, 0, 3, ...] }\n</code></pre></p>"},{"location":"user/LIBRARY_API/#format_tablerows-nil-sort_order-descending-raise_on_stale-nil-tracked_globs-nil","title":"<code>format_table(rows = nil, sort_order: :descending, raise_on_stale: nil, tracked_globs: nil)</code>","text":"<p>Generates formatted ASCII table string.</p> <p>Parameters: - <code>rows</code> (Array, optional): Custom row data; defaults to <code>list</code> - <code>sort_order</code> (Symbol, optional): <code>:descending</code> (default) or <code>:ascending</code> - <code>raise_on_stale</code> (Boolean, optional): Whether to raise error if project is stale. Defaults to model setting. - <code>tracked_globs</code> (Array, optional): Patterns to filter files. <p>Returns: <code>String</code> - Formatted table with Unicode borders</p> <p>Example: <pre><code># Default: all files\ntable = model.format_table\nputs table\n\n# Custom rows\nlib_files = model.list['files'].select { |f| f['file'].include?('/lib/') }\nlib_table = model.format_table(lib_files, sort_order: :descending)\nputs lib_table\n</code></pre></p>"},{"location":"user/LIBRARY_API/#project_totalstracked_globs-raise_on_stale-nil","title":"<code>project_totals(tracked_globs: [], raise_on_stale: nil)</code>","text":"<p>Returns aggregated coverage totals across all files.</p> <p>Parameters: - <code>tracked_globs</code> (Array or String, optional): Glob patterns to filter files - <code>raise_on_stale</code> (Boolean, optional): Whether to raise error if project is stale. Defaults to model setting. <p>Returns: <code>Hash</code> - See project_totals return type</p> <p>Example: <pre><code>totals = model.project_totals\n# =&gt; {\n#      'lines' =&gt; { 'total' =&gt; 123, 'covered' =&gt; 100, 'uncovered' =&gt; 23, 'percent_covered' =&gt; 81.3 },\n#      'tracking' =&gt; { 'enabled' =&gt; true, 'globs' =&gt; ['lib/**/*.rb'] },\n#      'files' =&gt; { 'total' =&gt; 4, 'with_coverage' =&gt; { 'total' =&gt; 4, 'ok' =&gt; 4, 'stale' =&gt; { ... } } }\n#    }\n\n# Filter to specific directory\nlib_totals = model.project_totals(tracked_globs: 'lib/**/*.rb')\n</code></pre></p> <p>When <code>raise_on_stale: true</code> is set, the method raises on stale coverage instead of returning totals. Otherwise, totals exclude stale files (<code>M</code>, <code>T</code>, <code>L</code>, <code>E</code>) from line counts and report stale breakdowns under <code>files['with_coverage']['stale']</code>.</p> <p>Note: The <code>without_coverage</code> hash will only be present if <code>tracked_globs</code> were specified.</p>"},{"location":"user/LIBRARY_API/#relativizedata","title":"<code>relativize(data)</code>","text":"<p>Converts absolute file paths in coverage data to relative paths from project root.</p> <p>Parameters: - <code>data</code> (Hash or Array): Coverage data with absolute file paths <p>Returns: <code>Hash</code> or <code>Array&lt;Hash&gt;</code> - Same structure with relative paths</p> <p>Example: <pre><code>summary = model.summary_for('lib/cov_loupe/model.rb')\n# =&gt; { 'file' =&gt; '/path/to/project/lib/cov_loupe/model.rb', ... }\n\nrelative_summary = model.relativize(summary)\n# =&gt; { 'file' =&gt; 'lib/cov_loupe/model.rb', ... }\n\n# Works with arrays too\nlist_result = model.list\nfiles = list_result['files']\nrelative_files = model.relativize(files)\n</code></pre></p>"},{"location":"user/LIBRARY_API/#return-types","title":"Return Types","text":""},{"location":"user/LIBRARY_API/#list","title":"<code>list</code>","text":"<p>Returns <code>Hash</code> with file data and staleness metadata:</p> <pre><code>{\n  'files' =&gt; [\n    {\n      'file' =&gt; String,       # Absolute file path\n      'covered' =&gt; Integer,   # Number of covered lines\n      'total' =&gt; Integer,     # Total relevant lines\n      'percentage' =&gt; Float,  # Coverage percentage (0.00-100.00)\n      'stale' =&gt; String  # Staleness indicator: \"ok\", \"error\", \"missing\", \"newer\", or \"length_mismatch\"\n    }\n  ],\n  'skipped_files' =&gt; Array&lt;String&gt;,        # Files skipped due to coverage errors\n  'missing_tracked_files' =&gt; Array&lt;String&gt;,# Tracked files missing from coverage\n  'newer_files' =&gt; Array&lt;String&gt;,          # Files newer than coverage\n  'deleted_files' =&gt; Array&lt;String&gt;,        # Coverage entries for deleted files\n  'length_mismatch_files' =&gt; Array&lt;String&gt;,# Files whose line counts differ from coverage\n  'unreadable_files' =&gt; Array&lt;String&gt;      # Files that could not be read\n}\n</code></pre>"},{"location":"user/LIBRARY_API/#summary_for","title":"<code>summary_for</code>","text":"<p>Returns <code>Hash</code>:</p> <pre><code>{\n  'file' =&gt; String,       # Absolute file path\n  'summary' =&gt; {\n    'covered' =&gt; Integer, # Number of covered lines\n    'total' =&gt; Integer,   # Total relevant lines\n    'percentage' =&gt; Float        # Coverage percentage (0.00-100.00)\n  }\n}\n</code></pre>"},{"location":"user/LIBRARY_API/#uncovered_for","title":"<code>uncovered_for</code>","text":"<p>Returns <code>Hash</code>:</p> <pre><code>{\n  'file' =&gt; String,       # Absolute file path\n  'uncovered' =&gt; Array&lt;Integer&gt;,  # Line numbers that are not covered\n  'summary' =&gt; {\n    'covered' =&gt; Integer,\n    'total' =&gt; Integer,\n    'percentage' =&gt; Float\n  }\n}\n</code></pre>"},{"location":"user/LIBRARY_API/#detailed_for","title":"<code>detailed_for</code>","text":"<p>Returns <code>Hash</code>:</p> <pre><code>{\n  'file' =&gt; String,       # Absolute file path\n  'lines' =&gt; Array&lt;Hash&gt;, # Per-line coverage details\n  'summary' =&gt; {\n    'covered' =&gt; Integer,\n    'total' =&gt; Integer,\n    'percentage' =&gt; Float\n  }\n}\n</code></pre> <p>Each element in <code>lines</code> array: <pre><code>{\n  'line' =&gt; Integer,    # Line number (1-indexed)\n  'hits' =&gt; Integer,    # Execution count (0 means not covered)\n  'covered' =&gt; Boolean  # true if hits &gt; 0\n}\n</code></pre></p>"},{"location":"user/LIBRARY_API/#raw_for","title":"<code>raw_for</code>","text":"<p>Returns <code>Hash</code>:</p> <pre><code>{\n  'file' =&gt; String,              # Absolute file path\n  'lines' =&gt; Array&lt;Integer | nil&gt;   # SimpleCov lines array (nil = irrelevant, 0 = uncovered, &gt;0 = hit count)\n}\n</code></pre>"},{"location":"user/LIBRARY_API/#project_totals","title":"<code>project_totals</code>","text":"<p>Returns <code>Hash</code>:</p> <pre><code>{\n  'lines' =&gt; {\n    'total' =&gt; Integer,            # Total relevant lines across all files\n    'covered' =&gt; Integer,          # Total covered lines\n    'uncovered' =&gt; Integer,        # Total uncovered lines\n    'percent_covered' =&gt; Float     # Overall percent covered\n  },\n  'tracking' =&gt; {\n    'enabled' =&gt; Boolean,          # Whether tracked_globs are active\n    'globs' =&gt; Array&lt;String&gt;       # Active tracked globs (empty when disabled)\n  },\n  'files' =&gt; {\n    'total' =&gt; Integer,          # Total number of files (with + without coverage)\n    'with_coverage' =&gt; {\n      'total' =&gt; Integer,        # Files with coverage entries\n      'ok' =&gt; Integer,           # Fresh coverage entries\n      'stale' =&gt; {\n        'total' =&gt; Integer,      # Stale coverage entries\n        'by_type' =&gt; {\n          'missing_from_disk' =&gt; Integer,\n          'newer' =&gt; Integer,\n          'length_mismatch' =&gt; Integer,\n          'unreadable' =&gt; Integer\n        }\n      }\n    },\n    'without_coverage' =&gt; {\n      'total' =&gt; Integer,        # Tracked files missing coverage entries\n      'by_type' =&gt; {\n        'missing_from_coverage' =&gt; Integer,\n        'unreadable' =&gt; Integer,\n        'skipped' =&gt; Integer\n      }\n    }\n  }\n}\n</code></pre> <p>Note: The <code>without_coverage</code> hash will only be present if <code>tracked_globs</code> were specified.</p>"},{"location":"user/LIBRARY_API/#error-handling","title":"Error Handling","text":""},{"location":"user/LIBRARY_API/#exception-types","title":"Exception Types","text":"<p>The library raises these custom exceptions:</p> <ul> <li><code>CovLoupe::ResultsetNotFoundError</code> - Coverage data file not found</li> <li><code>CovLoupe::FileError</code> - Requested file not in coverage data</li> <li><code>CovLoupe::CoverageDataStaleError</code> - Coverage data is stale (only when <code>raise_on_stale: true</code>)</li> <li><code>CovLoupe::CoverageDataError</code> - Invalid coverage data format or structure</li> </ul> <p>All exceptions inherit from <code>CovLoupe::Error</code>.</p>"},{"location":"user/LIBRARY_API/#basic-error-handling","title":"Basic Error Handling","text":"<pre><code>require \"cov_loupe\"\n\nbegin\n  model = CovLoupe::CoverageModel.new\n  summary = model.summary_for(\"lib/foo.rb\")\n  puts \"Coverage: #{summary['summary']['percentage']}%\"\nrescue CovLoupe::FileError =&gt; e\n  puts \"File not in coverage data: #{e.message}\"\nrescue CovLoupe::ResultsetNotFoundError =&gt; e\n  puts \"Coverage data not found: #{e.message}\"\n  puts \"Run your tests first: bundle exec rspec\"\nrescue CovLoupe::Error =&gt; e\n  puts \"Coverage error: #{e.message}\"\nend\n</code></pre>"},{"location":"user/LIBRARY_API/#handling-stale-coverage","title":"Handling Stale Coverage","text":"<pre><code># Option 1: Check staleness without raising\nmodel = CovLoupe::CoverageModel.new(raise_on_stale: false)\nfiles = model.list['files']\n\nstale_files = files.select { |f| f['stale'] }\nif stale_files.any?\n  puts \"Warning: #{stale_files.length} files have stale coverage\"\n  stale_files.each do |f|\n    puts \"  #{f['file']}: #{f['stale']}\"\n  end\nend\n\n# Option 2: Raise on staleness\nbegin\n  model = CovLoupe::CoverageModel.new(raise_on_stale: true)\n  files = model.list['files']\nrescue CovLoupe::CoverageDataStaleError =&gt; e\n  puts \"Stale coverage detected: #{e.message}\"\n  puts \"Re-run tests: bundle exec rspec\"\n  exit 1\nend\n</code></pre>"},{"location":"user/LIBRARY_API/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code># Try multiple file paths\ndef find_coverage(model, possible_paths)\n  possible_paths.each do |path|\n    begin\n      return model.summary_for(path)\n    rescue CovLoupe::FileError\n      next\n    end\n  end\n  nil\nend\n\nsummary = find_coverage(model, [\n  \"lib/services/auth_service.rb\",\n  \"app/services/auth_service.rb\",\n  \"services/auth_service.rb\"\n])\n\nif summary\n  puts \"Coverage: #{summary['summary']['percentage']}%\"\nelse\n  puts \"File not found in coverage data\"\nend\n</code></pre>"},{"location":"user/LIBRARY_API/#advanced-recipes","title":"Advanced Recipes","text":""},{"location":"user/LIBRARY_API/#batch-file-analysis","title":"Batch File Analysis","text":"<pre><code>require \"cov_loupe\"\n\nmodel = CovLoupe::CoverageModel.new\n\n# Analyze multiple files efficiently\nfiles_to_check = [\n  \"lib/auth_service.rb\",\n  \"lib/payment_processor.rb\",\n  \"lib/user_manager.rb\"\n]\n\nresults = files_to_check.map do |path|\n  begin\n    summary = model.summary_for(path)\n    {\n      file: path,\n      coverage: summary['summary']['percentage'],\n      status: summary['summary']['percentage'] &gt;= 80 ? :ok : :low\n    }\n  rescue CovLoupe::FileError\n    {\n      file: path,\n      coverage: nil,\n      status: :missing\n    }\n  end\nend\n\n# Report\nresults.each do |r|\n  status_icon = { ok: '\u2713', low: '\u26a0', missing: '\u2717' }[r[:status]]\n  puts \"#{status_icon} #{r[:file]}: #{r[:coverage] || 'N/A'}%\"\nend\n</code></pre>"},{"location":"user/LIBRARY_API/#coverage-threshold-validation","title":"Coverage Threshold Validation","text":"<pre><code>require \"cov_loupe\"\n\nclass CoverageValidator\n  THRESHOLDS = {\n    'lib/api/' =&gt; 90.0,         # API layer needs 90%+\n    'app/models/' =&gt; 85.0,      # Models need 85%+\n    'app/controllers/' =&gt; 75.0, # Controllers need 75%+\n  }\n\n  def initialize(model)\n    @model = model\n  end\n\n  def validate!\n    files = @model.list['files']\n    failures = []\n\n    files.each do |file|\n      threshold = threshold_for(file['file'])\n      next unless threshold\n\n      if file['percentage'] &lt; threshold\n        failures &lt;&lt; {\n          file: file['file'],\n          actual: file['percentage'],\n          required: threshold,\n          gap: threshold - file['percentage']\n        }\n      end\n    end\n\n    if failures.any?\n      puts \"\u274c #{failures.length} files below coverage threshold:\"\n      failures.sort_by { |f| -f[:gap] }.each do |f|\n        puts \"  #{f[:file]}: #{f[:actual]}% (need #{f[:required]}%)\"\n      end\n      exit 1\n    else\n      puts \"\u2713 All files meet coverage thresholds\"\n    end\n  end\n\n  private\n\n  def threshold_for(path)\n    THRESHOLDS.each do |prefix, threshold|\n      return threshold if path.include?(prefix)\n    end\n    nil\n  end\nend\n\nmodel = CovLoupe::CoverageModel.new\nvalidator = CoverageValidator.new(model)\nvalidator.validate!\n</code></pre>"},{"location":"user/LIBRARY_API/#directory-level-aggregation","title":"Directory-Level Aggregation","text":"<pre><code>require \"cov_loupe\"\n\nmodel = CovLoupe::CoverageModel.new\n\n# Calculate coverage by directory using the totals API\npatterns = %w[lib/cov_loupe/tools/**/*.rb lib/cov_loupe/commands/**/*.rb lib/cov_loupe/presenters/**/*.rb]\n\ndirectory_stats = patterns.map do |pattern|\n  totals = model.project_totals(tracked_globs: pattern)\n\n  {\n    directory: pattern,\n    files: totals['files']['total'],\n    coverage: totals['lines']['percent_covered'].round(2),\n    covered: totals['lines']['covered'],\n    total: totals['lines']['total']\n  }\nend\n\n# Display sorted by coverage\ndirectory_stats.sort_by { |s| s[:coverage] }.each do |stat|\n  puts \"#{stat[:directory]}: #{stat[:coverage]}% (#{stat[:files]} files)\"\nend\n</code></pre>"},{"location":"user/LIBRARY_API/#coverage-delta-tracking","title":"Coverage Delta Tracking","text":"<pre><code>require \"cov_loupe\"\nrequire \"json\"\n\nclass CoverageDeltaTracker\n  def initialize(baseline_path: \"coverage_baseline.json\")\n    @baseline_path = baseline_path\n    @model = CovLoupe::CoverageModel.new\n  end\n\n  def save_baseline\n    current = @model.list['files']\n    File.write(@baseline_path, JSON.pretty_generate(current))\n    puts \"Saved coverage baseline (#{current.length} files)\"\n  end\n\n  def compare\n    unless File.exist?(@baseline_path)\n      puts \"No baseline found. Run save_baseline first.\"\n      return\n    end\n\n    baseline = JSON.parse(File.read(@baseline_path))\n    current = @model.list['files']\n\n    improved = []\n    regressed = []\n\n    current.each do |file|\n      baseline_file = baseline.find { |f| f['file'] == file['file'] }\n      next unless baseline_file\n\n      delta = file['percentage'] - baseline_file['percentage']\n\n      if delta &gt; 0.1\n        improved &lt;&lt; {\n          file: file['file'],\n          before: baseline_file['percentage'],\n          after: file['percentage'],\n          delta: delta\n        }\n      elsif delta &lt; -0.1\n        regressed &lt;&lt; {\n          file: file['file'],\n          before: baseline_file['percentage'],\n          after: file['percentage'],\n          delta: delta\n        }\n      end\n    end\n\n    if improved.any?\n      puts \"\\n\u2713 Coverage Improvements:\"\n      improved.sort_by { |f| -f[:delta] }.each do |f|\n        puts \"  #{f[:file]}: #{f[:before]}% \u2192 #{f[:after]}% (+#{f[:delta].round(2)}%)\"\n      end\n    end\n\n    if regressed.any?\n      puts \"\\n\u26a0 Coverage Regressions:\"\n      regressed.sort_by { |f| f[:delta] }.each do |f|\n        puts \"  #{f[:file]}: #{f[:before]}% \u2192 #{f[:after]}% (#{f[:delta].round(2)}%)\"\n      end\n    end\n\n    if improved.empty? &amp;&amp; regressed.empty?\n      puts \"No significant coverage changes\"\n    end\n  end\nend\n\n# Usage\ntracker = CoverageDeltaTracker.new\ntracker.save_baseline  # Run before making changes\n# ... make code changes and re-run tests ...\ntracker.compare        # See what changed\n</code></pre>"},{"location":"user/LIBRARY_API/#custom-reporting","title":"Custom Reporting","text":"<pre><code>require \"cov_loupe\"\n\nclass CoverageReporter\n  def initialize(model)\n    @model = model\n  end\n\n  def generate_markdown_report(output_path)\n    files = @model.list['files']\n    totals = @model.project_totals\n\n    # Overall stats\n    overall_percentage = totals['lines']['percent_covered']\n    total_lines = totals['lines']['total']\n    covered_lines = totals['lines']['covered']\n    total_files = totals['files']['total']\n\n    # Files below threshold\n    threshold = 80.0\n    low_coverage = files.select { |file| file['percentage'] &lt; threshold }\n\n    # Build low coverage table\n    low_coverage_section = if low_coverage.any?\n      rows = low_coverage.sort_by { |file| file['percentage'] }.map do |file|\n        uncovered = @model.uncovered_for(file['file'])\n        missing_count = uncovered['uncovered'].length\n        \"| #{file['file']} | #{file['percentage']}% | #{missing_count} |\"\n      end.join(\"\\n\")\n\n      &lt;&lt;~LOW_COVERAGE_TABLE\n\n        ## Files Below #{threshold}% Coverage\n\n        | File | Coverage | Missing Lines |\n        |------|----------|---------------|\n        #{rows}\n      LOW_COVERAGE_TABLE\n    else\n      \"\"\n    end\n\n    # Build top performers table\n    top_rows = files.sort_by { |file| -file['percentage'] }.take(10).map do |file|\n      \"| #{file['file']} | #{file['percentage']}% |\"\n    end.join(\"\\n\")\n\n    # Generate report\n    report = &lt;&lt;~COVERAGE_REPORT\n      # Coverage Report\n\n      Generated: #{Time.now.strftime('%Y-%m-%d %H:%M:%S')}\n\n      ## Overall Coverage: #{overall_percentage}%\n\n      - Total Files: #{total_files}\n      - Total Lines: #{total_lines}\n      - Covered Lines: #{covered_lines}\n      #{low_coverage_section}\n      ## Top 10 Best Covered Files\n\n      | File | Coverage |\n      |------|----------|\n      #{top_rows}\n    COVERAGE_REPORT\n\n    File.write(output_path, report)\n    puts \"Report saved to #{output_path}\"\n  end\nend\n\nmodel = CovLoupe::CoverageModel.new\nreporter = CoverageReporter.new(model)\nreporter.generate_markdown_report(\"coverage_report.md\")\n</code></pre>"},{"location":"user/LIBRARY_API/#per-model-context-advanced","title":"Per-Model Context (Advanced)","text":"<p>By default, all <code>CoverageModel</code> instances share the global context for error handling and logging. For advanced scenarios where you need different models with different logging or error handling configurations in the same process, you can pass a custom context to each model.</p> <pre><code>require \"cov_loupe\"\n\n# Scenario: Analyzing coverage for multiple projects in one script\n\n# Project A: Detailed logging for debugging\ncontext_a = CovLoupe.create_context(\n  error_handler: CovLoupe::ErrorHandlerFactory.for_library,\n  log_target: 'project_a_coverage.log'\n)\n\nmodel_a = CovLoupe::CoverageModel.new(\n  root: '/path/to/project_a',\n  resultset: '/path/to/project_a/coverage/.resultset.json',\n  context: context_a\n)\n\n# Project B: Different log file\ncontext_b = context_a.with(log_target: 'project_b_coverage.log')\n\nmodel_b = CovLoupe::CoverageModel.new(\n  root: '/path/to/project_b',\n  resultset: '/path/to/project_b/coverage/.resultset.json',\n  context: context_b\n)\n\n# Each model logs to its own file\nsummary_a = model_a.summary_for('lib/foo.rb')  # Logs to project_a_coverage.log\nsummary_b = model_b.summary_for('lib/bar.rb')  # Logs to project_b_coverage.log\n\n# You can also change a model's context at runtime\nmodel_a.context = CovLoupe.context  # Switch to global context\n</code></pre> <p>When to use per-model contexts: - Managing coverage for multiple projects in one script - Different error handling strategies per model - Separate log files for different data sources - Testing scenarios requiring isolated configurations</p> <p>Simple use case (most common): <pre><code># For most use cases, just configure the global context once\nCovLoupe.error_handler = CovLoupe::ErrorHandlerFactory.for_library\nCovLoupe.default_log_file = 'coverage_analysis.log'\n\n# All models automatically use the global context\nmodel = CovLoupe::CoverageModel.new\n</code></pre></p>"},{"location":"user/LIBRARY_API/#staleness-detection","title":"Staleness Detection","text":"<p>The <code>list</code> method returns a <code>'stale'</code> field for each file with one of these values:</p> <ul> <li><code>\"ok\"</code> - Coverage data is current</li> <li><code>\"missing\"</code> - Missing: File no longer exists on disk</li> <li><code>\"newer\"</code> - Timestamp: File modified more recently than coverage data</li> <li><code>\"length_mismatch\"</code> - Length: Source file line count differs from coverage data</li> <li><code>\"error\"</code> - Error: Staleness check failed</li> </ul> <p>Note: Per-file methods (<code>summary_for</code>, <code>uncovered_for</code>, <code>detailed_for</code>, <code>raw_for</code>) do not include staleness information in their return values. To check staleness for individual files, use <code>list</code> and filter the results.</p> <p>When <code>raise_on_stale: true</code> is enabled in <code>CoverageModel.new</code>, the model will raise <code>CovLoupe::CoverageDataStaleError</code> exceptions when stale files are detected during method calls.</p>"},{"location":"user/LIBRARY_API/#related-documentation","title":"Related Documentation","text":"<ul> <li>Examples - Practical cookbook-style examples</li> <li>CLI Usage - Command-line interface reference</li> <li>Error Handling - Detailed error handling documentation</li> <li>MCP Integration - AI assistant integration</li> </ul>"},{"location":"user/MCP_INTEGRATION/","title":"MCP Integration Guide","text":"<p>Back to main README</p> <p>\u26a0\ufe0f BREAKING CHANGE (v4.0.0+): The <code>-m/--mode mcp</code> flag is now required to run cov-loupe as an MCP server.  Automatic mode detection based on TTY/stdin has been removed. If you're upgrading from an earlier version, you must update your MCP server configuration to include <code>-m mcp</code> or <code>--mode mcp</code> or the server will run in CLI mode and hang. See Migration Guide for details.</p>"},{"location":"user/MCP_INTEGRATION/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Setup by Client</li> <li>Available MCP Tools</li> <li>Testing Your Setup</li> <li>Troubleshooting</li> </ul>"},{"location":"user/MCP_INTEGRATION/#setup-by-client","title":"Setup by Client","text":"<p>For the <code>mcp add</code> commands, the executable path comes after the server name. You can optionally pass arguments to the executable after that (e.g., <code>-- --error-mode debug</code>).</p> <p>Note: If you change which Ruby version you use, you will need to <code>bundle install</code> or <code>gem install cov-loupe</code> again with the new version active. Additionally, if your MCP server configuration uses an absolute path, that configuration will need to be updated as well.</p>"},{"location":"user/MCP_INTEGRATION/#claude-code","title":"Claude Code","text":"<pre><code># Add the MCP server; equivalent to ...--scope local...\nclaude mcp add cov-loupe cov-loupe -- -m mcp\n\n# For user-wide configuration\nclaude mcp add --scope user cov-loupe cov-loupe -- -m mcp\n\n# For project-specific configuration.\nclaude mcp add --scope project cov-loupe cov-loupe -- -m mcp\n\n# List configured MCP servers\nclaude mcp list\n\n# Get server details\nclaude mcp get cov-loupe\n\n# Remove if needed (use --scope to match where it was added)\nclaude mcp remove cov-loupe                # Removes from local scope (default)\nclaude mcp remove --scope user cov-loupe   # Removes from user scope\nclaude mcp remove --scope project cov-loupe # Removes from project scope\n</code></pre>"},{"location":"user/MCP_INTEGRATION/#codex","title":"Codex","text":"<p>Using the Codex CLI:</p> <pre><code># Add the MCP server\ncodex mcp add cov-loupe cov-loupe -m mcp\n\n# List configured servers\ncodex mcp list\n\n# Show server details\ncodex mcp get cov-loupe\n\n# Remove if needed (check codex documentation for scope options if applicable)\ncodex mcp remove cov-loupe\n</code></pre> <p>Important: Codex does not pass environment variables like <code>GEM_HOME</code>/<code>GEM_PATH</code> to MCP servers by default. After adding the server, you must manually edit <code>~/.codex/config.toml</code> to add the 'env_vars' setting:</p> <pre><code>[mcp_servers.cov-loupe]\ncommand = \"cov-loupe\"\nargs = [\"-m\", \"mcp\"]\nenv_vars = [\"GEM_HOME\", \"GEM_PATH\"]  # Add this line manually\n</code></pre> <p>Warning: If you run <code>codex mcp remove cov-loupe</code>, the <code>env_vars</code> line will be deleted along with the rest of the section. You'll need to manually add it back after running <code>codex mcp add</code> again. To avoid this, consider editing <code>~/.codex/config.toml</code> directly instead of using <code>remove</code>/<code>add</code> commands.</p>"},{"location":"user/MCP_INTEGRATION/#gemini","title":"Gemini","text":"<p>Using the Gemini CLI:</p> <pre><code># Add the MCP server\ngemini mcp add cov-loupe cov-loupe -- -m mcp\n\n# List configured servers\ngemini mcp list\n\n# Remove if needed (check gemini documentation for scope options if applicable)\ngemini mcp remove cov-loupe\n</code></pre> <p>Environment variables you can set:</p> <ul> <li><code>COV_LOUPE_OPTS</code> - Default CLI options (though less useful for MCP mode)</li> </ul>"},{"location":"user/MCP_INTEGRATION/#available-mcp-tools-functions","title":"Available MCP Tools (Functions)","text":""},{"location":"user/MCP_INTEGRATION/#tool-catalog","title":"Tool Catalog","text":"<p>cov-loupe exposes 10 MCP tools:</p> Tool Purpose Key Parameters <code>coverage_summary_tool</code> File coverage summary <code>path</code> <code>coverage_detailed_tool</code> Per-line coverage <code>path</code> <code>coverage_raw_tool</code> Raw SimpleCov array <code>path</code> <code>uncovered_lines_tool</code> List uncovered lines <code>path</code> <code>list_tool</code> Project-wide coverage <code>sort_order</code>, <code>tracked_globs</code> <code>coverage_totals_tool</code> Aggregated line totals <code>tracked_globs</code> <code>coverage_table_tool</code> Formatted coverage table <code>sort_order</code> <code>validate_tool</code> Validate coverage policies <code>code</code> or <code>file</code> <code>help_tool</code> Tool discovery (none) <code>version_tool</code> Version information (none)"},{"location":"user/MCP_INTEGRATION/#json-response-format","title":"JSON Response Format","text":"<p>For tools that return structured data, <code>cov-loupe</code> serializes the data as a JSON string and returns it inside a <code>text</code> part of the MCP response.</p> <p>Example: <pre><code>{\n  \"type\": \"text\",\n  \"text\": \"{\\\"file\\\":\\\"lib/foo.rb\\\",\\\"summary\\\":{\\\"covered\\\":10,\\\"total\\\":20,\\\"percentage\\\":50.0},\\\"stale\\\":false}\"\n}\n</code></pre></p> <p>Reasoning: While returning JSON in a <code>resource</code> part with <code>mimeType: \"application/json\"</code> is more semantically correct, major MCP clients (including Google's Gemini and Anthropic's Claude) were found to not support this format, causing validation errors. They expect a <code>resource</code> part to contain a <code>uri</code>.</p> <p>To ensure maximum compatibility, the decision was made to use a simple <code>text</code> part. This is a pragmatic compromise that has proven to be reliable across different clients.</p> <p>Further Reading: This decision was informed by discussions with multiple AI models. For more details, see these conversations: - Perplexity AI Discussion - ChatGPT Discussion</p>"},{"location":"user/MCP_INTEGRATION/#cli-options-in-mcp-mode","title":"CLI Options in MCP Mode","text":"<p>When the MCP server starts, you can pass CLI options via the startup command. These options become the default config for MCP tools. Per-request JSON parameters still win over CLI defaults.</p> CLI Option Affects MCP Server? JSON Parameter Notes <code>-R</code>, <code>--root</code> \u2705 Default <code>root</code> Request param overrides; CLI sets default <code>-r</code>, <code>--resultset</code> \u2705 Default <code>resultset</code> Request param overrides; CLI sets default <code>-S</code>, <code>--raise-on-stale</code> \u2705 Default <code>raise_on_stale</code> Request param overrides; CLI sets default (<code>false</code> or <code>true</code>) <code>-g</code>, <code>--tracked-globs</code> \u2705 Default <code>tracked_globs</code> Request param overrides; CLI sets default (array) <code>--error-mode</code> \u2705 Yes <code>error_mode</code> Sets server-wide error handling; can override per tool <code>-l</code>, <code>--log-file</code> \u2705 Yes N/A Sets server log location (cannot override per tool) <code>-f</code>, <code>--format</code> \u274c No N/A CLI-only presentation flag (not used by MCP) <code>-o</code>, <code>--sort-order</code> \u274c No <code>sort_order</code> CLI flag ignored in MCP; pass per tool call (<code>\\\"ascending\\\"</code> or <code>\\\"descending\\\"</code>) <code>-s</code>, <code>--source</code> \u274c No N/A CLI-only presentation flag (not used by MCP) <code>-c</code>, <code>--context-lines</code> \u274c No N/A CLI-only presentation flag (not used by MCP) <code>-C</code>, <code>--color BOOLEAN</code> \u274c No N/A CLI-only presentation flag (not used by MCP) <code>-m</code>, <code>--mode</code> \u2705 Required N/A Required for MCP mode: <code>-m mcp</code> or <code>--mode mcp</code>. Default: <code>cli</code>. <p>Key Takeaways: - Server-level options (<code>--error-mode</code>, <code>--log-file</code>): Set once when server starts, apply to all tool calls - Tool-level options (<code>root</code>, <code>resultset</code>, <code>raise_on_stale</code>, <code>tracked_globs</code>): CLI args provide defaults; per-tool JSON params override when provided - CLI-only options (<code>--format</code>, <code>--source</code>, etc.): Not applicable to MCP mode</p> <p>Precedence for MCP tool config: <code>JSON request param</code> &gt; <code>CLI args used to start MCP</code> (including <code>COV_LOUPE_OPTS</code>) &gt; built-in defaults (<code>root: '.'</code>, <code>raise_on_stale: false</code>, <code>resultset: nil</code>, <code>tracked_globs: []</code> - no filtering, no tracking).</p> <p>CLI-only presentation flags (<code>-f/--format</code>, <code>-s/--source</code>, <code>-c/--context-lines</code>, <code>-C/--color</code>, and CLI <code>-o/--sort-order</code> defaults) never flow into MCP. Pass <code>sort_order</code> explicitly in each tool request when you need non-default ordering.</p> <p>Data caching: Coverage data is cached in a global singleton (<code>ModelDataCache</code>) and shared across all <code>CoverageModel</code> instances. When the resultset file changes (based on file signature and MD5 digest), the cache automatically reloads fresh data. Model instances themselves are lightweight and created fresh for each tool request.</p>"},{"location":"user/MCP_INTEGRATION/#common-parameters","title":"Common Parameters","text":"<p>All file-specific tools accept these parameters in the JSON request:</p> <ul> <li><code>path</code> (required for file tools) - File path (relative or absolute)</li> <li><code>root</code> (optional) - Project root directory (default: <code>.</code>)</li> <li><code>resultset</code> (optional) - Path to the <code>.resultset.json</code> file. See Configuring the Resultset for details.</li> <li><code>raise_on_stale</code> (optional) - Raise error on staleness: <code>false</code> (default) or <code>true</code></li> <li><code>error_mode</code> (optional) - Error handling: <code>\"off\"</code>, <code>\"log\"</code> (default), <code>\"debug\"</code> (overrides server-level setting)</li> </ul>"},{"location":"user/MCP_INTEGRATION/#tool-details","title":"Tool Details","text":""},{"location":"user/MCP_INTEGRATION/#per-file-tools","title":"Per-File Tools","text":"<p>These tools analyze individual files. All require <code>path</code> parameter.</p> <p><code>coverage_summary_tool</code> - Covered/total/percentage summary <pre><code>{\"file\": \"...\", \"summary\": {\"covered\": 12, \"total\": 14, \"percentage\": 85.71}, \"stale\": \"ok\"}\n</code></pre></p> <p><code>uncovered_lines_tool</code> - List uncovered line numbers <pre><code>{\"file\": \"...\", \"uncovered\": [5, 9, 12], \"summary\": {...}, \"stale\": \"ok\"}\n</code></pre></p> <p><code>coverage_detailed_tool</code> - Per-line hit counts <pre><code>{\"file\": \"...\", \"lines\": [{\"line\": 1, \"hits\": 1, \"covered\": true}, ...], \"summary\": {...}, \"stale\": \"ok\"}\n</code></pre></p> <p><code>coverage_raw_tool</code> - Raw SimpleCov lines array <pre><code>{\"file\": \"...\", \"lines\": [1, 0, null, 5, 2, null, 1], \"stale\": \"ok\"}\n</code></pre></p> <p>Staleness values: <code>\"ok\"</code> (fresh), <code>\"missing\"</code> (missing), <code>\"newer\"</code> (timestamp), <code>\"length_mismatch\"</code> (length), <code>\"error\"</code> (staleness check error)</p>"},{"location":"user/MCP_INTEGRATION/#project-wide-tools","title":"Project-Wide Tools","text":"<p><code>list_tool</code> - Coverage for all files - Parameters: <code>sort_order</code> (<code>ascending</code>|<code>descending</code>), <code>tracked_globs</code> (array) - Returns: <code>{\"files\": [...], \"counts\": {\"total\": N, \"ok\": N, \"stale\": N}, \"skipped_files\": [...], \"missing_tracked_files\": [...], \"newer_files\": [...], \"deleted_files\": [...], \"length_mismatch_files\": [...], \"unreadable_files\": [...], \"timestamp_status\": \"ok|missing\"}</code></p> <p><code>coverage_totals_tool</code> - Aggregated line totals - Parameters: <code>tracked_globs</code> (array), <code>raise_on_stale</code> - Returns: <code>{\"lines\":{\"total\":N,\"covered\":N,\"uncovered\":N,\"percent_covered\":Float},\"tracking\":{\"enabled\":Boolean,\"globs\":[String]},\"files\":{\"total\":N,\"with_coverage\":{\"total\":N,\"ok\":N,\"stale\":{\"total\":N,\"by_type\":{\"missing_from_disk\":N,\"newer\":N,\"length_mismatch\":N,\"unreadable\":N}}},\"without_coverage\":{\"total\":N,\"by_type\":{\"missing_from_coverage\":N,\"unreadable\":N,\"skipped\":N}}}}</code> - <code>without_coverage</code> is only present when tracking is enabled (tracked globs provided).</p> <p><code>coverage_table_tool</code> - Formatted table with box-drawing characters - Parameters: <code>sort_order</code> (<code>ascending</code>|<code>descending</code>) - Returns: Plain text table</p>"},{"location":"user/MCP_INTEGRATION/#policy-validation-tools","title":"Policy Validation Tools","text":"<p><code>validate_tool</code> - Validate coverage against custom policies - Parameters: Either <code>code</code> (Ruby string) OR <code>file</code> (path to Ruby file), plus optional <code>root</code>, <code>resultset</code>, <code>raise_on_stale</code>, <code>error_mode</code> - Returns: <code>{\"result\": Boolean}</code> where <code>true</code> means policy passed, <code>false</code> means failed - Security Warning: Predicates execute as arbitrary Ruby code with full system privileges. Only use predicate files from trusted sources. - Examples:   - Check if all files have at least 80% coverage: <code>{\"code\": \"-&gt;(m) { m.list.all? { |f| f['percentage'] &gt;= 80 } }\"}</code>   - Run coverage policy from file: <code>{\"file\": \"coverage_policy.rb\"}</code></p>"},{"location":"user/MCP_INTEGRATION/#utility-tools","title":"Utility Tools","text":"<p><code>help_tool</code> - Tool discovery <code>version_tool</code> - Version information</p>"},{"location":"user/MCP_INTEGRATION/#example-prompts-for-ai-assistants","title":"Example Prompts for AI Assistants","text":"<p>(Hopefully, your AI agent will not need you to explicilty specify \"Using cov-loupe\", but this is included here because we have seen cases where it does not know to use cov-loupe.)</p>"},{"location":"user/MCP_INTEGRATION/#coverage-analysis","title":"Coverage Analysis","text":"<pre><code>Using cov-loupe, show me a table of all files and their coverage percentages.\n</code></pre> <pre><code>Using cov-loupe, find files with less than 80% coverage and tell me which ones to prioritize.\n</code></pre> <pre><code>Using cov-loupe, analyze the coverage for lib/cov_loupe/tools/ and suggest improvements.\n</code></pre>"},{"location":"user/MCP_INTEGRATION/#finding-coverage-gaps","title":"Finding Coverage Gaps","text":"<pre><code>Using cov-loupe, show me the uncovered lines in lib/cov_loupe/base_tool.rb and explain what they do.\n</code></pre> <pre><code>Using cov-loupe, find the most important uncovered code in lib/cov_loupe/tools/coverage_detailed_tool.rb.\n</code></pre>"},{"location":"user/MCP_INTEGRATION/#test-generation","title":"Test Generation","text":"<pre><code>Using cov-loupe, find uncovered lines in lib/cov_loupe/staleness_checker.rb and write *meaningful* RSpec tests for them.\n</code></pre> <pre><code>Using cov-loupe, analyze coverage gaps in lib/cov_loupe/tools/ and generate test cases.\n</code></pre>"},{"location":"user/MCP_INTEGRATION/#coverage-reporting","title":"Coverage Reporting","text":"<pre><code>Using cov-loupe, create a markdown report of:\n- Files with worst coverage\n- Most critical coverage gaps\n- Recommended action items\n</code></pre>"},{"location":"user/MCP_INTEGRATION/#testing-your-setup","title":"Testing Your Setup","text":""},{"location":"user/MCP_INTEGRATION/#manual-testing-via-command-line","title":"Manual Testing via Command Line","text":"<p>Test the MCP server responds to JSON-RPC:</p> <pre><code># Test version tool (simplest, no parameters needed)\necho '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"version_tool\",\"arguments\":{}}}' | cov-loupe -m mcp\n\n# Test help tool (no parameters needed)\necho '{\"jsonrpc\":\"2.0\",\"id\":3,\"method\":\"tools/call\",\"params\":{\"name\":\"help_tool\",\"arguments\":{}}}' | cov-loupe -m mcp\n\n# Test summary tool (use root param if needed)\necho '{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"tools/call\",\"params\":{\"name\":\"coverage_summary_tool\",\"arguments\":{\"path\":\"lib/cov_loupe/model.rb\",\"root\":\".\"}}}' | cov-loupe -m mcp\n\n# Test with a project-specific root\necho '{\"jsonrpc\":\"2.0\",\"id\":4,\"method\":\"tools/call\",\"params\":{\"name\":\"coverage_summary_tool\",\"arguments\":{\"path\":\"app/models/order.rb\",\"root\":\"docs/fixtures/demo_project\"}}}' | cov-loupe -m mcp\n</code></pre> <p>Important Notes: - JSON-RPC messages must be on a single line. Multi-line JSON will cause parse errors. - CLI flags like <code>-R</code> set server defaults, but per-request JSON parameters still win. - The <code>root</code> parameter is optional and defaults to <code>.</code> (current directory).</p>"},{"location":"user/MCP_INTEGRATION/#testing-in-ai-assistant","title":"Testing in AI Assistant","text":"<p>Once configured, try these prompts in your AI assistant:</p> <ol> <li> <p>Basic connectivity: <pre><code>Using cov-loupe, show me the version.\n</code></pre></p> </li> <li> <p>List tools: <pre><code>Using cov-loupe, what tools are available?\n</code></pre></p> </li> <li> <p>Simple query: <pre><code>Using cov-loupe, show me all files with coverage.\n</code></pre></p> </li> </ol> <p>If these work, your setup is correct!</p>"},{"location":"user/MCP_INTEGRATION/#checking-logs","title":"Checking Logs","text":"<p>The MCP server logs to <code>cov_loupe.log</code> in the current directory by default.</p> <pre><code># Watch logs in real-time\ntail -f cov_loupe.log\n\n# View recent errors\ngrep ERROR cov_loupe.log | tail -20\n</code></pre> <p>To override the default log file location, specify the <code>--log-file</code> (or <code>-l</code>) argument wherever and however you configure your MCP server. For example, to log to a different file path, include <code>-l /path/to/logfile.log</code> in your server configuration. To log to standard error, use <code>-l stderr</code>.</p> <p>Warning: Log files may grow unbounded in long-running or CI usage. Consider using a log rotation tool or periodically cleaning up the log file if this is a concern.</p> <p>Note: Logging to <code>stdout</code> is not permitted in MCP mode.</p>"},{"location":"user/MCP_INTEGRATION/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user/MCP_INTEGRATION/#cli-fallback","title":"CLI Fallback","text":"<p>Important: If the MCP server doesn't work, you can use the CLI directly with the <code>-fJ</code> (output in JSON format) flag.</p> <p>See the CLI Fallback for LLMs Guide for: - Complete command reference and MCP tool mappings - Sample prompt to give your LLM - JSON output examples - Tips for using CLI as an MCP alternative</p>"},{"location":"user/MCP_INTEGRATION/#common-issues","title":"Common Issues","text":"<p>Server Won't Start <pre><code>which cov-loupe     # Verify executable exists\nruby -v             # Check Ruby &gt;= 3.2\ncov-loupe version   # Test basic functionality\n</code></pre></p> <p>Tools Not Appearing 1. Restart AI assistant after config changes 2. Check logs: <code>tail -f cov_loupe.log</code> 3. Try explicit tool names in prompts 4. Verify MCP server status in assistant</p> <p>JSON-RPC Parse Errors - Ensure JSON is on a single line (no newlines) - Test manually: <code>echo '{\"jsonrpc\":\"2.0\",...}' | cov-loupe -m mcp</code></p>"},{"location":"user/MCP_INTEGRATION/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"user/MCP_INTEGRATION/#enable-debug-logging","title":"Enable Debug Logging","text":"<p>For troubleshooting, add error mode when configuring the server:</p> <pre><code># Claude Code\nclaude mcp add cov-loupe cov-loupe -- -m mcp --error-mode debug\n\n# Codex\ncodex mcp add cov-loupe cov-loupe -m mcp --error-mode debug\n\n# Gemini\ngemini mcp add cov-loupe cov-loupe -- -m mcp --error-mode debug\n</code></pre>"},{"location":"user/MCP_INTEGRATION/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Fallback for LLMs - Using CLI when MCP isn't available</li> <li>CLI Usage - Complete CLI reference</li> <li>Examples - Example prompts and workflows</li> <li>Troubleshooting - Detailed troubleshooting guide</li> </ul>"},{"location":"user/TROUBLESHOOTING/","title":"Troubleshooting Guide","text":"<p>Back to main README</p>"},{"location":"user/TROUBLESHOOTING/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Running Issues</li> <li>Coverage Data Issues</li> <li>MCP Server Issues</li> <li>Diagnostic Commands</li> </ul>"},{"location":"user/TROUBLESHOOTING/#running-issues","title":"Running Issues","text":""},{"location":"user/TROUBLESHOOTING/#running-the-test-suite-with-rvm-codex-macos","title":"Running the Test Suite with RVM (Codex macOS)","text":"<p>Codex's macOS sandbox forbids <code>/bin/ps</code>; RVM shells need it. When you run <code>bundle exec rspec</code> there, the shell falls back to macOS Ruby 2.6 and Bundler dies with <code>Gem::Resolver::APISet::GemParser</code> errors.</p> <p>Workarounds:</p> <ul> <li>Run outside the macOS sandbox (Codex on Ubuntu, Gemini, Claude Code, local shells) or use a version manager that does not invoke <code>ps</code>.</li> <li>Or execute RSpec with explicit RVM paths:   <pre><code>PATH=\"$HOME/.rvm/gems/ruby-3.4.5@cov-loupe/bin:$HOME/.rvm/rubies/ruby-3.4.5/bin:$PATH\" \\\n  GEM_HOME=\"$HOME/.rvm/gems/ruby-3.4.5@cov-loupe\" \\\n  GEM_PATH=\"$HOME/.rvm/gems/ruby-3.4.5@cov-loupe:$HOME/.rvm/gems/ruby-3.4.5@global\" \\\n  $HOME/.rvm/rubies/ruby-3.4.5/bin/bundle exec rspec\n</code></pre></li> <li>Use a different AI coding agent and/or operating system.</li> </ul>"},{"location":"user/TROUBLESHOOTING/#coverage-data-issues","title":"Coverage Data Issues","text":""},{"location":"user/TROUBLESHOOTING/#missing-coverageresultsetjson","title":"Missing <code>coverage/.resultset.json</code>","text":"<p><code>cov-loupe</code> only reads coverage data; it never generates it. If you see \"Could not find .resultset.json\":</p> <ol> <li>Run the test suite with SimpleCov enabled (default project setup already enables it).    <pre><code>bundle exec rspec\nls coverage/.resultset.json\n</code></pre></li> <li>If your coverage lives elsewhere, point the tools at it:    <pre><code>cov-loupe -r build/coverage/.resultset.json  # -r = --resultset\n# or\nexport COV_LOUPE_OPTS=\"-r build/coverage\"\n</code></pre></li> </ol>"},{"location":"user/TROUBLESHOOTING/#stale-coverage-errors","title":"Stale Coverage Errors","text":"<p><code>--raise-on-stale</code> (or <code>-S</code>, or <code>raise_on_stale: true</code>) compares file mtimes and line counts to the coverage snapshot and raises if stale. When it fails:</p> <ul> <li>Regenerate coverage (<code>bundle exec rspec</code>) so the snapshot matches current sources.</li> <li>Or drop back to warning-only behaviour using <code>--no-raise-on-stale</code> / <code>raise_on_stale: false</code>.</li> </ul> <p>If you only care about a subset of files, supply <code>-g</code> / <code>--tracked-globs</code> (CLI) or <code>tracked_globs:</code> (API) so new files outside those globs do not trigger staleness.</p> <p>Note: If you see warnings about missing timestamps, time-based staleness checks may be skipped. See Timestamp Warnings for details.</p>"},{"location":"user/TROUBLESHOOTING/#no-coverage-data-found-for-file","title":"\"No coverage data found for file\"","text":"<p>The model looks up files by absolute path, then by relative path (stripping the project root). If you still hit this error:</p> <ol> <li>Verify the file is listed in the coverage table (<code>cov-loupe list | grep model.rb</code>).</li> <li>Use the exact project-relative path that SimpleCov recorded (no symlinks; case-sensitivity depends on your volume - see note below).</li> <li>If the file truly never executes under tests, add coverage or exclude it from your workflow.</li> </ol> <p>Note on case-sensitivity: <code>cov-loupe</code> auto-detects volume case-sensitivity at startup.  On case-insensitive volumes (most macOS/Windows), <code>lib/Foo.rb</code> and <code>lib/foo.rb</code> are treated as the same file. On case-sensitive volumes (most Linux, some macOS), they are different files.</p>"},{"location":"user/TROUBLESHOOTING/#simplecov-path-consistency-merged-resultsets","title":"SimpleCov path consistency (merged resultsets)","text":"<p>When SimpleCov merges resultsets from multiple suites or environments, it can record the same file under different path forms (for example, absolute vs relative, or with different roots). This is a SimpleCov output issue, not a cov-loupe issue. Downstream tools will normalize paths and may treat one entry as overriding another if two keys map to the same file.</p> <p>Recommendation: Keep <code>SimpleCov.root</code> consistent across suites and avoid manual path rewriting when merging resultsets.</p>"},{"location":"user/TROUBLESHOOTING/#mcp-server-issues","title":"MCP Server Issues","text":""},{"location":"user/TROUBLESHOOTING/#mcp-integration-not-working","title":"MCP Integration Not Working","text":"<p>Symptoms: - AI assistant reports \"Could not connect to MCP server\" - AI says \"I don't have access to cov-loupe tools\"</p> <p>Diagnostic steps:</p> <ol> <li> <p>Verify executable exists and works: <pre><code>which cov-loupe\ncov-loupe version\n</code></pre></p> </li> <li> <p>Test MCP server mode manually: <pre><code>echo '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"version_tool\",\"arguments\":{}}}' | cov-loupe -m mcp\n</code></pre>    Should return JSON-RPC response.</p> </li> <li> <p>Verify MCP server is configured: <pre><code>claude mcp list  # For Claude Code\ncodex mcp list   # For Codex\ngemini mcp list  # For Gemini\ntail -f cov_loupe.log  # Check logs\n</code></pre></p> </li> <li> <p>Restart AI assistant - Config changes often require restart</p> </li> <li> <p>Use absolute path in MCP config: <pre><code># Find absolute path\nwhich cov-loupe\n\n# Update your MCP client config to use this path\n</code></pre></p> </li> <li> <p>Use CLI as fallback:</p> </li> </ol> <p>If MCP still isn't working, you can use the CLI with <code>-fJ</code> flag instead.    See CLI Fallback for LLMs for complete guidance.</p> <ol> <li>Check for Codex environment variable issues:    If you are using Codex and the server fails to start due to missing gems, you need to manually add     <code>env_vars = [\"GEM_HOME\", \"GEM_PATH\"]</code> to your <code>~/.codex/config.toml</code>.     See the MCP Integration - Codex section for complete setup instructions.</li> </ol>"},{"location":"user/TROUBLESHOOTING/#path-issues-with-version-managers","title":"Path Issues with Version Managers","text":"<p>Symptom: <code>cov-loupe</code> works in terminal but not in MCP client.</p> <p>Cause: MCP client doesn't have your shell environment (PATH, RVM, etc.).</p> <p>Solution: Use absolute paths in MCP configuration:</p> <pre><code># For rbenv/asdf - get the full absolute path\nwhich cov-loupe\n# Example output: /home/username/.rbenv/shims/cov-loupe\n# Use this exact path in your MCP config\n\n# For RVM you may need to create a wrapper and specify its absolute path\n# (Replace ruby-3.3.8 with your rvm Ruby label) \nrvm wrapper ruby-3.3.8 cov-loupe cov-loupe\n\n# Get the full path (expands ~ to your home directory)\nrealpath ~/.rvm/wrappers/ruby-3.3.8/cov-loupe\n# Example output: /home/username/.rvm/wrappers/ruby-3.3.8/cov-loupe\n\n# Use the FULL path in MCP config (NOT the ~ version):\n# Good: /home/username/.rvm/wrappers/ruby-3.3.8/cov-loupe\n# Bad:  ~/.rvm/wrappers/ruby-3.3.8/cov-loupe  (~ may not expand)\n</code></pre>"},{"location":"user/TROUBLESHOOTING/#diagnostic-commands","title":"Diagnostic Commands","text":"<p>Before reporting an issue, run these diagnostic commands and include the output:</p> <pre><code># System info\nruby -v\ngem -v\nbundle -v\n\n# cov-loupe info\ngem list cov-loupe\nwhich cov-loupe\ncov-loupe version\n\n# Test basic functionality\ncov-loupe --help\ncov-loupe list 2&gt;&amp;1\n\n# Check coverage data\nls -la coverage/.resultset.json\nhead -20 coverage/.resultset.json\n\n# Test MCP mode\necho '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"tools/call\",\"params\":{\"name\":\"version_tool\",\"arguments\":{}}}' | cov-loupe -m mcp 2&gt;&amp;1\n</code></pre>"},{"location":"user/TROUBLESHOOTING/#getting-more-help","title":"Getting More Help","text":"<p>If the above doesn't solve your problem:</p> <ol> <li> <p>Check error mode - Run with <code>--error-mode debug</code> for full stack traces:    <pre><code>cov-loupe --error-mode debug summary lib/cov_loupe/cli.rb\n</code></pre></p> </li> <li> <p>Check logs: <pre><code># MCP server logs\ntail -50 cov_loupe.log\n\n# Or specify custom log location (--log-file or -l)\ncov-loupe -l /tmp/debug.log summary lib/cov_loupe/cli.rb\n</code></pre></p> </li> <li> <p>Search existing issues:    https://github.com/keithrbennett/cov-loupe/issues</p> </li> <li> <p>Report a bug:    Include output from Diagnostic Commands above</p> </li> </ol>"},{"location":"user/TROUBLESHOOTING/#related-documentation","title":"Related Documentation","text":"<ul> <li>Installation Guide - Setup and PATH configuration</li> <li>CLI Usage - Command-line options and examples</li> <li>CLI Fallback for LLMs - Using CLI when MCP isn't available</li> <li>MCP Integration - MCP server configuration</li> <li>Error Handling - Understanding error modes</li> </ul>"},{"location":"user/installing-a-prelease-version-of-covloupe/","title":"Installing a Prerelease Version of cov-loupe","text":"<p>Prerelease versions of gems (those containing <code>.pre</code>, <code>.alpha</code>, <code>.beta</code>, <code>.rc</code>, etc.) are not installed by default in RubyGems.</p>"},{"location":"user/installing-a-prelease-version-of-covloupe/#command-line-installation","title":"Command Line Installation","text":"<p>When users run <code>gem install cov-loupe</code>, RubyGems installs the latest stable version, skipping any prereleases.</p> <p>To install a prerelease, you must explicitly opt in:</p> <pre><code># Install the latest prerelease\ngem install cov-loupe --pre\n\n# Install a specific prerelease version\ngem install cov-loupe -v 4.0.0.pre\n</code></pre>"},{"location":"user/installing-a-prelease-version-of-covloupe/#gemfile","title":"Gemfile","text":"<p>In a Gemfile, you need to explicitly specify the prerelease version:</p> <pre><code># Exact version\ngem 'cov-loupe', '4.0.0.pre'\n\n# Or allow any 4.0.0 prerelease\ngem 'cov-loupe', '~&gt; 4.0.0.pre'\n</code></pre> <p>Without an explicit version constraint that includes the prerelease suffix, Bundler will skip prereleases just like <code>gem install</code> does.</p>"},{"location":"user/installing-a-prelease-version-of-covloupe/#gemspec-dependencies","title":"Gemspec Dependencies","text":"<p>For gemspec dependencies on prerelease gems, you must specify the prerelease version explicitly:</p> <pre><code>spec.add_dependency 'cov-loupe', '~&gt; 4.0.0.pre'\n</code></pre>"},{"location":"user/installing-a-prelease-version-of-covloupe/#key-point","title":"Key Point","text":"<p>Version constraints like <code>~&gt; 4.0</code> or <code>&gt;= 4.0</code> will not match prereleases. You must include the prerelease segment in the constraint for it to match.</p>"},{"location":"user/migrations/","title":"Migration Guides","text":"<p>Upgrade guides for major version changes in cov-loupe.</p>"},{"location":"user/migrations/#available-guides","title":"Available Guides","text":"<ul> <li>Migrating to v4 - Upgrade from v3.x to v4.x</li> <li>Migrating to v3 - Upgrade from v2.x to v3.x</li> <li>Migrating to v2 - Upgrade from v1.x to v2.x</li> </ul>"},{"location":"user/migrations/#general-migration-tips","title":"General Migration Tips","text":"<ol> <li>Always review the Release Notes for your target version</li> <li>Run your test suite after upgrading to catch any breaking changes</li> <li>Check the Troubleshooting Guide if you encounter issues</li> </ol>"},{"location":"user/migrations/#need-help","title":"Need Help?","text":"<p>If you encounter issues during migration, please: - Check the relevant migration guide above for your version - Review the Troubleshooting Guide - Search or open an issue on GitHub</p>"},{"location":"user/migrations/MIGRATING_TO_V2/","title":"V2.0 Breaking Changes and Migration Guide","text":"<p>Back to main README</p> <p>This document describes all breaking changes introduced in version 2.0.0 of simplecov-mcp. These changes improve consistency, clarity, and alignment with Ruby conventions.</p> <p>Note: Current versions use the boolean <code>--raise-on-stale</code> / <code>raise_on_stale</code> flag (short form <code>-S</code>) for staleness enforcement. The <code>--staleness</code> and <code>stale</code> names referenced below are kept for historical context about the v1\u2192v2 transition.</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Command Line Interface Changes</li> <li>Error Mode Values Changed</li> <li>Default Sort Order Changed</li> <li>MCP Tool Changes</li> <li>stale Parameter Renamed to staleness</li> <li>MCP Tool Arguments Use Symbols</li> <li>Ruby API Changes</li> <li>CLIConfig Renamed to AppConfig</li> <li>AppConfig Field Changes</li> <li>Behavioral Changes</li> <li>Context Lines Validation</li> <li>Migration Guide</li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V2/#command-line-interface-changes","title":"Command Line Interface Changes","text":"<p>Migration: Move all global options before the subcommand name. These options are:</p> <p><code>-r</code>, <code>-R</code>, <code>-f</code>, <code>-o</code>, <code>-s</code>, <code>-c</code>, <code>-C</code>, <code>-S</code>, <code>-g</code>, <code>-l</code>, <code>-F</code>, and <code>-e</code></p> <p>Exception: The <code>validate</code> subcommand has its own subcommand-specific option <code>-i/--inline</code> that must appear after the subcommand: <pre><code>cov-loupe validate -i '-&gt;(m) { m.list.all? { |f| f[\"percentage\"] &gt;= 80 } }'\n</code></pre></p>"},{"location":"user/migrations/MIGRATING_TO_V2/#-stale-renamed-to-staleness","title":"--stale Renamed to --staleness","text":"<p>Change: The <code>--stale</code> option has been renamed to <code>--staleness</code>. The short form <code>-S</code> is preserved.</p> <p>Rationale: Better describes what the option controls (staleness detection mode) and aligns with internal naming conventions.</p> <p>Before (v1.x): <pre><code>simplecov-mcp --stale error list\n</code></pre></p> <p>After (v2.x): <pre><code>simplecov-mcp --staleness error list\n# OR use the short form:\nsimplecov-mcp -S error list\n</code></pre></p> <p>Migration: Replace <code>--stale</code> with <code>--staleness</code> (or continue using <code>-S</code>).</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#-source-context-renamed-to-context-lines","title":"--source-context Renamed to --context-lines","text":"<p>Change: The <code>--source-context</code> option has been renamed to <code>--context-lines</code>.</p> <p>Rationale: More concise and clearer about what the option controls.</p> <p>Before (v1.x): <pre><code>simplecov-mcp --source uncovered --source-context 3 uncovered lib/foo.rb\n</code></pre></p> <p>After (v2.x): <pre><code>simplecov-mcp --source uncovered --context-lines 3 uncovered lib/foo.rb\n# OR use the short form:\nsimplecov-mcp -s uncovered -c 3 uncovered lib/foo.rb\n</code></pre></p> <p>Migration: Replace <code>--source-context</code> with <code>--context-lines</code> (or use <code>-c</code>).</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#-source-now-requires-explicit-mode","title":"--source Now Requires Explicit Mode","text":"<p>Change: The <code>--source</code> option now requires an explicit mode argument (<code>full</code> or <code>uncovered</code>).</p> <p>Rationale: Eliminates ambiguity about what source display mode is being used.</p> <p>Before (v1.x): <pre><code># Implied 'full' mode\nsimplecov-mcp --source summary lib/foo.rb\n</code></pre></p> <p>After (v2.x): <pre><code># Must specify mode explicitly\nsimplecov-mcp --source full summary lib/foo.rb\n# OR\nsimplecov-mcp --source uncovered summary lib/foo.rb\n</code></pre></p> <p>Migration: Add an explicit mode (<code>full</code> or <code>uncovered</code>) after <code>--source</code>.</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#-json-replaced-with-format","title":"--json Replaced with --format","text":"<p>Change: The <code>--json</code> flag (and related <code>-j</code>, <code>--pretty-json</code> flags) have been removed. Use <code>-f/--format</code> instead.</p> <p>Rationale: Supports multiple output formats beyond JSON (YAML, awesome_print, etc.) with a consistent interface.</p> <p>Before (v1.x): <pre><code>simplecov-mcp --json list\nsimplecov-mcp -j summary lib/foo.rb\nsimplecov-mcp --pretty-json list\n</code></pre></p> <p>After (v2.x): <pre><code>simplecov-mcp --format json list\nsimplecov-mcp -f j summary lib/foo.rb    # Short form\nsimplecov-mcp --format pretty-json list\nsimplecov-mcp -f J list                  # Short form for pretty-json\n</code></pre></p> <p>Available formats: - <code>table</code> (default) - Human-readable table format - <code>json</code> or <code>j</code> - Single-line JSON - <code>pretty-json</code> or <code>J</code> - Pretty-printed JSON - <code>yaml</code> or <code>y</code> - YAML format - <code>awesome_print</code> or <code>ap</code> - Colored awesome_print format (requires <code>awesome_print</code> gem)</p> <p>Migration: Replace <code>--json</code> with <code>--format json</code> (or <code>-f j</code>). Replace <code>--pretty-json</code> with <code>--format pretty-json</code> (or <code>-f J</code>).</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#error-mode-values-changed","title":"Error Mode Values Changed","text":"<p>Change: Error mode enum values have been renamed for clarity: - <code>on</code> \u2192 <code>log</code> - <code>trace</code> \u2192 <code>debug</code></p> <p>The old values are no longer supported.</p> <p>Rationale: More descriptive names that better communicate what each mode does.</p> <p>Before (v1.x): <pre><code>simplecov-mcp --error-mode on list\nsimplecov-mcp --error-mode trace list\n</code></pre></p> <p>After (v2.x): <pre><code>simplecov-mcp --error-mode log list\nsimplecov-mcp --error-mode debug list\n# OR use short forms:\nsimplecov-mcp --error-mode l list\nsimplecov-mcp --error-mode d list\n</code></pre></p> <p>Error modes: - <code>off</code> (or <code>o</code>) - Silent, no error logging - <code>log</code> (or <code>l</code>) - Log errors to file (default) - <code>debug</code> (or <code>d</code>) - Verbose logging with backtraces</p> <p>Migration: Replace <code>--error-mode on</code> with <code>--error-mode log</code>. Replace <code>--error-mode trace</code> with <code>--error-mode debug</code>.</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#-success-predicate-replaced-with-validate-subcommand","title":"--success-predicate Replaced with validate Subcommand","text":"<p>Change: The <code>--success-predicate</code> flag has been removed. Use the <code>validate</code> subcommand instead.</p> <p>Rationale: Better fits the subcommand paradigm and provides a clearer interface for policy validation.</p> <p>Before (v1.x): <pre><code>simplecov-mcp --success-predicate policy.rb\n</code></pre></p> <p>After (v2.x): <pre><code># File-based policy\nsimplecov-mcp validate policy.rb\n\n# Inline policy (new feature)\nsimplecov-mcp validate -i '-&gt;(m) { m.list.all? { |f| f[\"percentage\"] &gt;= 80 } }'\n</code></pre></p> <p>Migration: Replace <code>--success-predicate FILE</code> with <code>validate FILE</code>.</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#default-sort-order-changed","title":"Default Sort Order Changed","text":"<p>Change: The default sort order for the <code>list</code> command changed from <code>ascending</code> to <code>descending</code>.</p> <p>Rationale: Most users want to see worst-covered files last so that when scrolling is finished the worst-covered files are displayed on the screen.</p> <p>Before (v1.x): <pre><code># Shows worst coverage first by default\nsimplecov-mcp list\n</code></pre></p> <p>After (v2.x): <pre><code># Shows best coverage first by default\nsimplecov-mcp list\n\n# To get old behavior (worst first):\nsimplecov-mcp --sort-order ascending list\nsimplecov-mcp -o a list  # Short form\n</code></pre></p> <p>Migration: If you relied on ascending order (worst coverage first), explicitly specify <code>--sort-order ascending</code> or <code>-o a</code>.</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#mcp-tool-changes","title":"MCP Tool Changes","text":""},{"location":"user/migrations/MIGRATING_TO_V2/#stale-parameter-renamed-to-staleness","title":"stale Parameter Renamed to staleness","text":"<p>Change: All MCP tools that accepted a <code>stale</code> parameter now use <code>staleness</code> instead.</p> <p>Rationale: Aligns with the <code>CoverageModel</code> API and CLI option naming.</p> <p>Before (v1.x): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"coverage_summary_tool\",\n    \"arguments\": {\n      \"path\": \"lib/foo.rb\",\n      \"stale\": \"error\"\n    }\n  }\n}\n</code></pre></p> <p>After (v2.x): <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"coverage_summary_tool\",\n    \"arguments\": {\n      \"path\": \"lib/foo.rb\",\n      \"staleness\": \"error\"\n    }\n  }\n}\n</code></pre></p> <p>Affected tools: All file-based tools (<code>coverage_summary_tool</code>, <code>coverage_detailed_tool</code>, <code>coverage_raw_tool</code>, <code>uncovered_lines_tool</code>) and aggregate tools (<code>list_tool</code>, <code>coverage_totals_tool</code>).</p> <p>Migration: Replace <code>\"stale\"</code> with <code>\"staleness\"</code> in all MCP tool calls.</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#error-mode-values-changed_1","title":"Error Mode Values Changed","text":"<p>Change: Error mode enum values changed from <code>['off', 'on', 'trace']</code> to <code>['off', 'log', 'debug']</code>.</p> <p>Rationale: More descriptive names matching CLI changes.</p> <p>Before (v1.x): <pre><code>{\n  \"error_mode\": \"on\"\n}\n</code></pre></p> <p>After (v2.x): <pre><code>{\n  \"error_mode\": \"log\"\n}\n</code></pre></p> <p>Migration: Replace <code>\"on\"</code> with <code>\"log\"</code>, replace <code>\"trace\"</code> with <code>\"debug\"</code>.</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#mcp-tool-arguments-use-symbols","title":"MCP Tool Arguments Use Symbols","text":"<p>Change: Internally, MCP tools now normalize enum arguments to symbols (<code>:off</code>, <code>:error</code>, <code>:log</code>, <code>:debug</code>) for consistency with the Ruby API.</p> <p>Impact: This is mostly an internal change. MCP clients still send strings in JSON, but if you're using the tools programmatically in Ruby, be aware of the symbol usage.</p> <p>Migration: No action needed for MCP clients. For Ruby API users, see Ruby API Changes.</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#ruby-api-changes","title":"Ruby API Changes","text":""},{"location":"user/migrations/MIGRATING_TO_V2/#cliconfig-renamed-to-appconfig","title":"CLIConfig Renamed to AppConfig","text":"<p>Change: The <code>CLIConfig</code> class has been renamed to <code>AppConfig</code>.</p> <p>Rationale: The configuration is now used by both CLI and MCP modes, not just CLI.</p> <p>Before (v1.x): <pre><code>require 'cov_loupe/cli_config'\nconfig = CovLoupe::CLIConfig.new(root: '.', json: true)\n</code></pre></p> <p>After (v2.x): <pre><code>require 'cov_loupe/app_config'\nconfig = CovLoupe::AppConfig.new(root: '.', format: :json)\n</code></pre></p> <p>Migration: Replace <code>CLIConfig</code> with <code>AppConfig</code> in your code. Update require statements from <code>'cov_loupe/cli_config'</code> to <code>'cov_loupe/app_config'</code>.</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#appconfig-field-changes","title":"AppConfig Field Changes","text":"<p>Change: Several <code>AppConfig</code> fields have been renamed or changed:</p> Old Field (v1.x) New Field (v2.x) Type Change <code>json</code> <code>format</code> <code>Boolean</code> \u2192 <code>Symbol</code> (<code>:json</code>, <code>:table</code>, etc.) <code>stale_mode</code> <code>staleness</code> Name change only <code>success_predicate</code> (removed) Moved to <code>validate</code> subcommand (new) <code>show_version</code> New field for <code>-v</code>/<code>--version</code> <p>Default value changes: - <code>sort_order</code>: Changed from <code>:ascending</code> to <code>:descending</code> - <code>error_mode</code>: Changed from <code>:on</code> to <code>:log</code></p> <p>Before (v1.x): <pre><code>config = CovLoupe::CLIConfig.new(\n  json: true,\n  stale_mode: :error,\n  error_mode: :on,\n  sort_order: :ascending\n)\n</code></pre></p> <p>After (v2.x): <pre><code>config = CovLoupe::AppConfig.new(\n  format: :json,\n  staleness: :error,\n  error_mode: :log,\n  sort_order: :descending  # New default\n)\n</code></pre></p> <p>Migration: Update field names when constructing <code>AppConfig</code>. Note the new defaults.</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#behavioral-changes","title":"Behavioral Changes","text":""},{"location":"user/migrations/MIGRATING_TO_V2/#context-lines-validation","title":"Context Lines Validation","text":"<p>Change: The <code>--context-lines</code> option (formerly <code>--source-context</code>) now raises an <code>ArgumentError</code> if given a negative value. Previously, negative values were silently clamped to zero.</p> <p>Rationale: Fail fast and provide clear feedback for invalid input.</p> <p>Before (v1.x): <pre><code># Silently clamped to 0\nsimplecov-mcp --source-context -5 uncovered lib/foo.rb\n</code></pre></p> <p>After (v2.x): <pre><code># Raises ArgumentError\nsimplecov-mcp --context-lines -5 uncovered lib/foo.rb\n# Error: Context lines must be non-negative (got: -5)\n</code></pre></p> <p>Migration: Ensure <code>--context-lines</code> values are non-negative (&gt;= 0).</p>"},{"location":"user/migrations/MIGRATING_TO_V2/#migration-guide","title":"Migration Guide","text":""},{"location":"user/migrations/MIGRATING_TO_V2/#quick-checklist","title":"Quick Checklist","text":"<ul> <li>[ ] Move all global options before subcommands in CLI invocations</li> <li>[ ] Replace <code>--stale</code> with <code>--staleness</code> (or continue using <code>-S</code>)</li> <li>[ ] Replace <code>--source-context</code> with <code>--context-lines</code> (or use <code>-c</code>)</li> <li>[ ] Add explicit mode to <code>--source</code> (either <code>full</code> or <code>uncovered</code>)</li> <li>[ ] Replace <code>--json</code> with <code>--format json</code> (or <code>-f j</code>)</li> <li>[ ] Replace <code>--error-mode on</code> with <code>--error-mode log</code></li> <li>[ ] Replace <code>--error-mode trace</code> with <code>--error-mode debug</code></li> <li>[ ] Replace <code>--success-predicate FILE</code> with <code>validate FILE</code></li> <li>[ ] Update MCP tool calls: rename <code>stale</code> to <code>staleness</code></li> <li>[ ] Update MCP tool calls: replace error mode <code>\"on\"</code> with <code>\"log\"</code>, <code>\"trace\"</code> with <code>\"debug\"</code></li> <li>[ ] Update Ruby code: rename <code>CLIConfig</code> to <code>AppConfig</code></li> <li>[ ] Update Ruby code: rename <code>json</code> field to <code>format</code>, <code>stale_mode</code> to <code>staleness</code></li> <li>[ ] Explicitly set <code>--sort-order ascending</code> if you need worst-coverage-first sorting</li> <li>[ ] Ensure <code>--context-lines</code> values are non-negative</li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V2/#script-migration-example","title":"Script Migration Example","text":"<p>Before (v1.x): <pre><code>#!/bin/bash\nsimplecov-mcp list --json --stale error --sort-order ascending\nsimplecov-mcp summary lib/foo.rb --json\nsimplecov-mcp uncovered lib/bar.rb --source=uncovered --source-context 3\nsimplecov-mcp --success-predicate policy.rb\n</code></pre></p> <p>After (v2.x): <pre><code>#!/bin/bash\nsimplecov-mcp --format json --staleness error --sort-order ascending list\nsimplecov-mcp --format json summary lib/foo.rb\nsimplecov-mcp --source uncovered --context-lines 3 uncovered lib/bar.rb\nsimplecov-mcp validate policy.rb\n</code></pre></p>"},{"location":"user/migrations/MIGRATING_TO_V2/#environment-variable-migration","title":"Environment Variable Migration","text":"<p>Before (v1.x): <pre><code>export SIMPLECOV_MCP_OPTS=\"--stale error --json\"\n</code></pre></p> <p>After (v2.x): <pre><code>export COV_LOUPE_OPTS=\"--staleness error --format json\"\n</code></pre></p>"},{"location":"user/migrations/MIGRATING_TO_V2/#getting-help","title":"Getting Help","text":"<p>If you encounter issues migrating to v2.0:</p> <ol> <li>Check the Troubleshooting guide</li> <li>Review the CLI Usage for complete CLI reference</li> <li>See MCP Integration for MCP tool documentation</li> <li>Open an issue at https://github.com/keithrbennett/simplecov-mcp/issues</li> </ol> <p>See also: - RELEASE_NOTES.md - Full release notes with new features - CLI Usage - Complete CLI reference - MCP Integration - MCP tool reference</p>"},{"location":"user/migrations/MIGRATING_TO_V3/","title":"V3.0 Breaking Changes Guide","text":"<p>Back to main README</p> <p>This document describes the breaking changes introduced in version 3.0.0, which primarily involve the renaming of the gem from <code>simplecov-mcp</code> to <code>cov-loupe</code>. These changes affect the gem name, executable, Ruby API, and configuration.</p>"},{"location":"user/migrations/MIGRATING_TO_V3/#what-changed","title":"What Changed","text":"<p>The project has been completely renamed, impacting various aspects:</p>"},{"location":"user/migrations/MIGRATING_TO_V3/#gem-executable","title":"Gem &amp; Executable","text":"<ul> <li>Gem name: <code>simplecov-mcp</code> \u2192 <code>cov-loupe</code></li> <li>Executable: <code>simplecov-mcp</code> \u2192 <code>cov-loupe</code></li> <li>Repository: <code>github.com/keithrbennett/simplecov-mcp</code> \u2192 <code>github.com/keithrbennett/cov-loupe</code></li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V3/#ruby-api","title":"Ruby API","text":"<ul> <li>Module Name: <code>SimpleCovMcp</code> \u2192 <code>CovLoupe</code></li> <li>Require Path: <code>require 'simplecov_mcp'</code> \u2192 <code>require 'cov_loupe'</code></li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V3/#configuration","title":"Configuration","text":"<ul> <li>Environment variable: <code>SIMPLECOV_MCP_OPTS</code> \u2192 <code>COV_LOUPE_OPTS</code></li> <li>Log file: <code>simplecov_mcp.log</code> \u2192 <code>cov_loupe.log</code></li> <li>Documentation alias: <code>smcp</code> \u2192 <code>clp</code></li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V3/#what-stayed-the-same","title":"What Stayed the Same","text":"<ul> <li>Core functionality: No breaking changes to features, CLI command logic (other than the executable name), or the internal structure of the <code>CoverageModel</code> logic.</li> <li>MCP Protocol: The JSON-RPC tool definitions and behaviors remain consistent.</li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V3/#migration-steps","title":"Migration Steps","text":"<p>To upgrade from <code>simplecov-mcp</code> (v2.x) to <code>cov-loupe</code> (v3.x), follow these steps:</p> <ol> <li> <p>Uninstall the old gem:     <pre><code>gem uninstall simplecov-mcp\n</code></pre></p> </li> <li> <p>Install the new gem:     <pre><code>gem install cov-loupe\n</code></pre></p> </li> <li> <p>Update scripts and aliases:</p> <ul> <li>Change all occurrences of the <code>simplecov-mcp</code> command to <code>cov-loupe</code> in your shell scripts, CI/CD configurations, and shell aliases.</li> </ul> </li> <li> <p>Update Ruby code:</p> <ul> <li>Find: <code>require 'simplecov_mcp'</code></li> <li>Replace with: <code>require 'cov_loupe'</code></li> <li>Find: <code>SimpleCovMcp</code></li> <li>Replace with: <code>CovLoupe</code></li> </ul> </li> <li> <p>Update environment variables:</p> <ul> <li>Rename any <code>SIMPLECOV_MCP_OPTS</code> environment variables to <code>COV_LOUPE_OPTS</code>.</li> </ul> </li> <li> <p>Update log file references:</p> <ul> <li>If you rely on the default log file, it will now be named <code>cov_loupe.log</code>. Update any scripts or tools that reference <code>simplecov_mcp.log</code>.</li> </ul> </li> </ol> <p>Note: The old <code>simplecov-mcp</code> gem (v2.0.1) will remain available on RubyGems but will not receive further updates.</p>"},{"location":"user/migrations/MIGRATING_TO_V3/#getting-help","title":"Getting Help","text":"<p>If you encounter issues migrating to v3.0:</p> <ol> <li>Check the Troubleshooting guide.</li> <li>Review the CLI Usage for complete CLI reference.</li> <li>See MCP Integration for MCP tool documentation.</li> <li>Open an issue at https://github.com/keithrbennett/cov-loupe/issues.</li> </ol>"},{"location":"user/migrations/MIGRATING_TO_V4/","title":"V4.0 Breaking Changes Guide","text":"<p>Back to main README</p> <p>This document describes the breaking changes introduced in version 4.0.0. These changes affect the CLI flags for mode selection and staleness checks, as well as a method rename in the Ruby API.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#table-of-contents","title":"Table of Contents","text":"<ul> <li>CLI Changes</li> <li>MCP Mode Now Requires Explicit <code>-m/--mode mcp</code> Flag</li> <li>Unified Stale Coverage Enforcement</li> <li><code>--raise-on-stale</code> / <code>-S</code> - Explicit Value Required</li> <li><code>--color</code> / <code>-C</code> - Explicit Value Required</li> <li><code>--tracked-globs</code> Default Changed to Empty Array</li> <li>Ruby API Changes</li> <li>CoverageLineResolver Now Requires <code>root:</code> and <code>volume_case_sensitive:</code></li> <li>Method Renamed</li> <li>Return Type Changed: <code>list</code> Now Returns a Hash</li> <li>Return Type Changed: <code>project_totals</code> Schema Updated</li> <li>Logger Initialization Changed</li> <li>Deleted Files Now Raise <code>FileNotFoundError</code></li> <li>Staleness Indicators Changed from Strings to Symbols</li> <li>Removed Branch-Only Coverage Support</li> <li>Getting Help</li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V4/#cli-changes","title":"CLI Changes","text":""},{"location":"user/migrations/MIGRATING_TO_V4/#mcp-mode-now-requires-explicit-m-mode-mcp-flag","title":"\u26a0\ufe0f MCP Mode Now Requires Explicit <code>-m/--mode mcp</code> Flag","text":"<p>BREAKING: Automatic mode detection has been removed.  The <code>-m/--mode mcp</code> flag is now required to run cov-loupe as an MCP server.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#previous-behavior-v3x","title":"Previous Behavior (v3.x)","text":"<ul> <li>cov-loupe automatically detected MCP mode based on TTY/stdin status</li> <li><code>--force-mode</code> could override detection (values: <code>cli</code>, <code>mcp</code>, <code>auto</code>)</li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V4/#new-behavior-v4x","title":"New Behavior (v4.x)","text":"<ul> <li>No automatic detection - mode defaults to <code>cli</code></li> <li><code>-m mcp</code> or <code>--mode mcp</code> is required for MCP server mode</li> <li>Accepted values: <code>cli</code> (default) or <code>mcp</code></li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V4/#migration-for-mcp-users","title":"Migration for MCP Users","text":"<p>If you use cov-loupe as an MCP server, you MUST update your configuration:</p> <ol> <li>Remove the old entry (see MCP Integration Guide - Setup by Client for removal commands with proper <code>--scope</code> options)</li> <li>Add the new entry with <code>-m mcp</code> flag:</li> </ol> <pre><code># Claude Code\nclaude mcp add cov-loupe cov-loupe -- -m mcp\n\n# Codex\ncodex mcp add cov-loupe cov-loupe -m mcp\n\n# Gemini\ngemini mcp add cov-loupe cov-loupe -- -m mcp\n</code></pre> <p>Without <code>-m mcp</code> or <code>--mode mcp</code>, the server will run in CLI mode and hang waiting for subcommands.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#migration-for-cli-users","title":"Migration for CLI Users","text":"<p>CLI users are unaffected. The default mode is <code>cli</code>, so no changes are needed. However: - <code>--force-cli</code> removed \u2192 use <code>-m cli</code> or <code>--mode cli</code> if you need to be explicit (rare) - <code>--force-mode</code> removed \u2192 use <code>-m/--mode</code> instead</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#unified-stale-coverage-enforcement","title":"Unified Stale Coverage Enforcement","text":"<p>The staleness checking logic has been unified into a single flag that raises an error if any staleness is detected.</p> <ul> <li>Old: <code>--staleness</code> / <code>check_stale</code> (inconsistent behavior)</li> <li>New: <code>--raise-on-stale</code> (boolean)</li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V4/#behavior","title":"Behavior","text":"<ul> <li><code>--raise-on-stale true</code> (or <code>raise_on_stale: true</code>): The command will exit with an error code if any file in the result set is stale or if the project totals are stale.</li> <li>Default (false): Staleness is reported in the output (e.g., status <code>M</code>, <code>T</code>, <code>L</code>), but the command returns success (unless other errors occur).</li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V4/#migration","title":"Migration","text":"<ul> <li>If you relied on previous flags to enforce staleness checks, switch to <code>--raise-on-stale true</code> or <code>-S true</code>.</li> </ul> <p>IMPORTANT: As of v4.0.0, boolean flags now require explicit values for consistency.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#raise-on-stale-s-explicit-value-required","title":"<code>--raise-on-stale</code> / <code>-S</code> - Explicit Value Required","text":"<ul> <li>Old (no longer works): <code>--raise-on-stale</code>, <code>-S</code></li> <li>New (required): <code>--raise-on-stale true</code>, <code>-S true</code>, <code>--raise-on-stale=yes</code>, etc.</li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V4/#color-c-explicit-value-required","title":"<code>--color</code> / <code>-C</code> - Explicit Value Required","text":"<ul> <li>Old (no longer works): <code>--color</code>, <code>-C</code></li> <li>New (required): <code>--color true</code>, <code>-C true</code>, <code>--color=on</code>, etc.</li> </ul> <p>These changes improve consistency between short and long flag forms and eliminate ambiguous behavior where long-form bare flags would fail but short-form bare flags would succeed.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#tracked-globs-default-changed-to-empty-array","title":"\u26a0\ufe0f --tracked-globs Default Changed to Empty Array","text":"<p>BREAKING: The <code>--tracked-globs</code> CLI option now defaults to <code>[]</code> (empty) instead of <code>lib/**/*.rb,app/**/*.rb,src/**/*.rb</code>. The Ruby API (<code>CoverageModel</code>) now also defaults <code>tracked_globs:</code> to <code>[]</code> (previously <code>nil</code>, which behaved the same).</p> <p>This affects: - CLI: <code>cov-loupe list</code> (without <code>--tracked-globs</code>) - Ruby API: <code>CoverageModel.new</code> (for consistency, though behavior is unchanged)</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#previous-behavior-v4x-early-versions","title":"Previous Behavior (v4.x early versions)","text":"<ul> <li><code>--tracked-globs</code> CLI option defaulted to <code>lib/**/*.rb,app/**/*.rb,src/**/*.rb</code></li> <li>Files outside these patterns were silently excluded from CLI output</li> <li><code>missing_tracked_files</code> (in <code>list</code>) included any tracked files not in coverage</li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V4/#new-behavior-v4x-current","title":"New Behavior (v4.x current)","text":"<ul> <li><code>--tracked-globs</code> defaults to <code>[]</code> (empty)</li> <li>Shows all files in the resultset without filtering</li> <li>No files are flagged as missing unless you explicitly set globs</li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V4/#rationale","title":"Rationale","text":"<p>The previous default caused three problems: 1. Silent exclusions: Coverage results for files not matching the default patterns (e.g., <code>config/</code>, custom directories) were hidden 2. False positives: Files like migrations, bin scripts, etc. were incorrectly flagged as \"missing\" 3. Wrong assumptions: Not all projects use <code>lib/</code> and <code>app/</code> - some use <code>src/</code>, others have custom structures</p> <p>The new default shows all coverage data transparently without making assumptions about your project structure.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#migration-steps","title":"Migration Steps","text":"<p>For CLI usage (if you want the old filtering behavior with <code>lib/**/*.rb,app/**/*.rb,src/**/*.rb</code>):</p> <p>Set <code>COV_LOUPE_OPTS</code> to match your SimpleCov <code>track_files</code> configuration:</p> <pre><code># In spec_helper.rb or similar\nSimpleCov.start do\n  add_filter '/spec/'\n  track_files 'lib/**/*.rb'\n  track_files 'app/**/*.rb'\nend\n</code></pre> <pre><code># In your shell config (.bashrc, .zshrc, etc.)\nexport COV_LOUPE_OPTS=\"--tracked-globs lib/**/*.rb,app/**/*.rb\"\n</code></pre> <p>For Ruby API usage:</p> <p>No functional changes needed, but the default signature has changed for consistency. The Ruby API now defaults <code>tracked_globs: []</code> (previously <code>nil</code>). Both behave identically, so existing code works unchanged:</p> <pre><code># Default behavior (behavior unchanged, signature updated for consistency)\nmodel = CovLoupe::CoverageModel.new(root: '.')\nresult = model.list  # tracked_globs: [] \u2192 no filtering\n\n# Explicit globs for filtering and tracking\nmodel = CovLoupe::CoverageModel.new(\n  root: '.',\n  tracked_globs: ['lib/**/*.rb', 'app/**/*.rb']\n)\nresult = model.list  # Uses explicit globs\n</code></pre> <p>If you're fine with seeing all files in the resultset (and only files in the resultset) (no action needed for CLI or Ruby API): - The new default shows all files that have coverage data - No filtering applied, but also no detection of files lacking coverage data</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#important-note","title":"Important Note","text":"<p>Files lacking any coverage at all (not loaded during tests) will not appear in the resultset and therefore won't be visible with the default empty array. To detect such files, you must set <code>--tracked-globs</code> to match the files you expect to have coverage.</p> <p>\u2191 Back to top</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#ruby-api-changes","title":"Ruby API Changes","text":""},{"location":"user/migrations/MIGRATING_TO_V4/#coveragelineresolver-now-requires-root-and-volume_case_sensitive","title":"CoverageLineResolver Now Requires <code>root:</code> and <code>volume_case_sensitive:</code>","text":"<p>Breaking Change: <code>CovLoupe::Resolvers::CoverageLineResolver</code> now requires <code>root:</code> and <code>volume_case_sensitive:</code> keyword arguments, and <code>CovLoupe::Resolvers::ResolverHelpers.lookup_lines</code> / <code>create_coverage_resolver</code> now require these parameters as well.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#migration_1","title":"Migration","text":"<pre><code># Old\nresolver = CovLoupe::Resolvers::CoverageLineResolver.new(cov_data)\nlines = CovLoupe::Resolvers::ResolverHelpers.lookup_lines(cov_data, abs_path)\n\n# New\nroot = '/path/to/project'\nvolume_case_sensitive = CovLoupe::PathUtils.volume_case_sensitive?(root)\nresolver = CovLoupe::Resolvers::CoverageLineResolver.new(cov_data, root: root, volume_case_sensitive: volume_case_sensitive)\nlines = CovLoupe::Resolvers::ResolverHelpers.lookup_lines(cov_data, abs_path, root: root, volume_case_sensitive: volume_case_sensitive)\n</code></pre> <p>Note: If you're using <code>CoverageModel</code> (recommended), this is handled automatically - the model detects volume case-sensitivity during initialization based on the project root and passes it to resolvers internally.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#method-renamed","title":"Method Renamed","text":"<ul> <li>Old: <code>CoverageModel#all_files_coverage</code></li> <li>New: <code>CoverageModel#list</code></li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V4/#return-type-changed-list-now-returns-a-hash","title":"Return Type Changed: <code>list</code> Now Returns a Hash","text":"<p>Breaking Change: <code>CoverageModel#list</code> now returns a hash containing comprehensive staleness information instead of just an array of file data.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#old-behavior-v3x","title":"Old Behavior (v3.x)","text":"<pre><code>model = CovLoupe::CoverageModel.new(root: '.')\nfiles = model.list  # Returns array directly\n\n# Filter and use the array\nlow_coverage = files.select { |f| f['percentage'] &lt; 80 }\nmodel.format_table(files)\n</code></pre>"},{"location":"user/migrations/MIGRATING_TO_V4/#new-behavior-v4x_1","title":"New Behavior (v4.x)","text":"<pre><code>model = CovLoupe::CoverageModel.new(root: '.')\nresult = model.list  # Returns hash with multiple keys\n\n# Access the files array\nfiles = result['files']\n\n# Filter and use the array\nlow_coverage = files.select { |f| f['percentage'] &lt; 80 }\nmodel.format_table(files)\n\n# Access new staleness information\nresult['skipped_files']          # Files that raised errors during processing\nresult['missing_tracked_files']  # Files from tracked_globs not in coverage\nresult['newer_files']             # Files modified after coverage was generated\nresult['deleted_files']           # Files in coverage that no longer exist\n</code></pre>"},{"location":"user/migrations/MIGRATING_TO_V4/#migration-steps_1","title":"Migration Steps","text":"<p>Option 1: Quick Fix (Extract files array) <pre><code># Old\nfiles = model.list\n\n# New\nfiles = model.list['files']\n</code></pre></p> <p>Option 2: Leverage New Staleness Data <pre><code>result = model.list\n\n# Use the files array as before\nfiles = result['files']\nlow_coverage = files.select { |f| f['percentage'] &lt; 80 }\n\n# Now you can also:\nif result['skipped_files'].any?\n  warn \"Warning: #{result['skipped_files'].size} files were skipped due to errors\"\n  result['skipped_files'].each do |skip|\n    warn \"  #{skip['file']}: #{skip['error']}\"\n  end\nend\n\nif result['newer_files'].any?\n  warn \"Warning: #{result['newer_files'].size} files are newer than coverage data\"\nend\n</code></pre></p>"},{"location":"user/migrations/MIGRATING_TO_V4/#impact-on-format_table","title":"Impact on <code>format_table</code>","text":"<p>The <code>format_table</code> method still accepts an array of file hashes (not the full hash from <code>list</code>):</p> <pre><code># Correct\nfiles = model.list['files']\ntable = model.format_table(files)\n\n# Also correct (passing nil gets all files)\ntable = model.format_table(nil)\n\n# Incorrect - do not pass the full hash\nresult = model.list\ntable = model.format_table(result)  # This will fail\n</code></pre>"},{"location":"user/migrations/MIGRATING_TO_V4/#return-type-changed-project_totals-schema-updated","title":"Return Type Changed: <code>project_totals</code> Schema Updated","text":"<p>Breaking Change: <code>CoverageModel#project_totals</code> now returns a structured hash with explicit <code>lines</code>, <code>tracking</code>, and <code>files</code> sections. The top-level <code>percentage</code> and <code>excluded_files</code> fields were removed.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#old-behavior-v3x_1","title":"Old Behavior (v3.x)","text":"<pre><code>totals = model.project_totals\n# =&gt; {\n#   \"lines\" =&gt; { \"total\" =&gt; 123, \"covered\" =&gt; 100, \"uncovered\" =&gt; 23 },\n#   \"percentage\" =&gt; 81.3,\n#   \"files\" =&gt; { \"total\" =&gt; 4, \"ok\" =&gt; 4, \"stale\" =&gt; 0 },\n#   \"excluded_files\" =&gt; { ... }\n# }\n</code></pre>"},{"location":"user/migrations/MIGRATING_TO_V4/#new-behavior-v4x_2","title":"New Behavior (v4.x)","text":"<pre><code>totals = model.project_totals\n# =&gt; {\n#   \"lines\" =&gt; { \"total\" =&gt; 123, \"covered\" =&gt; 100, \"uncovered\" =&gt; 23, \"percent_covered\" =&gt; 81.3 },\n#   \"tracking\" =&gt; { \"enabled\" =&gt; true, \"globs\" =&gt; [\"lib/**/*.rb\"] },\n#   \"files\" =&gt; {\n#     \"total\" =&gt; 4,\n#     \"with_coverage\" =&gt; { \"total\" =&gt; 4, \"ok\" =&gt; 4, \"stale\" =&gt; { \"total\" =&gt; 0, \"by_type\" =&gt; { ... } } }\n#   }\n# }\n</code></pre>"},{"location":"user/migrations/MIGRATING_TO_V4/#migration-steps_2","title":"Migration Steps","text":"<ul> <li>Replace <code>totals['percentage']</code> with <code>totals['lines']['percent_covered']</code>.</li> <li>Replace <code>totals['files']['ok']</code> and <code>totals['files']['stale']</code> with   <code>totals['files']['with_coverage']['ok']</code> and <code>totals['files']['with_coverage']['stale']['total']</code>.</li> <li>If you relied on <code>excluded_files</code>, use <code>files.with_coverage.stale.by_type</code> and   <code>files.without_coverage.by_type</code> (present only when tracking is enabled).</li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V4/#logger-initialization-changed","title":"Logger Initialization Changed","text":"<p>The <code>CovLoupe::Logger</code> class has updated its <code>initialize</code> signature.</p> <ul> <li>Old: <code>initialize(target:, mcp_mode: false)</code></li> <li>New: <code>initialize(target:, mode: :library)</code> # or :cli or :mcp</li> </ul>"},{"location":"user/migrations/MIGRATING_TO_V4/#migration_2","title":"Migration","text":"<p>If you are manually instantiating <code>CovLoupe::Logger</code>:</p> <pre><code># Old\nlogger = CovLoupe::Logger.new(target: 'cov_loupe.log', mcp_mode: true)\nlogger = CovLoupe::Logger.new(target: 'cov_loupe.log', mcp_mode: false)\n\n# New\nlogger = CovLoupe::Logger.new(target: 'cov_loupe.log', mode: :mcp)\nlogger = CovLoupe::Logger.new(target: 'cov_loupe.log', mode: :cli)     # or :library\n</code></pre> <p>\u2191 Back to top</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#deleted-files-now-raise-filenotfounderror","title":"Deleted Files Now Raise <code>FileNotFoundError</code>","text":"<p>Breaking Change: Querying a file that has been deleted (but still exists in the coverage resultset) now raises <code>FileNotFoundError</code> instead of returning stale coverage data.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#previous-behavior-v3x_1","title":"Previous Behavior (v3.x)","text":"<pre><code># File lib/foo.rb was deleted after running tests\nmodel = CovLoupe::CoverageModel.new(root: '.')\nresult = model.summary_for('lib/foo.rb')\n# =&gt; { 'file' =&gt; '/path/to/lib/foo.rb', 'summary' =&gt; { 'covered' =&gt; 4, 'total' =&gt; 6, 'percentage' =&gt; 66.67 } }\n# Returns stale coverage data with no error\n</code></pre> <pre><code># CLI would return coverage percentage and exit 0\n$ cov-loupe summary lib/foo.rb\nlib/foo.rb: 66.67% (4/6)\n$ echo $?\n0\n</code></pre>"},{"location":"user/migrations/MIGRATING_TO_V4/#new-behavior-v4x_3","title":"New Behavior (v4.x)","text":"<pre><code># File lib/foo.rb was deleted after running tests\nmodel = CovLoupe::CoverageModel.new(root: '.')\nresult = model.summary_for('lib/foo.rb')\n# =&gt; raises CovLoupe::FileNotFoundError: \"File not found: lib/foo.rb\"\n</code></pre> <pre><code># CLI raises error and exits 1\n$ cov-loupe summary lib/foo.rb\nError: File not found: lib/foo.rb\n$ echo $?\n1\n</code></pre>"},{"location":"user/migrations/MIGRATING_TO_V4/#rationale_1","title":"Rationale","text":"<p>Deleted files represent stale data that: 1. Misleads coverage metrics and statistics 2. Violates the API contract (docstring already promised <code>FileNotFoundError</code>) 3. Should be treated the same as other staleness issues</p> <p>If a file no longer exists, its coverage data is no longer meaningful. The new behavior ensures you don't accidentally include deleted file coverage in your metrics.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#impact","title":"Impact","text":"<p>This affects: - <code>model.summary_for(path)</code> - All single-file query methods - <code>model.raw_for(path)</code> - <code>model.uncovered_for(path)</code> - <code>model.detailed_for(path)</code> - CLI commands: <code>summary</code>, <code>raw</code>, <code>uncovered</code>, <code>detailed</code> - MCP tools: <code>coverage_summary_tool</code>, <code>coverage_raw_tool</code>, etc.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#migration_3","title":"Migration","text":"<p>If you expect deleted files to raise errors (recommended): - No action needed. This is the correct behavior.</p> <p>If you relied on getting coverage for deleted files: - This was incorrect behavior. Update your workflow to:   1. Re-run tests after file deletions to get fresh coverage, OR   2. Use the <code>list</code> command to see deleted files in the <code>deleted_files</code> array without querying them directly</p> <p>Example: Checking for deleted files <pre><code>model = CovLoupe::CoverageModel.new(root: '.')\nresult = model.list\n\nif result['deleted_files'].any?\n  puts \"Warning: Coverage data exists for deleted files:\"\n  result['deleted_files'].each { |f| puts \"  - #{f}\" }\nend\n</code></pre></p> <p>\u2191 Back to top</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#staleness-indicators-changed-from-strings-to-symbols","title":"Staleness Indicators Changed from Strings to Symbols","text":"<p>Breaking Change: Staleness indicators in the <code>stale</code> field now use Ruby symbols instead of single-character strings.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#previous-behavior-v3x_2","title":"Previous Behavior (v3.x)","text":"<pre><code>result = model.list\n# =&gt; { 'files' =&gt; [{ 'file' =&gt; 'lib/foo.rb', 'stale' =&gt; 'M', ... }], ... }\n\n# Staleness was indicated by strings:\n# 'M' - Missing file\n# 'T' - Timestamp mismatch\n# 'L' - Line count mismatch\n# 'E' - Error during staleness check\n# false - Fresh coverage data\n</code></pre>"},{"location":"user/migrations/MIGRATING_TO_V4/#new-behavior-v4x_4","title":"New Behavior (v4.x)","text":"<pre><code>result = model.list\n# =&gt; { 'files' =&gt; [{ 'file' =&gt; 'lib/foo.rb', 'stale' =&gt; \"missing\", ... }], ... }\n\n# Staleness is now indicated by symbols:\n# \"missing\" - Missing file\n# \"newer\" - Timestamp mismatch\n# \"length_mismatch\" - Line count mismatch\n# \"error\" - Error during staleness check\n# \"ok\" - Fresh coverage data\n</code></pre>"},{"location":"user/migrations/MIGRATING_TO_V4/#rationale_2","title":"Rationale","text":"<p>Symbols are more idiomatic in Ruby for enumerated values and provide: - Better performance: Symbols are interned, so comparisons are faster - Clearer semantics: Symbols represent categories/concepts, not text - Consistency: Aligns with Ruby conventions for status indicators - Type safety: Symbol vs String distinction catches bugs</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#impact_1","title":"Impact","text":"<p>This affects code that: - Checks equality with string literals: <code>stale == 'M'</code> will no longer match - Uses string pattern matching: Case statements with string patterns need updating - Serializes to JSON: Symbols are converted to strings in JSON output - Type checks: <code>stale.is_a?(Symbol)</code> instead of <code>stale.is_a?(String)</code></p> <p>Frequency: High - affects any code that checks staleness status.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#migration_4","title":"Migration","text":"<p>If you check equality with string literals: <pre><code># Old\nif file['stale'] == 'M'\n  puts \"File is missing\"\nend\n\n# New - use symbols\nif file['stale'] == 'missing'\n  puts \"File is missing\"\nend\n\n# Or use string comparison (less efficient but works with both versions)\nif file['stale'].to_s == 'missing'\n  puts \"File is missing\"\nend\n</code></pre></p> <p>If you use case statements with string patterns: <pre><code># Old\ncase file['stale']\nwhen 'M' then handle_missing\nwhen 'T' then handle_timestamp\nwhen 'L' then handle_length\nwhen 'E' then handle_error\nwhen false then handle_fresh\nend\n\n# New - use symbols\ncase file['stale']\nwhen 'missing' then handle_missing\nwhen 'newer' then handle_timestamp\nwhen 'length_mismatch' then handle_length\nwhen 'error' then handle_error\nwhen 'ok' then handle_fresh\nend\n\n# Or use to_s for backward compatibility\ncase file['stale'].to_s\nwhen 'missing' then handle_missing\nwhen 'newer' then handle_timestamp\nwhen 'length_mismatch' then handle_length\nwhen 'error' then handle_error\nwhen 'ok' then handle_fresh\nend\n</code></pre></p> <p>If you check for any staleness: <pre><code># Old (works for both versions)\nif file['stale']\n  puts \"Stale file (#{file['stale']})\"\nend\n\n# New - explicit type check\nif file['stale'].is_a?(Symbol)\n  puts \"Stale file (#{file['stale']})\"\nend\n\n# Or use the same approach (works for both versions)\nif file['stale']\n  puts \"Stale file (#{file['stale']})\"\nend\n</code></pre></p> <p>JSON serialization note: When serializing to JSON (CLI, MCP, etc.), symbols are automatically converted to strings: <pre><code># In Ruby\nfile['stale']  # =&gt; \"missing\"\n\n# In JSON output\n{ \"file\": \"lib/foo.rb\", \"stale\": \"missing\" }\n</code></pre></p> <p>Table output legend updated: <pre><code>Staleness: missing = Missing file, newer = Timestamp mismatch, length_mismatch = Line count mismatch, error = Check failed\n</code></pre></p>"},{"location":"user/migrations/MIGRATING_TO_V4/#complete-staleness-value-reference","title":"Complete Staleness Value Reference","text":"Status v3.x (String) v4.x (Symbol) Description Fresh <code>false</code> <code>\"ok\"</code> Coverage data is current Missing file <code>'M'</code> <code>\"missing\"</code> File no longer exists on disk Timestamp mismatch <code>'T'</code> <code>\"newer\"</code> File modified after coverage was generated Line count mismatch <code>'L'</code> <code>\"length_mismatch\"</code> Source file line count differs from coverage data Check error <code>'E'</code> <code>\"error\"</code> Staleness check failed (permissions, I/O errors, etc.) <p>\u2191 Back to top</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#removed-branch-only-coverage-support","title":"Removed Branch-Only Coverage Support","text":"<p>Breaking Change: The automatic synthesis of line coverage data from SimpleCov branch-only coverage results has been removed.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#rationale_3","title":"Rationale","text":"<p>The logic required to maintain this feature was complex and prone to edge cases, particularly regarding staleness detection and line-count mismatches. Additionally, branch-only coverage is a rarely used configuration in the SimpleCov ecosystem.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#impact_2","title":"Impact","text":"<p>If your project is configured to track only branch coverage in SimpleCov (e.g., <code>enable_coverage :branch</code> without also tracking lines), <code>cov-loupe</code> will no longer be able to process your coverage data and will raise a <code>CorruptCoverageDataError</code>.</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#how-to-migrate","title":"How to Migrate","text":"<p>Most users do not need to take any action. Line coverage is enabled by default in SimpleCov.</p> <p>If you have <code>enable_coverage :branch</code> in your configuration, your <code>.resultset.json</code> contains both <code>lines</code> and <code>branches</code> data. This is fully supported. <code>cov-loupe</code> will read and report the <code>lines</code> coverage as usual.</p> <p>The change in v4.0 is simply that <code>cov-loupe</code> no longer looks at the <code>branches</code> data at all. Previously, if <code>lines</code> data was missing (a rare edge case), <code>cov-loupe</code> would attempt to calculate line coverage by summing up branch hits. This fallback logic has been removed.</p> <p>\u2191 Back to top</p>"},{"location":"user/migrations/MIGRATING_TO_V4/#getting-help","title":"Getting Help","text":"<p>If you encounter issues migrating to v4.0:</p> <ol> <li>Check the TROUBLESHOOTING.md guide.</li> <li>Review the CLI_USAGE.md for complete CLI reference.</li> <li>Open an issue at https://github.com/keithrbennett/cov-loupe/issues.</li> </ol>"},{"location":"user/prompts/","title":"Prompt Library","text":"<p>Back to main README</p> <p>Starter prompts you can paste into MCP-compatible assistants when you need cov-loupe to run targeted reports or fall back to CLI execution.</p> <ul> <li>Coverage Analysis \u2013 Analyze coverage for any Ruby project; adapts component categories to the framework in use (Rails example included)</li> <li>Use CLI Instead of MCP \u2013 Include in another prompt to instruct the model to use cov-loupe CLI as a fallback when MCP transport is blocked or unavailable</li> </ul>"},{"location":"user/prompts/coverage-analysis-prompt/","title":"Test Coverage Analysis Prompt for Ruby Projects","text":"<p>Back to main README</p> <p>Use the cov-loupe MCP server tool to analyze the test coverage data generated by simplecov for this Ruby project. Generate a detailed coverage analysis report and output it to a markdown file named <code>test_coverage_analysis.md</code>.</p> <p>Before diving into the sections below, identify the project type by examining the Gemfile, directory structure, and file-naming conventions (e.g., Rails app, CLI tool, service library, microservice). Adapt the component categories in sections 2 and 6 to match what is actually present \u2014 the Rails-specific names used as examples throughout are illustrative, not prescriptive.</p> <p>The report should include:</p>"},{"location":"user/prompts/coverage-analysis-prompt/#1-executive-summary","title":"1. Executive Summary","text":"<ul> <li>Overall coverage percentage and trend direction</li> <li>High-level assessment of testing health across the application</li> <li>Key strengths and critical gaps at a glance</li> </ul>"},{"location":"user/prompts/coverage-analysis-prompt/#2-coverage-by-application-component","title":"2. Coverage by Application Component","text":"<p>Detailed analysis of coverage across the application layers that are present in this project.</p> <p>For a Rails app these are typically: Models, Controllers, Views, Mailers, Jobs, Services/POROs, Concerns, Lib files, Configuration.</p> <p>For a non-web Ruby app these are typically: Core Domain Logic, Services/Commands, Data Access Layer, External Integrations, Utilities/Helpers, CLI Components, Configuration, Lib files, Concerns/Mixins.</p> <p>Adapt this list to the actual project \u2014 drop categories that don't exist, add any that do.</p>"},{"location":"user/prompts/coverage-analysis-prompt/#3-well-tested-areas","title":"3. Well-Tested Areas","text":"<ul> <li>What's working well and why</li> <li>Testing patterns and practices to replicate</li> <li>Examples of strong test coverage with specific file references</li> </ul>"},{"location":"user/prompts/coverage-analysis-prompt/#4-poorly-tested-areas","title":"4. Poorly-Tested Areas","text":"<p>Organize by: - Complexity to Test: Simple/Moderate/Complex (considering dependencies, I/O operations, external services, etc.) - Risk Level: High/Medium/Low (impact on data integrity, system reliability, business logic correctness) - Coverage Gap Size: Percentage of uncovered lines and number of untested methods</p>"},{"location":"user/prompts/coverage-analysis-prompt/#5-priority-issues-table","title":"5. Priority Issues Table","text":"<p>Create a markdown table with these columns: - File/Module Path - Component Type (Model/Service/Domain/Integration/etc.) - Current Coverage % - Uncovered Lines Count - Risk Level (High/Medium/Low) - Complexity to Fix (High/Medium/Low) - Priority Score (1-10, with 10 being highest priority) - Recommended Action (specific next steps)</p> <p>Sort by Priority Score descending.</p>"},{"location":"user/prompts/coverage-analysis-prompt/#6-framework-specific-testing-analysis","title":"6. Framework-Specific Testing Analysis","text":"<p>Cover the topics that apply to this project. For a Rails app: - Model Testing: Validations, associations, scopes, callbacks, custom methods - Controller Testing: Happy paths vs error handling, authentication/authorization - Integration Testing: Request specs, feature specs, system tests - API Testing: JSON/XML responses, API versioning - Database Operations: Migrations, seeds, complex queries - Background Jobs: Execution, retry logic, error handling - Security: Authentication, authorization, input sanitization, CSRF protection - Missing Test Types: Unit/integration/system/feature test gaps</p> <p>For a non-web Ruby app, focus instead on: - Domain Logic Testing: Business rules, validations, calculations, state transitions - Service Layer Testing: Orchestration logic, error handling, transaction boundaries - Data Access Testing: Queries, data transformations, persistence operations - Integration Testing: Interactions between components and external systems - API Client Testing: HTTP requests, response parsing, error handling - File I/O Operations: Reading/writing, parsing, serialization - Concurrency/Threading: Thread-safe operations and race conditions (if applicable) - Error Handling: Exception handling, retry logic, fallback mechanisms</p> <p>Include the security and missing-test-types bullets regardless of project type.</p>"},{"location":"user/prompts/coverage-analysis-prompt/#7-common-testing-anti-patterns-detected","title":"7. Common Testing Anti-Patterns Detected","text":"<p>Report only those actually observed: - Unnecessary verbosity \u2014 identical or near-identical code fragments that should be deduplicated using input arrays, extracted methods, shared examples, etc. - Over-reliance on controller tests vs request specs (Rails) - Over-mocking leading to brittle tests - Missing edge case coverage in core domain / model logic - Untested error handling and failure scenarios - Missing tests for background jobs and mailers (Rails) - Missing tests for external service integrations - Lack of integration tests for critical user flows / workflows - Untested authorization/permission logic - Untested concurrency or threading logic (if applicable) - Insufficient testing of data transformation pipelines - Missing tests for CLI argument parsing and validation (if applicable)</p>"},{"location":"user/prompts/coverage-analysis-prompt/#8-actionable-testing-roadmap","title":"8. Actionable Testing Roadmap","text":"<p>Prioritized list of specific issues to resolve, organized by effort level: - Quick Wins (&lt; 2 hours): Simple tests with high impact - Sprint 1 (2-8 hours): Medium complexity, high priority - Sprint 2 (1-2 days): Complex but critical coverage gaps - Long-term (&gt; 2 days): Large refactoring or architectural test improvements</p> <p>Also flag testing infrastructure issues \u2014 inadequate fixtures, missing helpers, or code patterns that make tests brittle \u2014 and place them in the Long-term bucket.</p> <p>Include specific file paths, method names, and recommended testing approaches for each item.</p>"},{"location":"user/prompts/coverage-analysis-prompt/#9-metrics-dashboard","title":"9. Metrics Dashboard","text":"<p>Key numbers: - Overall coverage percentage - Number of files at 0% coverage - Number of files at 100% coverage - Number of files above 90% coverage - Number of files below 50% coverage - Coverage by component type (adapted to project) - Trend direction (if historical data available) - Lines of code vs lines of test code ratio - Average cyclomatic complexity of untested methods (if available)</p>"},{"location":"user/prompts/coverage-analysis-prompt/#10-risk-assessment","title":"10. Risk Assessment","text":"<ul> <li>Critical Paths: Identify core user journeys / business workflows and their test coverage</li> <li>High-Risk Untested Code: Payment processing, authentication, data deletion, financial calculations, etc.</li> <li>Security Implications: Areas where lack of tests could lead to vulnerabilities</li> <li>Technical Debt: Old code with no tests that should be prioritized for coverage</li> <li>External Dependencies: Integration points with poor test coverage</li> <li>Data Integrity Risks: Operations that modify or delete data without adequate test coverage</li> </ul> <p>Include specific file paths, line numbers, and code examples where relevant. Focus on actionable insights rather than just reporting numbers. Provide concrete recommendations for improving the test suite architecture and coverage strategy.</p>"},{"location":"user/prompts/use-cli-not-mcp-prompt/","title":"Use cov-loupe CLI as a fallback when the MCP server is unavailable","text":"<p>Back to main README</p> <p>The <code>cov-loupe</code> application provides precise test coverage information for your Ruby application. It reads the <code>.resultset.json</code> file generated by SimpleCov and exposes that data through multiple subcommands.</p> <p>Ideally it is configured as an MCP server so you can call its tools directly. If the MCP server is unavailable or errors prevent tool calls from succeeding, fall back to the CLI.</p>"},{"location":"user/prompts/use-cli-not-mcp-prompt/#fallback-instructions","title":"Fallback instructions","text":"<ol> <li> <p>Detect the failure \u2013 if any MCP tool call fails or the server is unreachable, do not    retry it or attempt to read <code>.resultset.json</code> manually. Switch to CLI mode immediately.</p> </li> <li> <p>Run CLI commands using <code>bundle exec exe/cov-loupe &lt;subcommand&gt;</code> (or <code>cov-loupe    &lt;subcommand&gt;</code> when the gem is installed globally). The subcommands mirror the MCP tools:</p> </li> </ol> MCP tool CLI subcommand Example <code>list_tool</code> <code>list</code> <code>cov-loupe list</code> <code>coverage_summary_tool</code> <code>summary &lt;path&gt;</code> <code>cov-loupe summary lib/foo.rb</code> <code>coverage_raw_tool</code> <code>raw &lt;path&gt;</code> <code>cov-loupe raw lib/foo.rb</code> <code>uncovered_lines_tool</code> <code>uncovered &lt;path&gt;</code> <code>cov-loupe uncovered lib/foo.rb</code> <code>coverage_detailed_tool</code> <code>detailed &lt;path&gt;</code> <code>cov-loupe detailed lib/foo.rb</code> <code>coverage_totals_tool</code> <code>totals</code> <code>cov-loupe totals</code> <code>validate_tool</code> <code>validate &lt;expr&gt;</code> <code>cov-loupe validate 'pct &gt;= 90'</code> <code>version_tool</code> <code>version</code> <code>cov-loupe version</code> <ol> <li> <p>Use <code>--help</code> at any point to get up-to-date flag and argument information:    <pre><code>cov-loupe --help\ncov-loupe list --help\n</code></pre></p> </li> <li> <p>Treat CLI output as authoritative \u2013 do not estimate or infer coverage figures from    source files or test files. All data must come from <code>cov-loupe</code> output.</p> </li> <li> <p>Report the fallback \u2013 briefly note in your response that you used the CLI rather than    the MCP server, so the user knows which mode was active.</p> </li> </ol>"}]}